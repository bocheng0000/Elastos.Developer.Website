<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"elastos-trinity-plugins-qrscanner_node_modules_webrtc-adapter_out_adapter.js.html":{"id":"elastos-trinity-plugins-qrscanner_node_modules_webrtc-adapter_out_adapter.js.html","title":"Source: elastos-trinity-plugins-qrscanner/node_modules/webrtc-adapter/out/adapter.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: elastos-trinity-plugins-qrscanner/node_modules/webrtc-adapter/out/adapter.js (function(f){if(typeof exports===\"object\"&amp;&amp;typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&amp;&amp;define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.adapter = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&amp;&amp;require;if(!u&amp;&amp;a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&amp;&amp;require;for(var o=0;o&lt;r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){ /* eslint-env node */ 'use strict'; // SDP helpers. var SDPUtils = {}; // Generate an alphanumeric identifier for cname or mids. // TODO: use UUIDs instead? https://gist.github.com/jed/982883 SDPUtils.generateIdentifier = function() { return Math.random().toString(36).substr(2, 10); }; // The RTCP CNAME used by all peerconnections from the same JS. SDPUtils.localCName = SDPUtils.generateIdentifier(); // Splits SDP into lines, dealing with both CRLF and LF. SDPUtils.splitLines = function(blob) { return blob.trim().split('\\n').map(function(line) { return line.trim(); }); }; // Splits SDP into sessionpart and mediasections. Ensures CRLF. SDPUtils.splitSections = function(blob) { var parts = blob.split('\\nm='); return parts.map(function(part, index) { return (index &gt; 0 ? 'm=' + part : part).trim() + '\\r\\n'; }); }; // Returns lines that start with a certain prefix. SDPUtils.matchPrefix = function(blob, prefix) { return SDPUtils.splitLines(blob).filter(function(line) { return line.indexOf(prefix) === 0; }); }; // Parses an ICE candidate line. Sample input: // candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8 // rport 55996\" SDPUtils.parseCandidate = function(line) { var parts; // Parse both variants. if (line.indexOf('a=candidate:') === 0) { parts = line.substring(12).split(' '); } else { parts = line.substring(10).split(' '); } var candidate = { foundation: parts[0], component: parseInt(parts[1], 10), protocol: parts[2].toLowerCase(), priority: parseInt(parts[3], 10), ip: parts[4], port: parseInt(parts[5], 10), // skip parts[6] == 'typ' type: parts[7] }; for (var i = 8; i &lt; parts.length; i += 2) { switch (parts[i]) { case 'raddr': candidate.relatedAddress = parts[i + 1]; break; case 'rport': candidate.relatedPort = parseInt(parts[i + 1], 10); break; case 'tcptype': candidate.tcpType = parts[i + 1]; break; default: // extension handling, in particular ufrag candidate[parts[i]] = parts[i + 1]; break; } } return candidate; }; // Translates a candidate object into SDP candidate attribute. SDPUtils.writeCandidate = function(candidate) { var sdp = []; sdp.push(candidate.foundation); sdp.push(candidate.component); sdp.push(candidate.protocol.toUpperCase()); sdp.push(candidate.priority); sdp.push(candidate.ip); sdp.push(candidate.port); var type = candidate.type; sdp.push('typ'); sdp.push(type); if (type !== 'host' &amp;&amp; candidate.relatedAddress &amp;&amp; candidate.relatedPort) { sdp.push('raddr'); sdp.push(candidate.relatedAddress); // was: relAddr sdp.push('rport'); sdp.push(candidate.relatedPort); // was: relPort } if (candidate.tcpType &amp;&amp; candidate.protocol.toLowerCase() === 'tcp') { sdp.push('tcptype'); sdp.push(candidate.tcpType); } return 'candidate:' + sdp.join(' '); }; // Parses an ice-options line, returns an array of option tags. // a=ice-options:foo bar SDPUtils.parseIceOptions = function(line) { return line.substr(14).split(' '); } // Parses an rtpmap line, returns RTCRtpCoddecParameters. Sample input: // a=rtpmap:111 opus/48000/2 SDPUtils.parseRtpMap = function(line) { var parts = line.substr(9).split(' '); var parsed = { payloadType: parseInt(parts.shift(), 10) // was: id }; parts = parts[0].split('/'); parsed.name = parts[0]; parsed.clockRate = parseInt(parts[1], 10); // was: clockrate // was: channels parsed.numChannels = parts.length === 3 ? parseInt(parts[2], 10) : 1; return parsed; }; // Generate an a=rtpmap line from RTCRtpCodecCapability or // RTCRtpCodecParameters. SDPUtils.writeRtpMap = function(codec) { var pt = codec.payloadType; if (codec.preferredPayloadType !== undefined) { pt = codec.preferredPayloadType; } return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate + (codec.numChannels !== 1 ? '/' + codec.numChannels : '') + '\\r\\n'; }; // Parses an a=extmap line (headerextension from RFC 5285). Sample input: // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset // a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset SDPUtils.parseExtmap = function(line) { var parts = line.substr(9).split(' '); return { id: parseInt(parts[0], 10), direction: parts[0].indexOf('/') &gt; 0 ? parts[0].split('/')[1] : 'sendrecv', uri: parts[1] }; }; // Generates a=extmap line from RTCRtpHeaderExtensionParameters or // RTCRtpHeaderExtension. SDPUtils.writeExtmap = function(headerExtension) { return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) + (headerExtension.direction &amp;&amp; headerExtension.direction !== 'sendrecv' ? '/' + headerExtension.direction : '') + ' ' + headerExtension.uri + '\\r\\n'; }; // Parses an ftmp line, returns dictionary. Sample input: // a=fmtp:96 vbr=on;cng=on // Also deals with vbr=on; cng=on SDPUtils.parseFmtp = function(line) { var parsed = {}; var kv; var parts = line.substr(line.indexOf(' ') + 1).split(';'); for (var j = 0; j &lt; parts.length; j++) { kv = parts[j].trim().split('='); parsed[kv[0].trim()] = kv[1]; } return parsed; }; // Generates an a=ftmp line from RTCRtpCodecCapability or RTCRtpCodecParameters. SDPUtils.writeFmtp = function(codec) { var line = ''; var pt = codec.payloadType; if (codec.preferredPayloadType !== undefined) { pt = codec.preferredPayloadType; } if (codec.parameters &amp;&amp; Object.keys(codec.parameters).length) { var params = []; Object.keys(codec.parameters).forEach(function(param) { params.push(param + '=' + codec.parameters[param]); }); line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\\r\\n'; } return line; }; // Parses an rtcp-fb line, returns RTCPRtcpFeedback object. Sample input: // a=rtcp-fb:98 nack rpsi SDPUtils.parseRtcpFb = function(line) { var parts = line.substr(line.indexOf(' ') + 1).split(' '); return { type: parts.shift(), parameter: parts.join(' ') }; }; // Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters. SDPUtils.writeRtcpFb = function(codec) { var lines = ''; var pt = codec.payloadType; if (codec.preferredPayloadType !== undefined) { pt = codec.preferredPayloadType; } if (codec.rtcpFeedback &amp;&amp; codec.rtcpFeedback.length) { // FIXME: special handling for trr-int? codec.rtcpFeedback.forEach(function(fb) { lines += 'a=rtcp-fb:' + pt + ' ' + fb.type + (fb.parameter &amp;&amp; fb.parameter.length ? ' ' + fb.parameter : '') + '\\r\\n'; }); } return lines; }; // Parses an RFC 5576 ssrc media attribute. Sample input: // a=ssrc:3735928559 cname:something SDPUtils.parseSsrcMedia = function(line) { var sp = line.indexOf(' '); var parts = { ssrc: parseInt(line.substr(7, sp - 7), 10) }; var colon = line.indexOf(':', sp); if (colon &gt; -1) { parts.attribute = line.substr(sp + 1, colon - sp - 1); parts.value = line.substr(colon + 1); } else { parts.attribute = line.substr(sp + 1); } return parts; }; // Extracts the MID (RFC 5888) from a media section. // returns the MID or undefined if no mid line was found. SDPUtils.getMid = function(mediaSection) { var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0]; if (mid) { return mid.substr(6); } } SDPUtils.parseFingerprint = function(line) { var parts = line.substr(14).split(' '); return { algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge. value: parts[1] }; }; // Extracts DTLS parameters from SDP media section or sessionpart. // FIXME: for consistency with other functions this should only // get the fingerprint line as input. See also getIceParameters. SDPUtils.getDtlsParameters = function(mediaSection, sessionpart) { var lines = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=fingerprint:'); // Note: a=setup line is ignored since we use the 'auto' role. // Note2: 'algorithm' is not case sensitive except in Edge. return { role: 'auto', fingerprints: lines.map(SDPUtils.parseFingerprint) }; }; // Serializes DTLS parameters to SDP. SDPUtils.writeDtlsParameters = function(params, setupType) { var sdp = 'a=setup:' + setupType + '\\r\\n'; params.fingerprints.forEach(function(fp) { sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\\r\\n'; }); return sdp; }; // Parses ICE information from SDP media section or sessionpart. // FIXME: for consistency with other functions this should only // get the ice-ufrag and ice-pwd lines as input. SDPUtils.getIceParameters = function(mediaSection, sessionpart) { var lines = SDPUtils.splitLines(mediaSection); // Search in session part, too. lines = lines.concat(SDPUtils.splitLines(sessionpart)); var iceParameters = { usernameFragment: lines.filter(function(line) { return line.indexOf('a=ice-ufrag:') === 0; })[0].substr(12), password: lines.filter(function(line) { return line.indexOf('a=ice-pwd:') === 0; })[0].substr(10) }; return iceParameters; }; // Serializes ICE parameters to SDP. SDPUtils.writeIceParameters = function(params) { return 'a=ice-ufrag:' + params.usernameFragment + '\\r\\n' + 'a=ice-pwd:' + params.password + '\\r\\n'; }; // Parses the SDP media section and returns RTCRtpParameters. SDPUtils.parseRtpParameters = function(mediaSection) { var description = { codecs: [], headerExtensions: [], fecMechanisms: [], rtcp: [] }; var lines = SDPUtils.splitLines(mediaSection); var mline = lines[0].split(' '); for (var i = 3; i &lt; mline.length; i++) { // find all codecs from mline[3..] var pt = mline[i]; var rtpmapline = SDPUtils.matchPrefix( mediaSection, 'a=rtpmap:' + pt + ' ')[0]; if (rtpmapline) { var codec = SDPUtils.parseRtpMap(rtpmapline); var fmtps = SDPUtils.matchPrefix( mediaSection, 'a=fmtp:' + pt + ' '); // Only the first a=fmtp:&lt;pt&gt; is considered. codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {}; codec.rtcpFeedback = SDPUtils.matchPrefix( mediaSection, 'a=rtcp-fb:' + pt + ' ') .map(SDPUtils.parseRtcpFb); description.codecs.push(codec); // parse FEC mechanisms from rtpmap lines. switch (codec.name.toUpperCase()) { case 'RED': case 'ULPFEC': description.fecMechanisms.push(codec.name.toUpperCase()); break; default: // only RED and ULPFEC are recognized as FEC mechanisms. break; } } } SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(function(line) { description.headerExtensions.push(SDPUtils.parseExtmap(line)); }); // FIXME: parse rtcp. return description; }; // Generates parts of the SDP media section describing the capabilities / // parameters. SDPUtils.writeRtpDescription = function(kind, caps) { var sdp = ''; // Build the mline. sdp += 'm=' + kind + ' '; sdp += caps.codecs.length &gt; 0 ? '9' : '0'; // reject if no codecs. sdp += ' UDP/TLS/RTP/SAVPF '; sdp += caps.codecs.map(function(codec) { if (codec.preferredPayloadType !== undefined) { return codec.preferredPayloadType; } return codec.payloadType; }).join(' ') + '\\r\\n'; sdp += 'c=IN IP4 0.0.0.0\\r\\n'; sdp += 'a=rtcp:9 IN IP4 0.0.0.0\\r\\n'; // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb. caps.codecs.forEach(function(codec) { sdp += SDPUtils.writeRtpMap(codec); sdp += SDPUtils.writeFmtp(codec); sdp += SDPUtils.writeRtcpFb(codec); }); var maxptime = 0; caps.codecs.forEach(function(codec) { if (codec.maxptime &gt; maxptime) { maxptime = codec.maxptime; } }); if (maxptime &gt; 0) { sdp += 'a=maxptime:' + maxptime + '\\r\\n'; } sdp += 'a=rtcp-mux\\r\\n'; caps.headerExtensions.forEach(function(extension) { sdp += SDPUtils.writeExtmap(extension); }); // FIXME: write fecMechanisms. return sdp; }; // Parses the SDP media section and returns an array of // RTCRtpEncodingParameters. SDPUtils.parseRtpEncodingParameters = function(mediaSection) { var encodingParameters = []; var description = SDPUtils.parseRtpParameters(mediaSection); var hasRed = description.fecMechanisms.indexOf('RED') !== -1; var hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1; // filter a=ssrc:... cname:, ignore PlanB-msid var ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:') .map(function(line) { return SDPUtils.parseSsrcMedia(line); }) .filter(function(parts) { return parts.attribute === 'cname'; }); var primarySsrc = ssrcs.length &gt; 0 &amp;&amp; ssrcs[0].ssrc; var secondarySsrc; var flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID') .map(function(line) { var parts = line.split(' '); parts.shift(); return parts.map(function(part) { return parseInt(part, 10); }); }); if (flows.length &gt; 0 &amp;&amp; flows[0].length &gt; 1 &amp;&amp; flows[0][0] === primarySsrc) { secondarySsrc = flows[0][1]; } description.codecs.forEach(function(codec) { if (codec.name.toUpperCase() === 'RTX' &amp;&amp; codec.parameters.apt) { var encParam = { ssrc: primarySsrc, codecPayloadType: parseInt(codec.parameters.apt, 10), rtx: { ssrc: secondarySsrc } }; encodingParameters.push(encParam); if (hasRed) { encParam = JSON.parse(JSON.stringify(encParam)); encParam.fec = { ssrc: secondarySsrc, mechanism: hasUlpfec ? 'red+ulpfec' : 'red' }; encodingParameters.push(encParam); } } }); if (encodingParameters.length === 0 &amp;&amp; primarySsrc) { encodingParameters.push({ ssrc: primarySsrc }); } // we support both b=AS and b=TIAS but interpret AS as TIAS. var bandwidth = SDPUtils.matchPrefix(mediaSection, 'b='); if (bandwidth.length) { if (bandwidth[0].indexOf('b=TIAS:') === 0) { bandwidth = parseInt(bandwidth[0].substr(7), 10); } else if (bandwidth[0].indexOf('b=AS:') === 0) { bandwidth = parseInt(bandwidth[0].substr(5), 10); } encodingParameters.forEach(function(params) { params.maxBitrate = bandwidth; }); } return encodingParameters; }; // parses http://draft.ortc.org/#rtcrtcpparameters* SDPUtils.parseRtcpParameters = function(mediaSection) { var rtcpParameters = {}; var cname; // Gets the first SSRC. Note that with RTX there might be multiple // SSRCs. var remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:') .map(function(line) { return SDPUtils.parseSsrcMedia(line); }) .filter(function(obj) { return obj.attribute === 'cname'; })[0]; if (remoteSsrc) { rtcpParameters.cname = remoteSsrc.value; rtcpParameters.ssrc = remoteSsrc.ssrc; } // Edge uses the compound attribute instead of reducedSize // compound is !reducedSize var rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize'); rtcpParameters.reducedSize = rsize.length &gt; 0; rtcpParameters.compound = rsize.length === 0; // parses the rtcp-mux attrіbute. // Note that Edge does not support unmuxed RTCP. var mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux'); rtcpParameters.mux = mux.length &gt; 0; return rtcpParameters; }; // parses either a=msid: or a=ssrc:... msid lines an returns // the id of the MediaStream and MediaStreamTrack. SDPUtils.parseMsid = function(mediaSection) { var parts; var spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:'); if (spec.length === 1) { parts = spec[0].substr(7).split(' '); return {stream: parts[0], track: parts[1]}; } var planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:') .map(function(line) { return SDPUtils.parseSsrcMedia(line); }) .filter(function(parts) { return parts.attribute === 'msid'; }); if (planB.length &gt; 0) { parts = planB[0].value.split(' '); return {stream: parts[0], track: parts[1]}; } }; SDPUtils.writeSessionBoilerplate = function() { // FIXME: sess-id should be an NTP timestamp. return 'v=0\\r\\n' + 'o=thisisadapterortc 8169639915646943137 2 IN IP4 127.0.0.1\\r\\n' + 's=-\\r\\n' + 't=0 0\\r\\n'; }; SDPUtils.writeMediaSection = function(transceiver, caps, type, stream) { var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps); // Map ICE parameters (ufrag, pwd) to SDP. sdp += SDPUtils.writeIceParameters( transceiver.iceGatherer.getLocalParameters()); // Map DTLS parameters to SDP. sdp += SDPUtils.writeDtlsParameters( transceiver.dtlsTransport.getLocalParameters(), type === 'offer' ? 'actpass' : 'active'); sdp += 'a=mid:' + transceiver.mid + '\\r\\n'; if (transceiver.direction) { sdp += 'a=' + transceiver.direction + '\\r\\n'; } else if (transceiver.rtpSender &amp;&amp; transceiver.rtpReceiver) { sdp += 'a=sendrecv\\r\\n'; } else if (transceiver.rtpSender) { sdp += 'a=sendonly\\r\\n'; } else if (transceiver.rtpReceiver) { sdp += 'a=recvonly\\r\\n'; } else { sdp += 'a=inactive\\r\\n'; } if (transceiver.rtpSender) { // spec. var msid = 'msid:' + stream.id + ' ' + transceiver.rtpSender.track.id + '\\r\\n'; sdp += 'a=' + msid; // for Chrome. sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc + ' ' + msid; if (transceiver.sendEncodingParameters[0].rtx) { sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc + ' ' + msid; sdp += 'a=ssrc-group:FID ' + transceiver.sendEncodingParameters[0].ssrc + ' ' + transceiver.sendEncodingParameters[0].rtx.ssrc + '\\r\\n'; } } // FIXME: this should be written by writeRtpDescription. sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc + ' cname:' + SDPUtils.localCName + '\\r\\n'; if (transceiver.rtpSender &amp;&amp; transceiver.sendEncodingParameters[0].rtx) { sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc + ' cname:' + SDPUtils.localCName + '\\r\\n'; } return sdp; }; // Gets the direction from the mediaSection or the sessionpart. SDPUtils.getDirection = function(mediaSection, sessionpart) { // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv. var lines = SDPUtils.splitLines(mediaSection); for (var i = 0; i &lt; lines.length; i++) { switch (lines[i]) { case 'a=sendrecv': case 'a=sendonly': case 'a=recvonly': case 'a=inactive': return lines[i].substr(2); default: // FIXME: What should happen here? } } if (sessionpart) { return SDPUtils.getDirection(sessionpart); } return 'sendrecv'; }; SDPUtils.getKind = function(mediaSection) { var lines = SDPUtils.splitLines(mediaSection); var mline = lines[0].split(' '); return mline[0].substr(2); }; SDPUtils.isRejected = function(mediaSection) { return mediaSection.split(' ', 2)[1] === '0'; }; // Expose public methods. module.exports = SDPUtils; },{}],2:[function(require,module,exports){ /* * Copyright (c) 2016 The WebRTC project authors. All Rights Reserved. * * Use of this source code is governed by a BSD-style license * that can be found in the LICENSE file in the root of the source * tree. */ /* eslint-env node */ 'use strict'; // Shimming starts here. (function() { // Utils. var utils = require('./utils'); var logging = utils.log; var browserDetails = utils.browserDetails; // Export to the adapter global object visible in the browser. module.exports.browserDetails = browserDetails; module.exports.extractVersion = utils.extractVersion; module.exports.disableLog = utils.disableLog; // Uncomment the line below if you want logging to occur, including logging // for the switch statement below. Can also be turned on in the browser via // adapter.disableLog(false), but then logging from the switch statement below // will not appear. // require('./utils').disableLog(false); // Browser shims. var chromeShim = require('./chrome/chrome_shim') || null; var edgeShim = require('./edge/edge_shim') || null; var firefoxShim = require('./firefox/firefox_shim') || null; var safariShim = require('./safari/safari_shim') || null; // Shim browser if found. switch (browserDetails.browser) { case 'chrome': if (!chromeShim || !chromeShim.shimPeerConnection) { logging('Chrome shim is not included in this adapter release.'); return; } logging('adapter.js shimming chrome.'); // Export to the adapter global object visible in the browser. module.exports.browserShim = chromeShim; chromeShim.shimGetUserMedia(); chromeShim.shimMediaStream(); utils.shimCreateObjectURL(); chromeShim.shimSourceObject(); chromeShim.shimPeerConnection(); chromeShim.shimOnTrack(); chromeShim.shimGetSendersWithDtmf(); break; case 'firefox': if (!firefoxShim || !firefoxShim.shimPeerConnection) { logging('Firefox shim is not included in this adapter release.'); return; } logging('adapter.js shimming firefox.'); // Export to the adapter global object visible in the browser. module.exports.browserShim = firefoxShim; firefoxShim.shimGetUserMedia(); utils.shimCreateObjectURL(); firefoxShim.shimSourceObject(); firefoxShim.shimPeerConnection(); firefoxShim.shimOnTrack(); break; case 'edge': if (!edgeShim || !edgeShim.shimPeerConnection) { logging('MS edge shim is not included in this adapter release.'); return; } logging('adapter.js shimming edge.'); // Export to the adapter global object visible in the browser. module.exports.browserShim = edgeShim; edgeShim.shimGetUserMedia(); utils.shimCreateObjectURL(); edgeShim.shimPeerConnection(); edgeShim.shimReplaceTrack(); break; case 'safari': if (!safariShim) { logging('Safari shim is not included in this adapter release.'); return; } logging('adapter.js shimming safari.'); // Export to the adapter global object visible in the browser. module.exports.browserShim = safariShim; safariShim.shimCallbacksAPI(); safariShim.shimAddStream(); safariShim.shimOnAddStream(); safariShim.shimGetUserMedia(); break; default: logging('Unsupported browser!'); } })(); },{\"./chrome/chrome_shim\":3,\"./edge/edge_shim\":5,\"./firefox/firefox_shim\":8,\"./safari/safari_shim\":10,\"./utils\":11}],3:[function(require,module,exports){ /* * Copyright (c) 2016 The WebRTC project authors. All Rights Reserved. * * Use of this source code is governed by a BSD-style license * that can be found in the LICENSE file in the root of the source * tree. */ /* eslint-env node */ 'use strict'; var logging = require('../utils.js').log; var browserDetails = require('../utils.js').browserDetails; var chromeShim = { shimMediaStream: function() { window.MediaStream = window.MediaStream || window.webkitMediaStream; }, shimOnTrack: function() { if (typeof window === 'object' &amp;&amp; window.RTCPeerConnection &amp;&amp; !('ontrack' in window.RTCPeerConnection.prototype)) { Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', { get: function() { return this._ontrack; }, set: function(f) { var self = this; if (this._ontrack) { this.removeEventListener('track', this._ontrack); this.removeEventListener('addstream', this._ontrackpoly); } this.addEventListener('track', this._ontrack = f); this.addEventListener('addstream', this._ontrackpoly = function(e) { // onaddstream does not fire when a track is added to an existing // stream. But stream.onaddtrack is implemented so we use that. e.stream.addEventListener('addtrack', function(te) { var receiver; if (RTCPeerConnection.prototype.getReceivers) { receiver = self.getReceivers().find(function(r) { return r.track.id === te.track.id; }); } else { receiver = {track: te.track}; } var event = new Event('track'); event.track = te.track; event.receiver = receiver; event.streams = [e.stream]; self.dispatchEvent(event); }); e.stream.getTracks().forEach(function(track) { var receiver; if (RTCPeerConnection.prototype.getReceivers) { receiver = self.getReceivers().find(function(r) { return r.track.id === track.id; }); } else { receiver = {track: track}; } var event = new Event('track'); event.track = track; event.receiver = receiver; event.streams = [e.stream]; this.dispatchEvent(event); }.bind(this)); }.bind(this)); } }); } }, shimGetSendersWithDtmf: function() { if (typeof window === 'object' &amp;&amp; window.RTCPeerConnection &amp;&amp; !('getSenders' in RTCPeerConnection.prototype) &amp;&amp; 'createDTMFSender' in RTCPeerConnection.prototype) { RTCPeerConnection.prototype.getSenders = function() { return this._senders || []; }; var origAddStream = RTCPeerConnection.prototype.addStream; var origRemoveStream = RTCPeerConnection.prototype.removeStream; if (!RTCPeerConnection.prototype.addTrack) { RTCPeerConnection.prototype.addTrack = function(track, stream) { var pc = this; if (pc.signalingState === 'closed') { throw new DOMException( 'The RTCPeerConnection\\'s signalingState is \\'closed\\'.', 'InvalidStateError'); } var streams = [].slice.call(arguments, 1); if (streams.length !== 1 || !streams[0].getTracks().find(function(t) { return t === track; })) { // this is not fully correct but all we can manage without // [[associated MediaStreams]] internal slot. throw new DOMException( 'The adapter.js addTrack polyfill only supports a single ' + ' stream which is associated with the specified track.', 'NotSupportedError'); } pc._senders = pc._senders || []; var alreadyExists = pc._senders.find(function(t) { return t.track === track; }); if (alreadyExists) { throw new DOMException('Track already exists.', 'InvalidAccessError'); } pc._streams = pc._streams || {}; var oldStream = pc._streams[stream.id]; if (oldStream) { oldStream.addTrack(track); pc.removeStream(oldStream); pc.addStream(oldStream); } else { var newStream = new MediaStream([track]); pc._streams[stream.id] = newStream; pc.addStream(newStream); } var sender = { track: track, get dtmf() { if (this._dtmf === undefined) { if (track.kind === 'audio') { this._dtmf = pc.createDTMFSender(track); } else { this._dtmf = null; } } return this._dtmf; } }; pc._senders.push(sender); return sender; }; } RTCPeerConnection.prototype.addStream = function(stream) { var pc = this; pc._senders = pc._senders || []; origAddStream.apply(pc, [stream]); stream.getTracks().forEach(function(track) { pc._senders.push({ track: track, get dtmf() { if (this._dtmf === undefined) { if (track.kind === 'audio') { this._dtmf = pc.createDTMFSender(track); } else { this._dtmf = null; } } return this._dtmf; } }); }); }; RTCPeerConnection.prototype.removeStream = function(stream) { var pc = this; pc._senders = pc._senders || []; origRemoveStream.apply(pc, [stream]); stream.getTracks().forEach(function(track) { var sender = pc._senders.find(function(s) { return s.track === track; }); if (sender) { pc._senders.splice(pc._senders.indexOf(sender), 1); // remove sender } }); }; } }, shimSourceObject: function() { if (typeof window === 'object') { if (window.HTMLMediaElement &amp;&amp; !('srcObject' in window.HTMLMediaElement.prototype)) { // Shim the srcObject property, once, when HTMLMediaElement is found. Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', { get: function() { return this._srcObject; }, set: function(stream) { var self = this; // Use _srcObject as a private property for this shim this._srcObject = stream; if (this.src) { URL.revokeObjectURL(this.src); } if (!stream) { this.src = ''; return undefined; } this.src = URL.createObjectURL(stream); // We need to recreate the blob url when a track is added or // removed. Doing it manually since we want to avoid a recursion. stream.addEventListener('addtrack', function() { if (self.src) { URL.revokeObjectURL(self.src); } self.src = URL.createObjectURL(stream); }); stream.addEventListener('removetrack', function() { if (self.src) { URL.revokeObjectURL(self.src); } self.src = URL.createObjectURL(stream); }); } }); } } }, shimPeerConnection: function() { // The RTCPeerConnection object. if (!window.RTCPeerConnection) { window.RTCPeerConnection = function(pcConfig, pcConstraints) { // Translate iceTransportPolicy to iceTransports, // see https://code.google.com/p/webrtc/issues/detail?id=4869 // this was fixed in M56 along with unprefixing RTCPeerConnection. logging('PeerConnection'); if (pcConfig &amp;&amp; pcConfig.iceTransportPolicy) { pcConfig.iceTransports = pcConfig.iceTransportPolicy; } return new webkitRTCPeerConnection(pcConfig, pcConstraints); }; window.RTCPeerConnection.prototype = webkitRTCPeerConnection.prototype; // wrap static methods. Currently just generateCertificate. if (webkitRTCPeerConnection.generateCertificate) { Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', { get: function() { return webkitRTCPeerConnection.generateCertificate; } }); } } else { // migrate from non-spec RTCIceServer.url to RTCIceServer.urls var OrigPeerConnection = RTCPeerConnection; window.RTCPeerConnection = function(pcConfig, pcConstraints) { if (pcConfig &amp;&amp; pcConfig.iceServers) { var newIceServers = []; for (var i = 0; i &lt; pcConfig.iceServers.length; i++) { var server = pcConfig.iceServers[i]; if (!server.hasOwnProperty('urls') &amp;&amp; server.hasOwnProperty('url')) { console.warn('RTCIceServer.url is deprecated! Use urls instead.'); server = JSON.parse(JSON.stringify(server)); server.urls = server.url; newIceServers.push(server); } else { newIceServers.push(pcConfig.iceServers[i]); } } pcConfig.iceServers = newIceServers; } return new OrigPeerConnection(pcConfig, pcConstraints); }; window.RTCPeerConnection.prototype = OrigPeerConnection.prototype; // wrap static methods. Currently just generateCertificate. Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', { get: function() { return OrigPeerConnection.generateCertificate; } }); } var origGetStats = RTCPeerConnection.prototype.getStats; RTCPeerConnection.prototype.getStats = function(selector, successCallback, errorCallback) { var self = this; var args = arguments; // If selector is a function then we are in the old style stats so just // pass back the original getStats format to avoid breaking old users. if (arguments.length &gt; 0 &amp;&amp; typeof selector === 'function') { return origGetStats.apply(this, arguments); } // When spec-style getStats is supported, return those when called with // either no arguments or the selector argument is null. if (origGetStats.length === 0 &amp;&amp; (arguments.length === 0 || typeof arguments[0] !== 'function')) { return origGetStats.apply(this, []); } var fixChromeStats_ = function(response) { var standardReport = {}; var reports = response.result(); reports.forEach(function(report) { var standardStats = { id: report.id, timestamp: report.timestamp, type: { localcandidate: 'local-candidate', remotecandidate: 'remote-candidate' }[report.type] || report.type }; report.names().forEach(function(name) { standardStats[name] = report.stat(name); }); standardReport[standardStats.id] = standardStats; }); return standardReport; }; // shim getStats with maplike support var makeMapStats = function(stats) { return new Map(Object.keys(stats).map(function(key) { return [key, stats[key]]; })); }; if (arguments.length &gt;= 2) { var successCallbackWrapper_ = function(response) { args[1](makeMapStats(fixChromeStats_(response))); }; return origGetStats.apply(this, [successCallbackWrapper_, arguments[0]]); } // promise-support return new Promise(function(resolve, reject) { origGetStats.apply(self, [ function(response) { resolve(makeMapStats(fixChromeStats_(response))); }, reject]); }).then(successCallback, errorCallback); }; // add promise support -- natively available in Chrome 51 if (browserDetails.version &lt; 51) { ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'] .forEach(function(method) { var nativeMethod = RTCPeerConnection.prototype[method]; RTCPeerConnection.prototype[method] = function() { var args = arguments; var self = this; var promise = new Promise(function(resolve, reject) { nativeMethod.apply(self, [args[0], resolve, reject]); }); if (args.length &lt; 2) { return promise; } return promise.then(function() { args[1].apply(null, []); }, function(err) { if (args.length &gt;= 3) { args[2].apply(null, [err]); } }); }; }); } // promise support for createOffer and createAnswer. Available (without // bugs) since M52: crbug/619289 if (browserDetails.version &lt; 52) { ['createOffer', 'createAnswer'].forEach(function(method) { var nativeMethod = RTCPeerConnection.prototype[method]; RTCPeerConnection.prototype[method] = function() { var self = this; if (arguments.length &lt; 1 || (arguments.length === 1 &amp;&amp; typeof arguments[0] === 'object')) { var opts = arguments.length === 1 ? arguments[0] : undefined; return new Promise(function(resolve, reject) { nativeMethod.apply(self, [resolve, reject, opts]); }); } return nativeMethod.apply(this, arguments); }; }); } // shim implicit creation of RTCSessionDescription/RTCIceCandidate ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'] .forEach(function(method) { var nativeMethod = RTCPeerConnection.prototype[method]; RTCPeerConnection.prototype[method] = function() { arguments[0] = new ((method === 'addIceCandidate') ? RTCIceCandidate : RTCSessionDescription)(arguments[0]); return nativeMethod.apply(this, arguments); }; }); // support for addIceCandidate(null or undefined) var nativeAddIceCandidate = RTCPeerConnection.prototype.addIceCandidate; RTCPeerConnection.prototype.addIceCandidate = function() { if (!arguments[0]) { if (arguments[1]) { arguments[1].apply(null); } return Promise.resolve(); } return nativeAddIceCandidate.apply(this, arguments); }; } }; // Expose public methods. module.exports = { shimMediaStream: chromeShim.shimMediaStream, shimOnTrack: chromeShim.shimOnTrack, shimGetSendersWithDtmf: chromeShim.shimGetSendersWithDtmf, shimSourceObject: chromeShim.shimSourceObject, shimPeerConnection: chromeShim.shimPeerConnection, shimGetUserMedia: require('./getusermedia') }; },{\"../utils.js\":11,\"./getusermedia\":4}],4:[function(require,module,exports){ /* * Copyright (c) 2016 The WebRTC project authors. All Rights Reserved. * * Use of this source code is governed by a BSD-style license * that can be found in the LICENSE file in the root of the source * tree. */ /* eslint-env node */ 'use strict'; var logging = require('../utils.js').log; var browserDetails = require('../utils.js').browserDetails; // Expose public methods. module.exports = function() { var constraintsToChrome_ = function(c) { if (typeof c !== 'object' || c.mandatory || c.optional) { return c; } var cc = {}; Object.keys(c).forEach(function(key) { if (key === 'require' || key === 'advanced' || key === 'mediaSource') { return; } var r = (typeof c[key] === 'object') ? c[key] : {ideal: c[key]}; if (r.exact !== undefined &amp;&amp; typeof r.exact === 'number') { r.min = r.max = r.exact; } var oldname_ = function(prefix, name) { if (prefix) { return prefix + name.charAt(0).toUpperCase() + name.slice(1); } return (name === 'deviceId') ? 'sourceId' : name; }; if (r.ideal !== undefined) { cc.optional = cc.optional || []; var oc = {}; if (typeof r.ideal === 'number') { oc[oldname_('min', key)] = r.ideal; cc.optional.push(oc); oc = {}; oc[oldname_('max', key)] = r.ideal; cc.optional.push(oc); } else { oc[oldname_('', key)] = r.ideal; cc.optional.push(oc); } } if (r.exact !== undefined &amp;&amp; typeof r.exact !== 'number') { cc.mandatory = cc.mandatory || {}; cc.mandatory[oldname_('', key)] = r.exact; } else { ['min', 'max'].forEach(function(mix) { if (r[mix] !== undefined) { cc.mandatory = cc.mandatory || {}; cc.mandatory[oldname_(mix, key)] = r[mix]; } }); } }); if (c.advanced) { cc.optional = (cc.optional || []).concat(c.advanced); } return cc; }; var shimConstraints_ = function(constraints, func) { constraints = JSON.parse(JSON.stringify(constraints)); if (constraints &amp;&amp; constraints.audio) { constraints.audio = constraintsToChrome_(constraints.audio); } if (constraints &amp;&amp; typeof constraints.video === 'object') { // Shim facingMode for mobile &amp; surface pro. var face = constraints.video.facingMode; face = face &amp;&amp; ((typeof face === 'object') ? face : {ideal: face}); var getSupportedFacingModeLies = browserDetails.version &lt; 61; if ((face &amp;&amp; (face.exact === 'user' || face.exact === 'environment' || face.ideal === 'user' || face.ideal === 'environment')) &amp;&amp; !(navigator.mediaDevices.getSupportedConstraints &amp;&amp; navigator.mediaDevices.getSupportedConstraints().facingMode &amp;&amp; !getSupportedFacingModeLies)) { delete constraints.video.facingMode; var matches; if (face.exact === 'environment' || face.ideal === 'environment') { matches = ['back', 'rear']; } else if (face.exact === 'user' || face.ideal === 'user') { matches = ['front']; } if (matches) { // Look for matches in label, or use last cam for back (typical). return navigator.mediaDevices.enumerateDevices() .then(function(devices) { devices = devices.filter(function(d) { return d.kind === 'videoinput'; }); var dev = devices.find(function(d) { return matches.some(function(match) { return d.label.toLowerCase().indexOf(match) !== -1; }); }); if (!dev &amp;&amp; devices.length &amp;&amp; matches.indexOf('back') !== -1) { dev = devices[devices.length - 1]; // more likely the back cam } if (dev) { constraints.video.deviceId = face.exact ? {exact: dev.deviceId} : {ideal: dev.deviceId}; } constraints.video = constraintsToChrome_(constraints.video); logging('chrome: ' + JSON.stringify(constraints)); return func(constraints); }); } } constraints.video = constraintsToChrome_(constraints.video); } logging('chrome: ' + JSON.stringify(constraints)); return func(constraints); }; var shimError_ = function(e) { return { name: { ConstraintNotSatisfiedError: 'OverconstrainedError', PermissionDeniedError: 'NotAllowedError', TrackStartError: 'NotReadableError' }[e.name] || e.name, message: e.message, constraint: e.constraintName, toString: function() { return this.name + (this.message &amp;&amp; ': ') + this.message; } }; }; var getUserMedia_ = function(constraints, onSuccess, onError) { shimConstraints_(constraints, function(c) { navigator.webkitGetUserMedia(c, onSuccess, function(e) { onError(shimError_(e)); }); }); }; navigator.getUserMedia = getUserMedia_; // Returns the result of getUserMedia as a Promise. var getUserMediaPromise_ = function(constraints) { return new Promise(function(resolve, reject) { navigator.getUserMedia(constraints, resolve, reject); }); }; if (!navigator.mediaDevices) { navigator.mediaDevices = { getUserMedia: getUserMediaPromise_, enumerateDevices: function() { return new Promise(function(resolve) { var kinds = {audio: 'audioinput', video: 'videoinput'}; return MediaStreamTrack.getSources(function(devices) { resolve(devices.map(function(device) { return {label: device.label, kind: kinds[device.kind], deviceId: device.id, groupId: ''}; })); }); }); }, getSupportedConstraints: function() { return { deviceId: true, echoCancellation: true, facingMode: true, frameRate: true, height: true, width: true }; } }; } // A shim for getUserMedia method on the mediaDevices object. // TODO(KaptenJansson) remove once implemented in Chrome stable. if (!navigator.mediaDevices.getUserMedia) { navigator.mediaDevices.getUserMedia = function(constraints) { return getUserMediaPromise_(constraints); }; } else { // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia // function which returns a Promise, it does not accept spec-style // constraints. var origGetUserMedia = navigator.mediaDevices.getUserMedia. bind(navigator.mediaDevices); navigator.mediaDevices.getUserMedia = function(cs) { return shimConstraints_(cs, function(c) { return origGetUserMedia(c).then(function(stream) { if (c.audio &amp;&amp; !stream.getAudioTracks().length || c.video &amp;&amp; !stream.getVideoTracks().length) { stream.getTracks().forEach(function(track) { track.stop(); }); throw new DOMException('', 'NotFoundError'); } return stream; }, function(e) { return Promise.reject(shimError_(e)); }); }); }; } // Dummy devicechange event methods. // TODO(KaptenJansson) remove once implemented in Chrome stable. if (typeof navigator.mediaDevices.addEventListener === 'undefined') { navigator.mediaDevices.addEventListener = function() { logging('Dummy mediaDevices.addEventListener called.'); }; } if (typeof navigator.mediaDevices.removeEventListener === 'undefined') { navigator.mediaDevices.removeEventListener = function() { logging('Dummy mediaDevices.removeEventListener called.'); }; } }; },{\"../utils.js\":11}],5:[function(require,module,exports){ /* * Copyright (c) 2016 The WebRTC project authors. All Rights Reserved. * * Use of this source code is governed by a BSD-style license * that can be found in the LICENSE file in the root of the source * tree. */ /* eslint-env node */ 'use strict'; var browserDetails = require('../utils').browserDetails; var shimRTCPeerConnection = require('./rtcpeerconnection_shim'); module.exports = { shimGetUserMedia: require('./getusermedia'), shimPeerConnection: function() { if (window.RTCIceGatherer) { // ORTC defines an RTCIceCandidate object but no constructor. // Not implemented in Edge. if (!window.RTCIceCandidate) { window.RTCIceCandidate = function(args) { return args; }; } // ORTC does not have a session description object but // other browsers (i.e. Chrome) that will support both PC and ORTC // in the future might have this defined already. if (!window.RTCSessionDescription) { window.RTCSessionDescription = function(args) { return args; }; } // this adds an additional event listener to MediaStrackTrack that signals // when a tracks enabled property was changed. Workaround for a bug in // addStream, see below. No longer required in 15025+ if (browserDetails.version &lt; 15025) { var origMSTEnabled = Object.getOwnPropertyDescriptor( MediaStreamTrack.prototype, 'enabled'); Object.defineProperty(MediaStreamTrack.prototype, 'enabled', { set: function(value) { origMSTEnabled.set.call(this, value); var ev = new Event('enabled'); ev.enabled = value; this.dispatchEvent(ev); } }); } } window.RTCPeerConnection = shimRTCPeerConnection(browserDetails.version); }, shimReplaceTrack: function() { // ORTC has replaceTrack -- https://github.com/w3c/ortc/issues/614 if (window.RTCRtpSender &amp;&amp; !('replaceTrack' in RTCRtpSender.prototype)) { RTCRtpSender.prototype.replaceTrack = RTCRtpSender.prototype.setTrack; } } }; },{\"../utils\":11,\"./getusermedia\":6,\"./rtcpeerconnection_shim\":7}],6:[function(require,module,exports){ /* * Copyright (c) 2016 The WebRTC project authors. All Rights Reserved. * * Use of this source code is governed by a BSD-style license * that can be found in the LICENSE file in the root of the source * tree. */ /* eslint-env node */ 'use strict'; // Expose public methods. module.exports = function() { var shimError_ = function(e) { return { name: {PermissionDeniedError: 'NotAllowedError'}[e.name] || e.name, message: e.message, constraint: e.constraint, toString: function() { return this.name; } }; }; // getUserMedia error shim. var origGetUserMedia = navigator.mediaDevices.getUserMedia. bind(navigator.mediaDevices); navigator.mediaDevices.getUserMedia = function(c) { return origGetUserMedia(c).catch(function(e) { return Promise.reject(shimError_(e)); }); }; }; },{}],7:[function(require,module,exports){ /* * Copyright (c) 2017 The WebRTC project authors. All Rights Reserved. * * Use of this source code is governed by a BSD-style license * that can be found in the LICENSE file in the root of the source * tree. */ /* eslint-env node */ 'use strict'; var SDPUtils = require('sdp'); // sort tracks such that they follow an a-v-a-v... // pattern. function sortTracks(tracks) { var audioTracks = tracks.filter(function(track) { return track.kind === 'audio'; }); var videoTracks = tracks.filter(function(track) { return track.kind === 'video'; }); tracks = []; while (audioTracks.length || videoTracks.length) { if (audioTracks.length) { tracks.push(audioTracks.shift()); } if (videoTracks.length) { tracks.push(videoTracks.shift()); } } return tracks; } // Edge does not like // 1) stun: // 2) turn: that does not have all of turn:host:port?transport=udp // 3) turn: with ipv6 addresses // 4) turn: occurring muliple times function filterIceServers(iceServers, edgeVersion) { var hasTurn = false; iceServers = JSON.parse(JSON.stringify(iceServers)); return iceServers.filter(function(server) { if (server &amp;&amp; (server.urls || server.url)) { var urls = server.urls || server.url; if (server.url &amp;&amp; !server.urls) { console.warn('RTCIceServer.url is deprecated! Use urls instead.'); } var isString = typeof urls === 'string'; if (isString) { urls = [urls]; } urls = urls.filter(function(url) { var validTurn = url.indexOf('turn:') === 0 &amp;&amp; url.indexOf('transport=udp') !== -1 &amp;&amp; url.indexOf('turn:[') === -1 &amp;&amp; !hasTurn; if (validTurn) { hasTurn = true; return true; } return url.indexOf('stun:') === 0 &amp;&amp; edgeVersion &gt;= 14393; }); delete server.url; server.urls = isString ? urls[0] : urls; return !!urls.length; } return false; }); } // Determines the intersection of local and remote capabilities. function getCommonCapabilities(localCapabilities, remoteCapabilities) { var commonCapabilities = { codecs: [], headerExtensions: [], fecMechanisms: [] }; var findCodecByPayloadType = function(pt, codecs) { pt = parseInt(pt, 10); for (var i = 0; i &lt; codecs.length; i++) { if (codecs[i].payloadType === pt || codecs[i].preferredPayloadType === pt) { return codecs[i]; } } }; var rtxCapabilityMatches = function(lRtx, rRtx, lCodecs, rCodecs) { var lCodec = findCodecByPayloadType(lRtx.parameters.apt, lCodecs); var rCodec = findCodecByPayloadType(rRtx.parameters.apt, rCodecs); return lCodec &amp;&amp; rCodec &amp;&amp; lCodec.name.toLowerCase() === rCodec.name.toLowerCase(); }; localCapabilities.codecs.forEach(function(lCodec) { for (var i = 0; i &lt; remoteCapabilities.codecs.length; i++) { var rCodec = remoteCapabilities.codecs[i]; if (lCodec.name.toLowerCase() === rCodec.name.toLowerCase() &amp;&amp; lCodec.clockRate === rCodec.clockRate) { if (lCodec.name.toLowerCase() === 'rtx' &amp;&amp; lCodec.parameters &amp;&amp; rCodec.parameters.apt) { // for RTX we need to find the local rtx that has a apt // which points to the same local codec as the remote one. if (!rtxCapabilityMatches(lCodec, rCodec, localCapabilities.codecs, remoteCapabilities.codecs)) { continue; } } rCodec = JSON.parse(JSON.stringify(rCodec)); // deepcopy // number of channels is the highest common number of channels rCodec.numChannels = Math.min(lCodec.numChannels, rCodec.numChannels); // push rCodec so we reply with offerer payload type commonCapabilities.codecs.push(rCodec); // determine common feedback mechanisms rCodec.rtcpFeedback = rCodec.rtcpFeedback.filter(function(fb) { for (var j = 0; j &lt; lCodec.rtcpFeedback.length; j++) { if (lCodec.rtcpFeedback[j].type === fb.type &amp;&amp; lCodec.rtcpFeedback[j].parameter === fb.parameter) { return true; } } return false; }); // FIXME: also need to determine .parameters // see https://github.com/openpeer/ortc/issues/569 break; } } }); localCapabilities.headerExtensions.forEach(function(lHeaderExtension) { for (var i = 0; i &lt; remoteCapabilities.headerExtensions.length; i++) { var rHeaderExtension = remoteCapabilities.headerExtensions[i]; if (lHeaderExtension.uri === rHeaderExtension.uri) { commonCapabilities.headerExtensions.push(rHeaderExtension); break; } } }); // FIXME: fecMechanisms return commonCapabilities; } // is action=setLocalDescription with type allowed in signalingState function isActionAllowedInSignalingState(action, type, signalingState) { return { offer: { setLocalDescription: ['stable', 'have-local-offer'], setRemoteDescription: ['stable', 'have-remote-offer'] }, answer: { setLocalDescription: ['have-remote-offer', 'have-local-pranswer'], setRemoteDescription: ['have-local-offer', 'have-remote-pranswer'] } }[type][action].indexOf(signalingState) !== -1; } module.exports = function(edgeVersion) { var RTCPeerConnection = function(config) { var self = this; var _eventTarget = document.createDocumentFragment(); ['addEventListener', 'removeEventListener', 'dispatchEvent'] .forEach(function(method) { self[method] = _eventTarget[method].bind(_eventTarget); }); this.needNegotiation = false; this.onicecandidate = null; this.onaddstream = null; this.ontrack = null; this.onremovestream = null; this.onsignalingstatechange = null; this.oniceconnectionstatechange = null; this.onicegatheringstatechange = null; this.onnegotiationneeded = null; this.ondatachannel = null; this.canTrickleIceCandidates = null; this.localStreams = []; this.remoteStreams = []; this.getLocalStreams = function() { return self.localStreams; }; this.getRemoteStreams = function() { return self.remoteStreams; }; this.localDescription = new RTCSessionDescription({ type: '', sdp: '' }); this.remoteDescription = new RTCSessionDescription({ type: '', sdp: '' }); this.signalingState = 'stable'; this.iceConnectionState = 'new'; this.iceGatheringState = 'new'; this.iceOptions = { gatherPolicy: 'all', iceServers: [] }; if (config &amp;&amp; config.iceTransportPolicy) { switch (config.iceTransportPolicy) { case 'all': case 'relay': this.iceOptions.gatherPolicy = config.iceTransportPolicy; break; default: // don't set iceTransportPolicy. break; } } this.usingBundle = config &amp;&amp; config.bundlePolicy === 'max-bundle'; if (config &amp;&amp; config.iceServers) { this.iceOptions.iceServers = filterIceServers(config.iceServers, edgeVersion); } this._config = config || {}; // per-track iceGathers, iceTransports, dtlsTransports, rtpSenders, ... // everything that is needed to describe a SDP m-line. this.transceivers = []; // since the iceGatherer is currently created in createOffer but we // must not emit candidates until after setLocalDescription we buffer // them in this array. this._localIceCandidatesBuffer = []; }; RTCPeerConnection.prototype._emitGatheringStateChange = function() { var event = new Event('icegatheringstatechange'); this.dispatchEvent(event); if (this.onicegatheringstatechange !== null) { this.onicegatheringstatechange(event); } }; RTCPeerConnection.prototype._emitBufferedCandidates = function() { var self = this; var sections = SDPUtils.splitSections(self.localDescription.sdp); // FIXME: need to apply ice candidates in a way which is async but // in-order this._localIceCandidatesBuffer.forEach(function(event) { var end = !event.candidate || Object.keys(event.candidate).length === 0; if (end) { for (var j = 1; j &lt; sections.length; j++) { if (sections[j].indexOf('\\r\\na=end-of-candidates\\r\\n') === -1) { sections[j] += 'a=end-of-candidates\\r\\n'; } } } else { sections[event.candidate.sdpMLineIndex + 1] += 'a=' + event.candidate.candidate + '\\r\\n'; } self.localDescription.sdp = sections.join(''); self.dispatchEvent(event); if (self.onicecandidate !== null) { self.onicecandidate(event); } if (!event.candidate &amp;&amp; self.iceGatheringState !== 'complete') { var complete = self.transceivers.every(function(transceiver) { return transceiver.iceGatherer &amp;&amp; transceiver.iceGatherer.state === 'completed'; }); if (complete &amp;&amp; self.iceGatheringStateChange !== 'complete') { self.iceGatheringState = 'complete'; self._emitGatheringStateChange(); } } }); this._localIceCandidatesBuffer = []; }; RTCPeerConnection.prototype.getConfiguration = function() { return this._config; }; // internal helper to create a transceiver object. // (whih is not yet the same as the WebRTC 1.0 transceiver) RTCPeerConnection.prototype._createTransceiver = function(kind) { var hasBundleTransport = this.transceivers.length &gt; 0; var transceiver = { track: null, iceGatherer: null, iceTransport: null, dtlsTransport: null, localCapabilities: null, remoteCapabilities: null, rtpSender: null, rtpReceiver: null, kind: kind, mid: null, sendEncodingParameters: null, recvEncodingParameters: null, stream: null, wantReceive: true }; if (this.usingBundle &amp;&amp; hasBundleTransport) { transceiver.iceTransport = this.transceivers[0].iceTransport; transceiver.dtlsTransport = this.transceivers[0].dtlsTransport; } else { var transports = this._createIceAndDtlsTransports(); transceiver.iceTransport = transports.iceTransport; transceiver.dtlsTransport = transports.dtlsTransport; } this.transceivers.push(transceiver); return transceiver; }; RTCPeerConnection.prototype.addTrack = function(track, stream) { var transceiver; for (var i = 0; i &lt; this.transceivers.length; i++) { if (!this.transceivers[i].track &amp;&amp; this.transceivers[i].kind === track.kind) { transceiver = this.transceivers[i]; } } if (!transceiver) { transceiver = this._createTransceiver(track.kind); } transceiver.track = track; transceiver.stream = stream; transceiver.rtpSender = new RTCRtpSender(track, transceiver.dtlsTransport); this._maybeFireNegotiationNeeded(); return transceiver.rtpSender; }; RTCPeerConnection.prototype.addStream = function(stream) { var self = this; if (edgeVersion &gt;= 15025) { this.localStreams.push(stream); stream.getTracks().forEach(function(track) { self.addTrack(track, stream); }); } else { // Clone is necessary for local demos mostly, attaching directly // to two different senders does not work (build 10547). // Fixed in 15025 (or earlier) var clonedStream = stream.clone(); stream.getTracks().forEach(function(track, idx) { var clonedTrack = clonedStream.getTracks()[idx]; track.addEventListener('enabled', function(event) { clonedTrack.enabled = event.enabled; }); }); clonedStream.getTracks().forEach(function(track) { self.addTrack(track, clonedStream); }); this.localStreams.push(clonedStream); } this._maybeFireNegotiationNeeded(); }; RTCPeerConnection.prototype.removeStream = function(stream) { var idx = this.localStreams.indexOf(stream); if (idx &gt; -1) { this.localStreams.splice(idx, 1); this._maybeFireNegotiationNeeded(); } }; RTCPeerConnection.prototype.getSenders = function() { return this.transceivers.filter(function(transceiver) { return !!transceiver.rtpSender; }) .map(function(transceiver) { return transceiver.rtpSender; }); }; RTCPeerConnection.prototype.getReceivers = function() { return this.transceivers.filter(function(transceiver) { return !!transceiver.rtpReceiver; }) .map(function(transceiver) { return transceiver.rtpReceiver; }); }; // Create ICE gatherer and hook it up. RTCPeerConnection.prototype._createIceGatherer = function(mid, sdpMLineIndex) { var self = this; var iceGatherer = new RTCIceGatherer(self.iceOptions); iceGatherer.onlocalcandidate = function(evt) { var event = new Event('icecandidate'); event.candidate = {sdpMid: mid, sdpMLineIndex: sdpMLineIndex}; var cand = evt.candidate; var end = !cand || Object.keys(cand).length === 0; // Edge emits an empty object for RTCIceCandidateComplete‥ if (end) { // polyfill since RTCIceGatherer.state is not implemented in // Edge 10547 yet. if (iceGatherer.state === undefined) { iceGatherer.state = 'completed'; } } else { // RTCIceCandidate doesn't have a component, needs to be added cand.component = 1; event.candidate.candidate = SDPUtils.writeCandidate(cand); } // update local description. var sections = SDPUtils.splitSections(self.localDescription.sdp); if (!end) { sections[event.candidate.sdpMLineIndex + 1] += 'a=' + event.candidate.candidate + '\\r\\n'; } else { sections[event.candidate.sdpMLineIndex + 1] += 'a=end-of-candidates\\r\\n'; } self.localDescription.sdp = sections.join(''); var transceivers = self._pendingOffer ? self._pendingOffer : self.transceivers; var complete = transceivers.every(function(transceiver) { return transceiver.iceGatherer &amp;&amp; transceiver.iceGatherer.state === 'completed'; }); // Emit candidate if localDescription is set. // Also emits null candidate when all gatherers are complete. switch (self.iceGatheringState) { case 'new': if (!end) { self._localIceCandidatesBuffer.push(event); } if (end &amp;&amp; complete) { self._localIceCandidatesBuffer.push( new Event('icecandidate')); } break; case 'gathering': self._emitBufferedCandidates(); if (!end) { self.dispatchEvent(event); if (self.onicecandidate !== null) { self.onicecandidate(event); } } if (complete) { self.dispatchEvent(new Event('icecandidate')); if (self.onicecandidate !== null) { self.onicecandidate(new Event('icecandidate')); } self.iceGatheringState = 'complete'; self._emitGatheringStateChange(); } break; case 'complete': // should not happen... currently! break; default: // no-op. break; } }; return iceGatherer; }; // Create ICE transport and DTLS transport. RTCPeerConnection.prototype._createIceAndDtlsTransports = function() { var self = this; var iceTransport = new RTCIceTransport(null); iceTransport.onicestatechange = function() { self._updateConnectionState(); }; var dtlsTransport = new RTCDtlsTransport(iceTransport); dtlsTransport.ondtlsstatechange = function() { self._updateConnectionState(); }; dtlsTransport.onerror = function() { // onerror does not set state to failed by itself. Object.defineProperty(dtlsTransport, 'state', {value: 'failed', writable: true}); self._updateConnectionState(); }; return { iceTransport: iceTransport, dtlsTransport: dtlsTransport }; }; // Destroy ICE gatherer, ICE transport and DTLS transport. // Without triggering the callbacks. RTCPeerConnection.prototype._disposeIceAndDtlsTransports = function( sdpMLineIndex) { var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer; if (iceGatherer) { delete iceGatherer.onlocalcandidate; delete this.transceivers[sdpMLineIndex].iceGatherer; } var iceTransport = this.transceivers[sdpMLineIndex].iceTransport; if (iceTransport) { delete iceTransport.onicestatechange; delete this.transceivers[sdpMLineIndex].iceTransport; } var dtlsTransport = this.transceivers[sdpMLineIndex].dtlsTransport; if (dtlsTransport) { delete dtlsTransport.ondtlssttatechange; delete dtlsTransport.onerror; delete this.transceivers[sdpMLineIndex].dtlsTransport; } }; // Start the RTP Sender and Receiver for a transceiver. RTCPeerConnection.prototype._transceive = function(transceiver, send, recv) { var params = getCommonCapabilities(transceiver.localCapabilities, transceiver.remoteCapabilities); if (send &amp;&amp; transceiver.rtpSender) { params.encodings = transceiver.sendEncodingParameters; params.rtcp = { cname: SDPUtils.localCName, compound: transceiver.rtcpParameters.compound }; if (transceiver.recvEncodingParameters.length) { params.rtcp.ssrc = transceiver.recvEncodingParameters[0].ssrc; } transceiver.rtpSender.send(params); } if (recv &amp;&amp; transceiver.rtpReceiver) { // remove RTX field in Edge 14942 if (transceiver.kind === 'video' &amp;&amp; transceiver.recvEncodingParameters &amp;&amp; edgeVersion &lt; 15019) { transceiver.recvEncodingParameters.forEach(function(p) { delete p.rtx; }); } params.encodings = transceiver.recvEncodingParameters; params.rtcp = { cname: transceiver.rtcpParameters.cname, compound: transceiver.rtcpParameters.compound }; if (transceiver.sendEncodingParameters.length) { params.rtcp.ssrc = transceiver.sendEncodingParameters[0].ssrc; } transceiver.rtpReceiver.receive(params); } }; RTCPeerConnection.prototype.setLocalDescription = function(description) { var self = this; if (!isActionAllowedInSignalingState('setLocalDescription', description.type, this.signalingState)) { var e = new Error('Can not set local ' + description.type + ' in state ' + this.signalingState); e.name = 'InvalidStateError'; if (arguments.length &gt; 2 &amp;&amp; typeof arguments[2] === 'function') { window.setTimeout(arguments[2], 0, e); } return Promise.reject(e); } var sections; var sessionpart; if (description.type === 'offer') { // FIXME: What was the purpose of this empty if statement? // if (!this._pendingOffer) { // } else { if (this._pendingOffer) { // VERY limited support for SDP munging. Limited to: // * changing the order of codecs sections = SDPUtils.splitSections(description.sdp); sessionpart = sections.shift(); sections.forEach(function(mediaSection, sdpMLineIndex) { var caps = SDPUtils.parseRtpParameters(mediaSection); self._pendingOffer[sdpMLineIndex].localCapabilities = caps; }); this.transceivers = this._pendingOffer; delete this._pendingOffer; } } else if (description.type === 'answer') { sections = SDPUtils.splitSections(self.remoteDescription.sdp); sessionpart = sections.shift(); var isIceLite = SDPUtils.matchPrefix(sessionpart, 'a=ice-lite').length &gt; 0; sections.forEach(function(mediaSection, sdpMLineIndex) { var transceiver = self.transceivers[sdpMLineIndex]; var iceGatherer = transceiver.iceGatherer; var iceTransport = transceiver.iceTransport; var dtlsTransport = transceiver.dtlsTransport; var localCapabilities = transceiver.localCapabilities; var remoteCapabilities = transceiver.remoteCapabilities; var rejected = SDPUtils.isRejected(mediaSection); if (!rejected &amp;&amp; !transceiver.isDatachannel) { var remoteIceParameters = SDPUtils.getIceParameters( mediaSection, sessionpart); var remoteDtlsParameters = SDPUtils.getDtlsParameters( mediaSection, sessionpart); if (isIceLite) { remoteDtlsParameters.role = 'server'; } if (!self.usingBundle || sdpMLineIndex === 0) { iceTransport.start(iceGatherer, remoteIceParameters, isIceLite ? 'controlling' : 'controlled'); dtlsTransport.start(remoteDtlsParameters); } // Calculate intersection of capabilities. var params = getCommonCapabilities(localCapabilities, remoteCapabilities); // Start the RTCRtpSender. The RTCRtpReceiver for this // transceiver has already been started in setRemoteDescription. self._transceive(transceiver, params.codecs.length &gt; 0, false); } }); } this.localDescription = { type: description.type, sdp: description.sdp }; switch (description.type) { case 'offer': this._updateSignalingState('have-local-offer'); break; case 'answer': this._updateSignalingState('stable'); break; default: throw new TypeError('unsupported type \"' + description.type + '\"'); } // If a success callback was provided, emit ICE candidates after it // has been executed. Otherwise, emit callback after the Promise is // resolved. var hasCallback = arguments.length &gt; 1 &amp;&amp; typeof arguments[1] === 'function'; if (hasCallback) { var cb = arguments[1]; window.setTimeout(function() { cb(); if (self.iceGatheringState === 'new') { self.iceGatheringState = 'gathering'; self._emitGatheringStateChange(); } self._emitBufferedCandidates(); }, 0); } var p = Promise.resolve(); p.then(function() { if (!hasCallback) { if (self.iceGatheringState === 'new') { self.iceGatheringState = 'gathering'; self._emitGatheringStateChange(); } // Usually candidates will be emitted earlier. window.setTimeout(self._emitBufferedCandidates.bind(self), 500); } }); return p; }; RTCPeerConnection.prototype.setRemoteDescription = function(description) { var self = this; if (!isActionAllowedInSignalingState('setRemoteDescription', description.type, this.signalingState)) { var e = new Error('Can not set remote ' + description.type + ' in state ' + this.signalingState); e.name = 'InvalidStateError'; if (arguments.length &gt; 2 &amp;&amp; typeof arguments[2] === 'function') { window.setTimeout(arguments[2], 0, e); } return Promise.reject(e); } var streams = {}; var receiverList = []; var sections = SDPUtils.splitSections(description.sdp); var sessionpart = sections.shift(); var isIceLite = SDPUtils.matchPrefix(sessionpart, 'a=ice-lite').length &gt; 0; var usingBundle = SDPUtils.matchPrefix(sessionpart, 'a=group:BUNDLE ').length &gt; 0; this.usingBundle = usingBundle; var iceOptions = SDPUtils.matchPrefix(sessionpart, 'a=ice-options:')[0]; if (iceOptions) { this.canTrickleIceCandidates = iceOptions.substr(14).split(' ') .indexOf('trickle') &gt;= 0; } else { this.canTrickleIceCandidates = false; } sections.forEach(function(mediaSection, sdpMLineIndex) { var lines = SDPUtils.splitLines(mediaSection); var kind = SDPUtils.getKind(mediaSection); var rejected = SDPUtils.isRejected(mediaSection); var protocol = lines[0].substr(2).split(' ')[2]; var direction = SDPUtils.getDirection(mediaSection, sessionpart); var remoteMsid = SDPUtils.parseMsid(mediaSection); var mid = SDPUtils.getMid(mediaSection) || SDPUtils.generateIdentifier(); // Reject datachannels which are not implemented yet. if (kind === 'application' &amp;&amp; protocol === 'DTLS/SCTP') { self.transceivers[sdpMLineIndex] = { mid: mid, isDatachannel: true }; return; } var transceiver; var iceGatherer; var iceTransport; var dtlsTransport; var rtpReceiver; var sendEncodingParameters; var recvEncodingParameters; var localCapabilities; var track; // FIXME: ensure the mediaSection has rtcp-mux set. var remoteCapabilities = SDPUtils.parseRtpParameters(mediaSection); var remoteIceParameters; var remoteDtlsParameters; if (!rejected) { remoteIceParameters = SDPUtils.getIceParameters(mediaSection, sessionpart); remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection, sessionpart); remoteDtlsParameters.role = 'client'; } recvEncodingParameters = SDPUtils.parseRtpEncodingParameters(mediaSection); var rtcpParameters = SDPUtils.parseRtcpParameters(mediaSection); var isComplete = SDPUtils.matchPrefix(mediaSection, 'a=end-of-candidates', sessionpart).length &gt; 0; var cands = SDPUtils.matchPrefix(mediaSection, 'a=candidate:') .map(function(cand) { return SDPUtils.parseCandidate(cand); }) .filter(function(cand) { return cand.component === '1' || cand.component === 1; }); if (description.type === 'offer' &amp;&amp; !rejected) { transceiver = self.transceivers[sdpMLineIndex] || self._createTransceiver(kind); transceiver.mid = mid; if (!transceiver.iceGatherer) { transceiver.iceGatherer = usingBundle &amp;&amp; sdpMLineIndex &gt; 0 ? self.transceivers[0].iceGatherer : self._createIceGatherer(mid, sdpMLineIndex); } if (isComplete &amp;&amp; (!usingBundle || sdpMLineIndex === 0)) { transceiver.iceTransport.setRemoteCandidates(cands); } localCapabilities = RTCRtpReceiver.getCapabilities(kind); // filter RTX until additional stuff needed for RTX is implemented // in adapter.js if (edgeVersion &lt; 15019) { localCapabilities.codecs = localCapabilities.codecs.filter( function(codec) { return codec.name !== 'rtx'; }); } sendEncodingParameters = [{ ssrc: (2 * sdpMLineIndex + 2) * 1001 }]; if (direction === 'sendrecv' || direction === 'sendonly') { rtpReceiver = new RTCRtpReceiver(transceiver.dtlsTransport, kind); track = rtpReceiver.track; // FIXME: does not work with Plan B. if (remoteMsid) { if (!streams[remoteMsid.stream]) { streams[remoteMsid.stream] = new MediaStream(); Object.defineProperty(streams[remoteMsid.stream], 'id', { get: function() { return remoteMsid.stream; } }); } Object.defineProperty(track, 'id', { get: function() { return remoteMsid.track; } }); streams[remoteMsid.stream].addTrack(track); receiverList.push([track, rtpReceiver, streams[remoteMsid.stream]]); } else { if (!streams.default) { streams.default = new MediaStream(); } streams.default.addTrack(track); receiverList.push([track, rtpReceiver, streams.default]); } } transceiver.localCapabilities = localCapabilities; transceiver.remoteCapabilities = remoteCapabilities; transceiver.rtpReceiver = rtpReceiver; transceiver.rtcpParameters = rtcpParameters; transceiver.sendEncodingParameters = sendEncodingParameters; transceiver.recvEncodingParameters = recvEncodingParameters; // Start the RTCRtpReceiver now. The RTPSender is started in // setLocalDescription. self._transceive(self.transceivers[sdpMLineIndex], false, direction === 'sendrecv' || direction === 'sendonly'); } else if (description.type === 'answer' &amp;&amp; !rejected) { if (usingBundle &amp;&amp; sdpMLineIndex &gt; 0) { self._disposeIceAndDtlsTransports(sdpMLineIndex); self.transceivers[sdpMLineIndex].iceGatherer = self.transceivers[0].iceGatherer; self.transceivers[sdpMLineIndex].iceTransport = self.transceivers[0].iceTransport; self.transceivers[sdpMLineIndex].dtlsTransport = self.transceivers[0].dtlsTransport; if (self.transceivers[sdpMLineIndex].rtpSender) { self.transceivers[sdpMLineIndex].rtpSender.setTransport( self.transceivers[0].dtlsTransport); } if (self.transceivers[sdpMLineIndex].rtpReceiver) { self.transceivers[sdpMLineIndex].rtpReceiver.setTransport( self.transceivers[0].dtlsTransport); } } transceiver = self.transceivers[sdpMLineIndex]; iceGatherer = transceiver.iceGatherer; iceTransport = transceiver.iceTransport; dtlsTransport = transceiver.dtlsTransport; rtpReceiver = transceiver.rtpReceiver; sendEncodingParameters = transceiver.sendEncodingParameters; localCapabilities = transceiver.localCapabilities; self.transceivers[sdpMLineIndex].recvEncodingParameters = recvEncodingParameters; self.transceivers[sdpMLineIndex].remoteCapabilities = remoteCapabilities; self.transceivers[sdpMLineIndex].rtcpParameters = rtcpParameters; if ((isIceLite || isComplete) &amp;&amp; cands.length) { iceTransport.setRemoteCandidates(cands); } if (!usingBundle || sdpMLineIndex === 0) { iceTransport.start(iceGatherer, remoteIceParameters, 'controlling'); dtlsTransport.start(remoteDtlsParameters); } self._transceive(transceiver, direction === 'sendrecv' || direction === 'recvonly', direction === 'sendrecv' || direction === 'sendonly'); if (rtpReceiver &amp;&amp; (direction === 'sendrecv' || direction === 'sendonly')) { track = rtpReceiver.track; if (remoteMsid) { if (!streams[remoteMsid.stream]) { streams[remoteMsid.stream] = new MediaStream(); } streams[remoteMsid.stream].addTrack(track); receiverList.push([track, rtpReceiver, streams[remoteMsid.stream]]); } else { if (!streams.default) { streams.default = new MediaStream(); } streams.default.addTrack(track); receiverList.push([track, rtpReceiver, streams.default]); } } else { // FIXME: actually the receiver should be created later. delete transceiver.rtpReceiver; } } }); this.remoteDescription = { type: description.type, sdp: description.sdp }; switch (description.type) { case 'offer': this._updateSignalingState('have-remote-offer'); break; case 'answer': this._updateSignalingState('stable'); break; default: throw new TypeError('unsupported type \"' + description.type + '\"'); } Object.keys(streams).forEach(function(sid) { var stream = streams[sid]; if (stream.getTracks().length) { self.remoteStreams.push(stream); var event = new Event('addstream'); event.stream = stream; self.dispatchEvent(event); if (self.onaddstream !== null) { window.setTimeout(function() { self.onaddstream(event); }, 0); } receiverList.forEach(function(item) { var track = item[0]; var receiver = item[1]; if (stream.id !== item[2].id) { return; } var trackEvent = new Event('track'); trackEvent.track = track; trackEvent.receiver = receiver; trackEvent.streams = [stream]; self.dispatchEvent(trackEvent); if (self.ontrack !== null) { window.setTimeout(function() { self.ontrack(trackEvent); }, 0); } }); } }); // check whether addIceCandidate({}) was called within four seconds after // setRemoteDescription. window.setTimeout(function() { if (!(self &amp;&amp; self.transceivers)) { return; } self.transceivers.forEach(function(transceiver) { if (transceiver.iceTransport &amp;&amp; transceiver.iceTransport.state === 'new' &amp;&amp; transceiver.iceTransport.getRemoteCandidates().length &gt; 0) { console.warn('Timeout for addRemoteCandidate. Consider sending ' + 'an end-of-candidates notification'); transceiver.iceTransport.addRemoteCandidate({}); } }); }, 4000); if (arguments.length &gt; 1 &amp;&amp; typeof arguments[1] === 'function') { window.setTimeout(arguments[1], 0); } return Promise.resolve(); }; RTCPeerConnection.prototype.close = function() { this.transceivers.forEach(function(transceiver) { /* not yet if (transceiver.iceGatherer) { transceiver.iceGatherer.close(); } */ if (transceiver.iceTransport) { transceiver.iceTransport.stop(); } if (transceiver.dtlsTransport) { transceiver.dtlsTransport.stop(); } if (transceiver.rtpSender) { transceiver.rtpSender.stop(); } if (transceiver.rtpReceiver) { transceiver.rtpReceiver.stop(); } }); // FIXME: clean up tracks, local streams, remote streams, etc this._updateSignalingState('closed'); }; // Update the signaling state. RTCPeerConnection.prototype._updateSignalingState = function(newState) { this.signalingState = newState; var event = new Event('signalingstatechange'); this.dispatchEvent(event); if (this.onsignalingstatechange !== null) { this.onsignalingstatechange(event); } }; // Determine whether to fire the negotiationneeded event. RTCPeerConnection.prototype._maybeFireNegotiationNeeded = function() { var self = this; if (this.signalingState !== 'stable' || this.needNegotiation === true) { return; } this.needNegotiation = true; window.setTimeout(function() { if (self.needNegotiation === false) { return; } self.needNegotiation = false; var event = new Event('negotiationneeded'); self.dispatchEvent(event); if (self.onnegotiationneeded !== null) { self.onnegotiationneeded(event); } }, 0); }; // Update the connection state. RTCPeerConnection.prototype._updateConnectionState = function() { var self = this; var newState; var states = { 'new': 0, closed: 0, connecting: 0, checking: 0, connected: 0, completed: 0, failed: 0 }; this.transceivers.forEach(function(transceiver) { states[transceiver.iceTransport.state]++; states[transceiver.dtlsTransport.state]++; }); // ICETransport.completed and connected are the same for this purpose. states.connected += states.completed; newState = 'new'; if (states.failed &gt; 0) { newState = 'failed'; } else if (states.connecting &gt; 0 || states.checking &gt; 0) { newState = 'connecting'; } else if (states.disconnected &gt; 0) { newState = 'disconnected'; } else if (states.new &gt; 0) { newState = 'new'; } else if (states.connected &gt; 0 || states.completed &gt; 0) { newState = 'connected'; } if (newState !== self.iceConnectionState) { self.iceConnectionState = newState; var event = new Event('iceconnectionstatechange'); this.dispatchEvent(event); if (this.oniceconnectionstatechange !== null) { this.oniceconnectionstatechange(event); } } }; RTCPeerConnection.prototype.createOffer = function() { var self = this; if (this._pendingOffer) { throw new Error('createOffer called while there is a pending offer.'); } var offerOptions; if (arguments.length === 1 &amp;&amp; typeof arguments[0] !== 'function') { offerOptions = arguments[0]; } else if (arguments.length === 3) { offerOptions = arguments[2]; } var numAudioTracks = this.transceivers.filter(function(t) { return t.kind === 'audio'; }).length; var numVideoTracks = this.transceivers.filter(function(t) { return t.kind === 'video'; }).length; // Determine number of audio and video tracks we need to send/recv. if (offerOptions) { // Reject Chrome legacy constraints. if (offerOptions.mandatory || offerOptions.optional) { throw new TypeError( 'Legacy mandatory/optional constraints not supported.'); } if (offerOptions.offerToReceiveAudio !== undefined) { if (offerOptions.offerToReceiveAudio === true) { numAudioTracks = 1; } else if (offerOptions.offerToReceiveAudio === false) { numAudioTracks = 0; } else { numAudioTracks = offerOptions.offerToReceiveAudio; } } if (offerOptions.offerToReceiveVideo !== undefined) { if (offerOptions.offerToReceiveVideo === true) { numVideoTracks = 1; } else if (offerOptions.offerToReceiveVideo === false) { numVideoTracks = 0; } else { numVideoTracks = offerOptions.offerToReceiveVideo; } } } this.transceivers.forEach(function(transceiver) { if (transceiver.kind === 'audio') { numAudioTracks--; if (numAudioTracks &lt; 0) { transceiver.wantReceive = false; } } else if (transceiver.kind === 'video') { numVideoTracks--; if (numVideoTracks &lt; 0) { transceiver.wantReceive = false; } } }); // Create M-lines for recvonly streams. while (numAudioTracks &gt; 0 || numVideoTracks &gt; 0) { if (numAudioTracks &gt; 0) { this._createTransceiver('audio'); numAudioTracks--; } if (numVideoTracks &gt; 0) { this._createTransceiver('video'); numVideoTracks--; } } // reorder tracks var transceivers = sortTracks(this.transceivers); var sdp = SDPUtils.writeSessionBoilerplate(); transceivers.forEach(function(transceiver, sdpMLineIndex) { // For each track, create an ice gatherer, ice transport, // dtls transport, potentially rtpsender and rtpreceiver. var track = transceiver.track; var kind = transceiver.kind; var mid = SDPUtils.generateIdentifier(); transceiver.mid = mid; if (!transceiver.iceGatherer) { transceiver.iceGatherer = self.usingBundle &amp;&amp; sdpMLineIndex &gt; 0 ? transceivers[0].iceGatherer : self._createIceGatherer(mid, sdpMLineIndex); } var localCapabilities = RTCRtpSender.getCapabilities(kind); // filter RTX until additional stuff needed for RTX is implemented // in adapter.js if (edgeVersion &lt; 15019) { localCapabilities.codecs = localCapabilities.codecs.filter( function(codec) { return codec.name !== 'rtx'; }); } localCapabilities.codecs.forEach(function(codec) { // work around https://bugs.chromium.org/p/webrtc/issues/detail?id=6552 // by adding level-asymmetry-allowed=1 if (codec.name === 'H264' &amp;&amp; codec.parameters['level-asymmetry-allowed'] === undefined) { codec.parameters['level-asymmetry-allowed'] = '1'; } }); // generate an ssrc now, to be used later in rtpSender.send var sendEncodingParameters = [{ ssrc: (2 * sdpMLineIndex + 1) * 1001 }]; if (track) { // add RTX if (edgeVersion &gt;= 15019 &amp;&amp; kind === 'video') { sendEncodingParameters[0].rtx = { ssrc: (2 * sdpMLineIndex + 1) * 1001 + 1 }; } } if (transceiver.wantReceive) { transceiver.rtpReceiver = new RTCRtpReceiver(transceiver.dtlsTransport, kind); } transceiver.localCapabilities = localCapabilities; transceiver.sendEncodingParameters = sendEncodingParameters; }); // always offer BUNDLE and dispose on return if not supported. if (this._config.bundlePolicy !== 'max-compat') { sdp += 'a=group:BUNDLE ' + transceivers.map(function(t) { return t.mid; }).join(' ') + '\\r\\n'; } sdp += 'a=ice-options:trickle\\r\\n'; transceivers.forEach(function(transceiver, sdpMLineIndex) { sdp += SDPUtils.writeMediaSection(transceiver, transceiver.localCapabilities, 'offer', transceiver.stream); sdp += 'a=rtcp-rsize\\r\\n'; }); this._pendingOffer = transceivers; var desc = new RTCSessionDescription({ type: 'offer', sdp: sdp }); if (arguments.length &amp;&amp; typeof arguments[0] === 'function') { window.setTimeout(arguments[0], 0, desc); } return Promise.resolve(desc); }; RTCPeerConnection.prototype.createAnswer = function() { var sdp = SDPUtils.writeSessionBoilerplate(); if (this.usingBundle) { sdp += 'a=group:BUNDLE ' + this.transceivers.map(function(t) { return t.mid; }).join(' ') + '\\r\\n'; } this.transceivers.forEach(function(transceiver, sdpMLineIndex) { if (transceiver.isDatachannel) { sdp += 'm=application 0 DTLS/SCTP 5000\\r\\n' + 'c=IN IP4 0.0.0.0\\r\\n' + 'a=mid:' + transceiver.mid + '\\r\\n'; return; } // FIXME: look at direction. if (transceiver.stream) { var localTrack; if (transceiver.kind === 'audio') { localTrack = transceiver.stream.getAudioTracks()[0]; } else if (transceiver.kind === 'video') { localTrack = transceiver.stream.getVideoTracks()[0]; } if (localTrack) { // add RTX if (edgeVersion &gt;= 15019 &amp;&amp; transceiver.kind === 'video') { transceiver.sendEncodingParameters[0].rtx = { ssrc: (2 * sdpMLineIndex + 2) * 1001 + 1 }; } } } // Calculate intersection of capabilities. var commonCapabilities = getCommonCapabilities( transceiver.localCapabilities, transceiver.remoteCapabilities); var hasRtx = commonCapabilities.codecs.filter(function(c) { return c.name.toLowerCase() === 'rtx'; }).length; if (!hasRtx &amp;&amp; transceiver.sendEncodingParameters[0].rtx) { delete transceiver.sendEncodingParameters[0].rtx; } sdp += SDPUtils.writeMediaSection(transceiver, commonCapabilities, 'answer', transceiver.stream); if (transceiver.rtcpParameters &amp;&amp; transceiver.rtcpParameters.reducedSize) { sdp += 'a=rtcp-rsize\\r\\n'; } }); var desc = new RTCSessionDescription({ type: 'answer', sdp: sdp }); if (arguments.length &amp;&amp; typeof arguments[0] === 'function') { window.setTimeout(arguments[0], 0, desc); } return Promise.resolve(desc); }; RTCPeerConnection.prototype.addIceCandidate = function(candidate) { if (!candidate) { for (var j = 0; j &lt; this.transceivers.length; j++) { this.transceivers[j].iceTransport.addRemoteCandidate({}); if (this.usingBundle) { return Promise.resolve(); } } } else { var mLineIndex = candidate.sdpMLineIndex; if (candidate.sdpMid) { for (var i = 0; i &lt; this.transceivers.length; i++) { if (this.transceivers[i].mid === candidate.sdpMid) { mLineIndex = i; break; } } } var transceiver = this.transceivers[mLineIndex]; if (transceiver) { var cand = Object.keys(candidate.candidate).length &gt; 0 ? SDPUtils.parseCandidate(candidate.candidate) : {}; // Ignore Chrome's invalid candidates since Edge does not like them. if (cand.protocol === 'tcp' &amp;&amp; (cand.port === 0 || cand.port === 9)) { return Promise.resolve(); } // Ignore RTCP candidates, we assume RTCP-MUX. if (cand.component &amp;&amp; !(cand.component === '1' || cand.component === 1)) { return Promise.resolve(); } transceiver.iceTransport.addRemoteCandidate(cand); // update the remoteDescription. var sections = SDPUtils.splitSections(this.remoteDescription.sdp); sections[mLineIndex + 1] += (cand.type ? candidate.candidate.trim() : 'a=end-of-candidates') + '\\r\\n'; this.remoteDescription.sdp = sections.join(''); } } if (arguments.length &gt; 1 &amp;&amp; typeof arguments[1] === 'function') { window.setTimeout(arguments[1], 0); } return Promise.resolve(); }; RTCPeerConnection.prototype.getStats = function() { var promises = []; this.transceivers.forEach(function(transceiver) { ['rtpSender', 'rtpReceiver', 'iceGatherer', 'iceTransport', 'dtlsTransport'].forEach(function(method) { if (transceiver[method]) { promises.push(transceiver[method].getStats()); } }); }); var cb = arguments.length &gt; 1 &amp;&amp; typeof arguments[1] === 'function' &amp;&amp; arguments[1]; var fixStatsType = function(stat) { return { inboundrtp: 'inbound-rtp', outboundrtp: 'outbound-rtp', candidatepair: 'candidate-pair', localcandidate: 'local-candidate', remotecandidate: 'remote-candidate' }[stat.type] || stat.type; }; return new Promise(function(resolve) { // shim getStats with maplike support var results = new Map(); Promise.all(promises).then(function(res) { res.forEach(function(result) { Object.keys(result).forEach(function(id) { result[id].type = fixStatsType(result[id]); results.set(id, result[id]); }); }); if (cb) { window.setTimeout(cb, 0, results); } resolve(results); }); }); }; return RTCPeerConnection; }; },{\"sdp\":1}],8:[function(require,module,exports){ /* * Copyright (c) 2016 The WebRTC project authors. All Rights Reserved. * * Use of this source code is governed by a BSD-style license * that can be found in the LICENSE file in the root of the source * tree. */ /* eslint-env node */ 'use strict'; var browserDetails = require('../utils').browserDetails; var firefoxShim = { shimOnTrack: function() { if (typeof window === 'object' &amp;&amp; window.RTCPeerConnection &amp;&amp; !('ontrack' in window.RTCPeerConnection.prototype)) { Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', { get: function() { return this._ontrack; }, set: function(f) { if (this._ontrack) { this.removeEventListener('track', this._ontrack); this.removeEventListener('addstream', this._ontrackpoly); } this.addEventListener('track', this._ontrack = f); this.addEventListener('addstream', this._ontrackpoly = function(e) { e.stream.getTracks().forEach(function(track) { var event = new Event('track'); event.track = track; event.receiver = {track: track}; event.streams = [e.stream]; this.dispatchEvent(event); }.bind(this)); }.bind(this)); } }); } }, shimSourceObject: function() { // Firefox has supported mozSrcObject since FF22, unprefixed in 42. if (typeof window === 'object') { if (window.HTMLMediaElement &amp;&amp; !('srcObject' in window.HTMLMediaElement.prototype)) { // Shim the srcObject property, once, when HTMLMediaElement is found. Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', { get: function() { return this.mozSrcObject; }, set: function(stream) { this.mozSrcObject = stream; } }); } } }, shimPeerConnection: function() { if (typeof window !== 'object' || !(window.RTCPeerConnection || window.mozRTCPeerConnection)) { return; // probably media.peerconnection.enabled=false in about:config } // The RTCPeerConnection object. if (!window.RTCPeerConnection) { window.RTCPeerConnection = function(pcConfig, pcConstraints) { if (browserDetails.version &lt; 38) { // .urls is not supported in FF &lt; 38. // create RTCIceServers with a single url. if (pcConfig &amp;&amp; pcConfig.iceServers) { var newIceServers = []; for (var i = 0; i &lt; pcConfig.iceServers.length; i++) { var server = pcConfig.iceServers[i]; if (server.hasOwnProperty('urls')) { for (var j = 0; j &lt; server.urls.length; j++) { var newServer = { url: server.urls[j] }; if (server.urls[j].indexOf('turn') === 0) { newServer.username = server.username; newServer.credential = server.credential; } newIceServers.push(newServer); } } else { newIceServers.push(pcConfig.iceServers[i]); } } pcConfig.iceServers = newIceServers; } } return new mozRTCPeerConnection(pcConfig, pcConstraints); }; window.RTCPeerConnection.prototype = mozRTCPeerConnection.prototype; // wrap static methods. Currently just generateCertificate. if (mozRTCPeerConnection.generateCertificate) { Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', { get: function() { return mozRTCPeerConnection.generateCertificate; } }); } window.RTCSessionDescription = mozRTCSessionDescription; window.RTCIceCandidate = mozRTCIceCandidate; } // shim away need for obsolete RTCIceCandidate/RTCSessionDescription. ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'] .forEach(function(method) { var nativeMethod = RTCPeerConnection.prototype[method]; RTCPeerConnection.prototype[method] = function() { arguments[0] = new ((method === 'addIceCandidate') ? RTCIceCandidate : RTCSessionDescription)(arguments[0]); return nativeMethod.apply(this, arguments); }; }); // support for addIceCandidate(null or undefined) var nativeAddIceCandidate = RTCPeerConnection.prototype.addIceCandidate; RTCPeerConnection.prototype.addIceCandidate = function() { if (!arguments[0]) { if (arguments[1]) { arguments[1].apply(null); } return Promise.resolve(); } return nativeAddIceCandidate.apply(this, arguments); }; // shim getStats with maplike support var makeMapStats = function(stats) { var map = new Map(); Object.keys(stats).forEach(function(key) { map.set(key, stats[key]); map[key] = stats[key]; }); return map; }; var modernStatsTypes = { inboundrtp: 'inbound-rtp', outboundrtp: 'outbound-rtp', candidatepair: 'candidate-pair', localcandidate: 'local-candidate', remotecandidate: 'remote-candidate' }; var nativeGetStats = RTCPeerConnection.prototype.getStats; RTCPeerConnection.prototype.getStats = function(selector, onSucc, onErr) { return nativeGetStats.apply(this, [selector || null]) .then(function(stats) { if (browserDetails.version &lt; 48) { stats = makeMapStats(stats); } if (browserDetails.version &lt; 53 &amp;&amp; !onSucc) { // Shim only promise getStats with spec-hyphens in type names // Leave callback version alone; misc old uses of forEach before Map try { stats.forEach(function(stat) { stat.type = modernStatsTypes[stat.type] || stat.type; }); } catch (e) { if (e.name !== 'TypeError') { throw e; } // Avoid TypeError: \"type\" is read-only, in old versions. 34-43ish stats.forEach(function(stat, i) { stats.set(i, Object.assign({}, stat, { type: modernStatsTypes[stat.type] || stat.type })); }); } } return stats; }) .then(onSucc, onErr); }; } }; // Expose public methods. module.exports = { shimOnTrack: firefoxShim.shimOnTrack, shimSourceObject: firefoxShim.shimSourceObject, shimPeerConnection: firefoxShim.shimPeerConnection, shimGetUserMedia: require('./getusermedia') }; },{\"../utils\":11,\"./getusermedia\":9}],9:[function(require,module,exports){ /* * Copyright (c) 2016 The WebRTC project authors. All Rights Reserved. * * Use of this source code is governed by a BSD-style license * that can be found in the LICENSE file in the root of the source * tree. */ /* eslint-env node */ 'use strict'; var logging = require('../utils').log; var browserDetails = require('../utils').browserDetails; // Expose public methods. module.exports = function() { var shimError_ = function(e) { return { name: { InternalError: 'NotReadableError', NotSupportedError: 'TypeError', PermissionDeniedError: 'NotAllowedError', SecurityError: 'NotAllowedError' }[e.name] || e.name, message: { 'The operation is insecure.': 'The request is not allowed by the ' + 'user agent or the platform in the current context.' }[e.message] || e.message, constraint: e.constraint, toString: function() { return this.name + (this.message &amp;&amp; ': ') + this.message; } }; }; // getUserMedia constraints shim. var getUserMedia_ = function(constraints, onSuccess, onError) { var constraintsToFF37_ = function(c) { if (typeof c !== 'object' || c.require) { return c; } var require = []; Object.keys(c).forEach(function(key) { if (key === 'require' || key === 'advanced' || key === 'mediaSource') { return; } var r = c[key] = (typeof c[key] === 'object') ? c[key] : {ideal: c[key]}; if (r.min !== undefined || r.max !== undefined || r.exact !== undefined) { require.push(key); } if (r.exact !== undefined) { if (typeof r.exact === 'number') { r. min = r.max = r.exact; } else { c[key] = r.exact; } delete r.exact; } if (r.ideal !== undefined) { c.advanced = c.advanced || []; var oc = {}; if (typeof r.ideal === 'number') { oc[key] = {min: r.ideal, max: r.ideal}; } else { oc[key] = r.ideal; } c.advanced.push(oc); delete r.ideal; if (!Object.keys(r).length) { delete c[key]; } } }); if (require.length) { c.require = require; } return c; }; constraints = JSON.parse(JSON.stringify(constraints)); if (browserDetails.version &lt; 38) { logging('spec: ' + JSON.stringify(constraints)); if (constraints.audio) { constraints.audio = constraintsToFF37_(constraints.audio); } if (constraints.video) { constraints.video = constraintsToFF37_(constraints.video); } logging('ff37: ' + JSON.stringify(constraints)); } return navigator.mozGetUserMedia(constraints, onSuccess, function(e) { onError(shimError_(e)); }); }; // Returns the result of getUserMedia as a Promise. var getUserMediaPromise_ = function(constraints) { return new Promise(function(resolve, reject) { getUserMedia_(constraints, resolve, reject); }); }; // Shim for mediaDevices on older versions. if (!navigator.mediaDevices) { navigator.mediaDevices = {getUserMedia: getUserMediaPromise_, addEventListener: function() { }, removeEventListener: function() { } }; } navigator.mediaDevices.enumerateDevices = navigator.mediaDevices.enumerateDevices || function() { return new Promise(function(resolve) { var infos = [ {kind: 'audioinput', deviceId: 'default', label: '', groupId: ''}, {kind: 'videoinput', deviceId: 'default', label: '', groupId: ''} ]; resolve(infos); }); }; if (browserDetails.version &lt; 41) { // Work around http://bugzil.la/1169665 var orgEnumerateDevices = navigator.mediaDevices.enumerateDevices.bind(navigator.mediaDevices); navigator.mediaDevices.enumerateDevices = function() { return orgEnumerateDevices().then(undefined, function(e) { if (e.name === 'NotFoundError') { return []; } throw e; }); }; } if (browserDetails.version &lt; 49) { var origGetUserMedia = navigator.mediaDevices.getUserMedia. bind(navigator.mediaDevices); navigator.mediaDevices.getUserMedia = function(c) { return origGetUserMedia(c).then(function(stream) { // Work around https://bugzil.la/802326 if (c.audio &amp;&amp; !stream.getAudioTracks().length || c.video &amp;&amp; !stream.getVideoTracks().length) { stream.getTracks().forEach(function(track) { track.stop(); }); throw new DOMException('The object can not be found here.', 'NotFoundError'); } return stream; }, function(e) { return Promise.reject(shimError_(e)); }); }; } navigator.getUserMedia = function(constraints, onSuccess, onError) { if (browserDetails.version &lt; 44) { return getUserMedia_(constraints, onSuccess, onError); } // Replace Firefox 44+'s deprecation warning with unprefixed version. console.warn('navigator.getUserMedia has been replaced by ' + 'navigator.mediaDevices.getUserMedia'); navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError); }; }; },{\"../utils\":11}],10:[function(require,module,exports){ /* * Copyright (c) 2016 The WebRTC project authors. All Rights Reserved. * * Use of this source code is governed by a BSD-style license * that can be found in the LICENSE file in the root of the source * tree. */ 'use strict'; var safariShim = { // TODO: DrAlex, should be here, double check against LayoutTests // TODO: once the back-end for the mac port is done, add. // TODO: check for webkitGTK+ // shimPeerConnection: function() { }, shimAddStream: function() { if (typeof window === 'object' &amp;&amp; window.RTCPeerConnection &amp;&amp; !('addStream' in window.RTCPeerConnection.prototype)) { RTCPeerConnection.prototype.addStream = function(stream) { var self = this; stream.getTracks().forEach(function(track) { self.addTrack(track, stream); }); }; } }, shimOnAddStream: function() { if (typeof window === 'object' &amp;&amp; window.RTCPeerConnection &amp;&amp; !('onaddstream' in window.RTCPeerConnection.prototype)) { Object.defineProperty(window.RTCPeerConnection.prototype, 'onaddstream', { get: function() { return this._onaddstream; }, set: function(f) { if (this._onaddstream) { this.removeEventListener('addstream', this._onaddstream); this.removeEventListener('track', this._onaddstreampoly); } this.addEventListener('addstream', this._onaddstream = f); this.addEventListener('track', this._onaddstreampoly = function(e) { var stream = e.streams[0]; if (!this._streams) { this._streams = []; } if (this._streams.indexOf(stream) &gt;= 0) { return; } this._streams.push(stream); var event = new Event('addstream'); event.stream = e.streams[0]; this.dispatchEvent(event); }.bind(this)); } }); } }, shimCallbacksAPI: function() { if (typeof window !== 'object' || !window.RTCPeerConnection) { return; } var prototype = RTCPeerConnection.prototype; var createOffer = prototype.createOffer; var createAnswer = prototype.createAnswer; var setLocalDescription = prototype.setLocalDescription; var setRemoteDescription = prototype.setRemoteDescription; var addIceCandidate = prototype.addIceCandidate; prototype.createOffer = function(successCallback, failureCallback) { var options = (arguments.length &gt;= 2) ? arguments[2] : arguments[0]; var promise = createOffer.apply(this, [options]); if (!failureCallback) { return promise; } promise.then(successCallback, failureCallback); return Promise.resolve(); }; prototype.createAnswer = function(successCallback, failureCallback) { var options = (arguments.length &gt;= 2) ? arguments[2] : arguments[0]; var promise = createAnswer.apply(this, [options]); if (!failureCallback) { return promise; } promise.then(successCallback, failureCallback); return Promise.resolve(); }; var withCallback = function(description, successCallback, failureCallback) { var promise = setLocalDescription.apply(this, [description]); if (!failureCallback) { return promise; } promise.then(successCallback, failureCallback); return Promise.resolve(); }; prototype.setLocalDescription = withCallback; withCallback = function(description, successCallback, failureCallback) { var promise = setRemoteDescription.apply(this, [description]); if (!failureCallback) { return promise; } promise.then(successCallback, failureCallback); return Promise.resolve(); }; prototype.setRemoteDescription = withCallback; withCallback = function(candidate, successCallback, failureCallback) { var promise = addIceCandidate.apply(this, [candidate]); if (!failureCallback) { return promise; } promise.then(successCallback, failureCallback); return Promise.resolve(); }; prototype.addIceCandidate = withCallback; }, shimGetUserMedia: function() { if (!navigator.getUserMedia) { if (navigator.webkitGetUserMedia) { navigator.getUserMedia = navigator.webkitGetUserMedia.bind(navigator); } else if (navigator.mediaDevices &amp;&amp; navigator.mediaDevices.getUserMedia) { navigator.getUserMedia = function(constraints, cb, errcb) { navigator.mediaDevices.getUserMedia(constraints) .then(cb, errcb); }.bind(navigator); } } } }; // Expose public methods. module.exports = { shimCallbacksAPI: safariShim.shimCallbacksAPI, shimAddStream: safariShim.shimAddStream, shimOnAddStream: safariShim.shimOnAddStream, shimGetUserMedia: safariShim.shimGetUserMedia // TODO // shimPeerConnection: safariShim.shimPeerConnection }; },{}],11:[function(require,module,exports){ /* * Copyright (c) 2016 The WebRTC project authors. All Rights Reserved. * * Use of this source code is governed by a BSD-style license * that can be found in the LICENSE file in the root of the source * tree. */ /* eslint-env node */ 'use strict'; var logDisabled_ = true; // Utility methods. var utils = { disableLog: function(bool) { if (typeof bool !== 'boolean') { return new Error('Argument type: ' + typeof bool + '. Please use a boolean.'); } logDisabled_ = bool; return (bool) ? 'adapter.js logging disabled' : 'adapter.js logging enabled'; }, log: function() { if (typeof window === 'object') { if (logDisabled_) { return; } if (typeof console !== 'undefined' &amp;&amp; typeof console.log === 'function') { console.log.apply(console, arguments); } } }, /** * Extract browser version out of the provided user agent string. * * @param {!string} uastring userAgent string. * @param {!string} expr Regular expression used as match criteria. * @param {!number} pos position in the version string to be returned. * @return {!number} browser version. */ extractVersion: function(uastring, expr, pos) { var match = uastring.match(expr); return match &amp;&amp; match.length &gt;= pos &amp;&amp; parseInt(match[pos], 10); }, /** * Browser detector. * * @return {object} result containing browser and version * properties. */ detectBrowser: function() { // Returned result object. var result = {}; result.browser = null; result.version = null; // Fail early if it's not a browser if (typeof window === 'undefined' || !window.navigator) { result.browser = 'Not a browser.'; return result; } // Firefox. if (navigator.mozGetUserMedia) { result.browser = 'firefox'; result.version = this.extractVersion(navigator.userAgent, /Firefox\\/(\\d+)\\./, 1); } else if (navigator.webkitGetUserMedia) { // Chrome, Chromium, Webview, Opera, all use the chrome shim for now if (window.webkitRTCPeerConnection) { result.browser = 'chrome'; result.version = this.extractVersion(navigator.userAgent, /Chrom(e|ium)\\/(\\d+)\\./, 2); } else { // Safari (in an unpublished version) or unknown webkit-based. if (navigator.userAgent.match(/Version\\/(\\d+).(\\d+)/)) { result.browser = 'safari'; result.version = this.extractVersion(navigator.userAgent, /AppleWebKit\\/(\\d+)\\./, 1); } else { // unknown webkit-based browser. result.browser = 'Unsupported webkit-based browser ' + 'with GUM support but no WebRTC support.'; return result; } } } else if (navigator.mediaDevices &amp;&amp; navigator.userAgent.match(/Edge\\/(\\d+).(\\d+)$/)) { // Edge. result.browser = 'edge'; result.version = this.extractVersion(navigator.userAgent, /Edge\\/(\\d+).(\\d+)$/, 2); } else if (navigator.mediaDevices &amp;&amp; navigator.userAgent.match(/AppleWebKit\\/(\\d+)\\./)) { // Safari, with webkitGetUserMedia removed. result.browser = 'safari'; result.version = this.extractVersion(navigator.userAgent, /AppleWebKit\\/(\\d+)\\./, 1); } else { // Default fallthrough: not supported. result.browser = 'Not a supported browser.'; return result; } return result; }, // shimCreateObjectURL must be called before shimSourceObject to avoid loop. shimCreateObjectURL: function() { if (!(typeof window === 'object' &amp;&amp; window.HTMLMediaElement &amp;&amp; 'srcObject' in window.HTMLMediaElement.prototype)) { // Only shim CreateObjectURL using srcObject if srcObject exists. return undefined; } var nativeCreateObjectURL = URL.createObjectURL.bind(URL); var nativeRevokeObjectURL = URL.revokeObjectURL.bind(URL); var streams = new Map(), newId = 0; URL.createObjectURL = function(stream) { if ('getTracks' in stream) { var url = 'polyblob:' + (++newId); streams.set(url, stream); console.log('URL.createObjectURL(stream) is deprecated! ' + 'Use elem.srcObject = stream instead!'); return url; } return nativeCreateObjectURL(stream); }; URL.revokeObjectURL = function(url) { nativeRevokeObjectURL(url); streams.delete(url); }; var dsc = Object.getOwnPropertyDescriptor(window.HTMLMediaElement.prototype, 'src'); Object.defineProperty(window.HTMLMediaElement.prototype, 'src', { get: function() { return dsc.get.apply(this); }, set: function(url) { this.srcObject = streams.get(url) || null; return dsc.set.apply(this, [url]); } }); var nativeSetAttribute = HTMLMediaElement.prototype.setAttribute; HTMLMediaElement.prototype.setAttribute = function() { if (arguments.length === 2 &amp;&amp; ('' + arguments[0]).toLowerCase() === 'src') { this.srcObject = streams.get(arguments[1]) || null; } return nativeSetAttribute.apply(this, arguments); }; } }; // Export. module.exports = { log: utils.log, disableLog: utils.disableLog, browserDetails: utils.detectBrowser(), extractVersion: utils.extractVersion, shimCreateObjectURL: utils.shimCreateObjectURL, detectBrowser: utils.detectBrowser.bind(utils) }; },{}]},{},[2])(2) }); × Search results Close "},"elastos-trinity-plugins-qrscanner_node_modules_webrtc-adapter_out_adapter_no_edge.js.html":{"id":"elastos-trinity-plugins-qrscanner_node_modules_webrtc-adapter_out_adapter_no_edge.js.html","title":"Source: elastos-trinity-plugins-qrscanner/node_modules/webrtc-adapter/out/adapter_no_edge.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: elastos-trinity-plugins-qrscanner/node_modules/webrtc-adapter/out/adapter_no_edge.js (function(f){if(typeof exports===\"object\"&amp;&amp;typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&amp;&amp;define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.adapter = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&amp;&amp;require;if(!u&amp;&amp;a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&amp;&amp;require;for(var o=0;o&lt;r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){ },{}],2:[function(require,module,exports){ /* * Copyright (c) 2016 The WebRTC project authors. All Rights Reserved. * * Use of this source code is governed by a BSD-style license * that can be found in the LICENSE file in the root of the source * tree. */ /* eslint-env node */ 'use strict'; // Shimming starts here. (function() { // Utils. var utils = require('./utils'); var logging = utils.log; var browserDetails = utils.browserDetails; // Export to the adapter global object visible in the browser. module.exports.browserDetails = browserDetails; module.exports.extractVersion = utils.extractVersion; module.exports.disableLog = utils.disableLog; // Uncomment the line below if you want logging to occur, including logging // for the switch statement below. Can also be turned on in the browser via // adapter.disableLog(false), but then logging from the switch statement below // will not appear. // require('./utils').disableLog(false); // Browser shims. var chromeShim = require('./chrome/chrome_shim') || null; var edgeShim = require('./edge/edge_shim') || null; var firefoxShim = require('./firefox/firefox_shim') || null; var safariShim = require('./safari/safari_shim') || null; // Shim browser if found. switch (browserDetails.browser) { case 'chrome': if (!chromeShim || !chromeShim.shimPeerConnection) { logging('Chrome shim is not included in this adapter release.'); return; } logging('adapter.js shimming chrome.'); // Export to the adapter global object visible in the browser. module.exports.browserShim = chromeShim; chromeShim.shimGetUserMedia(); chromeShim.shimMediaStream(); utils.shimCreateObjectURL(); chromeShim.shimSourceObject(); chromeShim.shimPeerConnection(); chromeShim.shimOnTrack(); chromeShim.shimGetSendersWithDtmf(); break; case 'firefox': if (!firefoxShim || !firefoxShim.shimPeerConnection) { logging('Firefox shim is not included in this adapter release.'); return; } logging('adapter.js shimming firefox.'); // Export to the adapter global object visible in the browser. module.exports.browserShim = firefoxShim; firefoxShim.shimGetUserMedia(); utils.shimCreateObjectURL(); firefoxShim.shimSourceObject(); firefoxShim.shimPeerConnection(); firefoxShim.shimOnTrack(); break; case 'edge': if (!edgeShim || !edgeShim.shimPeerConnection) { logging('MS edge shim is not included in this adapter release.'); return; } logging('adapter.js shimming edge.'); // Export to the adapter global object visible in the browser. module.exports.browserShim = edgeShim; edgeShim.shimGetUserMedia(); utils.shimCreateObjectURL(); edgeShim.shimPeerConnection(); edgeShim.shimReplaceTrack(); break; case 'safari': if (!safariShim) { logging('Safari shim is not included in this adapter release.'); return; } logging('adapter.js shimming safari.'); // Export to the adapter global object visible in the browser. module.exports.browserShim = safariShim; safariShim.shimCallbacksAPI(); safariShim.shimAddStream(); safariShim.shimOnAddStream(); safariShim.shimGetUserMedia(); break; default: logging('Unsupported browser!'); } })(); },{\"./chrome/chrome_shim\":3,\"./edge/edge_shim\":1,\"./firefox/firefox_shim\":5,\"./safari/safari_shim\":7,\"./utils\":8}],3:[function(require,module,exports){ /* * Copyright (c) 2016 The WebRTC project authors. All Rights Reserved. * * Use of this source code is governed by a BSD-style license * that can be found in the LICENSE file in the root of the source * tree. */ /* eslint-env node */ 'use strict'; var logging = require('../utils.js').log; var browserDetails = require('../utils.js').browserDetails; var chromeShim = { shimMediaStream: function() { window.MediaStream = window.MediaStream || window.webkitMediaStream; }, shimOnTrack: function() { if (typeof window === 'object' &amp;&amp; window.RTCPeerConnection &amp;&amp; !('ontrack' in window.RTCPeerConnection.prototype)) { Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', { get: function() { return this._ontrack; }, set: function(f) { var self = this; if (this._ontrack) { this.removeEventListener('track', this._ontrack); this.removeEventListener('addstream', this._ontrackpoly); } this.addEventListener('track', this._ontrack = f); this.addEventListener('addstream', this._ontrackpoly = function(e) { // onaddstream does not fire when a track is added to an existing // stream. But stream.onaddtrack is implemented so we use that. e.stream.addEventListener('addtrack', function(te) { var receiver; if (RTCPeerConnection.prototype.getReceivers) { receiver = self.getReceivers().find(function(r) { return r.track.id === te.track.id; }); } else { receiver = {track: te.track}; } var event = new Event('track'); event.track = te.track; event.receiver = receiver; event.streams = [e.stream]; self.dispatchEvent(event); }); e.stream.getTracks().forEach(function(track) { var receiver; if (RTCPeerConnection.prototype.getReceivers) { receiver = self.getReceivers().find(function(r) { return r.track.id === track.id; }); } else { receiver = {track: track}; } var event = new Event('track'); event.track = track; event.receiver = receiver; event.streams = [e.stream]; this.dispatchEvent(event); }.bind(this)); }.bind(this)); } }); } }, shimGetSendersWithDtmf: function() { if (typeof window === 'object' &amp;&amp; window.RTCPeerConnection &amp;&amp; !('getSenders' in RTCPeerConnection.prototype) &amp;&amp; 'createDTMFSender' in RTCPeerConnection.prototype) { RTCPeerConnection.prototype.getSenders = function() { return this._senders || []; }; var origAddStream = RTCPeerConnection.prototype.addStream; var origRemoveStream = RTCPeerConnection.prototype.removeStream; if (!RTCPeerConnection.prototype.addTrack) { RTCPeerConnection.prototype.addTrack = function(track, stream) { var pc = this; if (pc.signalingState === 'closed') { throw new DOMException( 'The RTCPeerConnection\\'s signalingState is \\'closed\\'.', 'InvalidStateError'); } var streams = [].slice.call(arguments, 1); if (streams.length !== 1 || !streams[0].getTracks().find(function(t) { return t === track; })) { // this is not fully correct but all we can manage without // [[associated MediaStreams]] internal slot. throw new DOMException( 'The adapter.js addTrack polyfill only supports a single ' + ' stream which is associated with the specified track.', 'NotSupportedError'); } pc._senders = pc._senders || []; var alreadyExists = pc._senders.find(function(t) { return t.track === track; }); if (alreadyExists) { throw new DOMException('Track already exists.', 'InvalidAccessError'); } pc._streams = pc._streams || {}; var oldStream = pc._streams[stream.id]; if (oldStream) { oldStream.addTrack(track); pc.removeStream(oldStream); pc.addStream(oldStream); } else { var newStream = new MediaStream([track]); pc._streams[stream.id] = newStream; pc.addStream(newStream); } var sender = { track: track, get dtmf() { if (this._dtmf === undefined) { if (track.kind === 'audio') { this._dtmf = pc.createDTMFSender(track); } else { this._dtmf = null; } } return this._dtmf; } }; pc._senders.push(sender); return sender; }; } RTCPeerConnection.prototype.addStream = function(stream) { var pc = this; pc._senders = pc._senders || []; origAddStream.apply(pc, [stream]); stream.getTracks().forEach(function(track) { pc._senders.push({ track: track, get dtmf() { if (this._dtmf === undefined) { if (track.kind === 'audio') { this._dtmf = pc.createDTMFSender(track); } else { this._dtmf = null; } } return this._dtmf; } }); }); }; RTCPeerConnection.prototype.removeStream = function(stream) { var pc = this; pc._senders = pc._senders || []; origRemoveStream.apply(pc, [stream]); stream.getTracks().forEach(function(track) { var sender = pc._senders.find(function(s) { return s.track === track; }); if (sender) { pc._senders.splice(pc._senders.indexOf(sender), 1); // remove sender } }); }; } }, shimSourceObject: function() { if (typeof window === 'object') { if (window.HTMLMediaElement &amp;&amp; !('srcObject' in window.HTMLMediaElement.prototype)) { // Shim the srcObject property, once, when HTMLMediaElement is found. Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', { get: function() { return this._srcObject; }, set: function(stream) { var self = this; // Use _srcObject as a private property for this shim this._srcObject = stream; if (this.src) { URL.revokeObjectURL(this.src); } if (!stream) { this.src = ''; return undefined; } this.src = URL.createObjectURL(stream); // We need to recreate the blob url when a track is added or // removed. Doing it manually since we want to avoid a recursion. stream.addEventListener('addtrack', function() { if (self.src) { URL.revokeObjectURL(self.src); } self.src = URL.createObjectURL(stream); }); stream.addEventListener('removetrack', function() { if (self.src) { URL.revokeObjectURL(self.src); } self.src = URL.createObjectURL(stream); }); } }); } } }, shimPeerConnection: function() { // The RTCPeerConnection object. if (!window.RTCPeerConnection) { window.RTCPeerConnection = function(pcConfig, pcConstraints) { // Translate iceTransportPolicy to iceTransports, // see https://code.google.com/p/webrtc/issues/detail?id=4869 // this was fixed in M56 along with unprefixing RTCPeerConnection. logging('PeerConnection'); if (pcConfig &amp;&amp; pcConfig.iceTransportPolicy) { pcConfig.iceTransports = pcConfig.iceTransportPolicy; } return new webkitRTCPeerConnection(pcConfig, pcConstraints); }; window.RTCPeerConnection.prototype = webkitRTCPeerConnection.prototype; // wrap static methods. Currently just generateCertificate. if (webkitRTCPeerConnection.generateCertificate) { Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', { get: function() { return webkitRTCPeerConnection.generateCertificate; } }); } } else { // migrate from non-spec RTCIceServer.url to RTCIceServer.urls var OrigPeerConnection = RTCPeerConnection; window.RTCPeerConnection = function(pcConfig, pcConstraints) { if (pcConfig &amp;&amp; pcConfig.iceServers) { var newIceServers = []; for (var i = 0; i &lt; pcConfig.iceServers.length; i++) { var server = pcConfig.iceServers[i]; if (!server.hasOwnProperty('urls') &amp;&amp; server.hasOwnProperty('url')) { console.warn('RTCIceServer.url is deprecated! Use urls instead.'); server = JSON.parse(JSON.stringify(server)); server.urls = server.url; newIceServers.push(server); } else { newIceServers.push(pcConfig.iceServers[i]); } } pcConfig.iceServers = newIceServers; } return new OrigPeerConnection(pcConfig, pcConstraints); }; window.RTCPeerConnection.prototype = OrigPeerConnection.prototype; // wrap static methods. Currently just generateCertificate. Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', { get: function() { return OrigPeerConnection.generateCertificate; } }); } var origGetStats = RTCPeerConnection.prototype.getStats; RTCPeerConnection.prototype.getStats = function(selector, successCallback, errorCallback) { var self = this; var args = arguments; // If selector is a function then we are in the old style stats so just // pass back the original getStats format to avoid breaking old users. if (arguments.length &gt; 0 &amp;&amp; typeof selector === 'function') { return origGetStats.apply(this, arguments); } // When spec-style getStats is supported, return those when called with // either no arguments or the selector argument is null. if (origGetStats.length === 0 &amp;&amp; (arguments.length === 0 || typeof arguments[0] !== 'function')) { return origGetStats.apply(this, []); } var fixChromeStats_ = function(response) { var standardReport = {}; var reports = response.result(); reports.forEach(function(report) { var standardStats = { id: report.id, timestamp: report.timestamp, type: { localcandidate: 'local-candidate', remotecandidate: 'remote-candidate' }[report.type] || report.type }; report.names().forEach(function(name) { standardStats[name] = report.stat(name); }); standardReport[standardStats.id] = standardStats; }); return standardReport; }; // shim getStats with maplike support var makeMapStats = function(stats) { return new Map(Object.keys(stats).map(function(key) { return [key, stats[key]]; })); }; if (arguments.length &gt;= 2) { var successCallbackWrapper_ = function(response) { args[1](makeMapStats(fixChromeStats_(response))); }; return origGetStats.apply(this, [successCallbackWrapper_, arguments[0]]); } // promise-support return new Promise(function(resolve, reject) { origGetStats.apply(self, [ function(response) { resolve(makeMapStats(fixChromeStats_(response))); }, reject]); }).then(successCallback, errorCallback); }; // add promise support -- natively available in Chrome 51 if (browserDetails.version &lt; 51) { ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'] .forEach(function(method) { var nativeMethod = RTCPeerConnection.prototype[method]; RTCPeerConnection.prototype[method] = function() { var args = arguments; var self = this; var promise = new Promise(function(resolve, reject) { nativeMethod.apply(self, [args[0], resolve, reject]); }); if (args.length &lt; 2) { return promise; } return promise.then(function() { args[1].apply(null, []); }, function(err) { if (args.length &gt;= 3) { args[2].apply(null, [err]); } }); }; }); } // promise support for createOffer and createAnswer. Available (without // bugs) since M52: crbug/619289 if (browserDetails.version &lt; 52) { ['createOffer', 'createAnswer'].forEach(function(method) { var nativeMethod = RTCPeerConnection.prototype[method]; RTCPeerConnection.prototype[method] = function() { var self = this; if (arguments.length &lt; 1 || (arguments.length === 1 &amp;&amp; typeof arguments[0] === 'object')) { var opts = arguments.length === 1 ? arguments[0] : undefined; return new Promise(function(resolve, reject) { nativeMethod.apply(self, [resolve, reject, opts]); }); } return nativeMethod.apply(this, arguments); }; }); } // shim implicit creation of RTCSessionDescription/RTCIceCandidate ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'] .forEach(function(method) { var nativeMethod = RTCPeerConnection.prototype[method]; RTCPeerConnection.prototype[method] = function() { arguments[0] = new ((method === 'addIceCandidate') ? RTCIceCandidate : RTCSessionDescription)(arguments[0]); return nativeMethod.apply(this, arguments); }; }); // support for addIceCandidate(null or undefined) var nativeAddIceCandidate = RTCPeerConnection.prototype.addIceCandidate; RTCPeerConnection.prototype.addIceCandidate = function() { if (!arguments[0]) { if (arguments[1]) { arguments[1].apply(null); } return Promise.resolve(); } return nativeAddIceCandidate.apply(this, arguments); }; } }; // Expose public methods. module.exports = { shimMediaStream: chromeShim.shimMediaStream, shimOnTrack: chromeShim.shimOnTrack, shimGetSendersWithDtmf: chromeShim.shimGetSendersWithDtmf, shimSourceObject: chromeShim.shimSourceObject, shimPeerConnection: chromeShim.shimPeerConnection, shimGetUserMedia: require('./getusermedia') }; },{\"../utils.js\":8,\"./getusermedia\":4}],4:[function(require,module,exports){ /* * Copyright (c) 2016 The WebRTC project authors. All Rights Reserved. * * Use of this source code is governed by a BSD-style license * that can be found in the LICENSE file in the root of the source * tree. */ /* eslint-env node */ 'use strict'; var logging = require('../utils.js').log; var browserDetails = require('../utils.js').browserDetails; // Expose public methods. module.exports = function() { var constraintsToChrome_ = function(c) { if (typeof c !== 'object' || c.mandatory || c.optional) { return c; } var cc = {}; Object.keys(c).forEach(function(key) { if (key === 'require' || key === 'advanced' || key === 'mediaSource') { return; } var r = (typeof c[key] === 'object') ? c[key] : {ideal: c[key]}; if (r.exact !== undefined &amp;&amp; typeof r.exact === 'number') { r.min = r.max = r.exact; } var oldname_ = function(prefix, name) { if (prefix) { return prefix + name.charAt(0).toUpperCase() + name.slice(1); } return (name === 'deviceId') ? 'sourceId' : name; }; if (r.ideal !== undefined) { cc.optional = cc.optional || []; var oc = {}; if (typeof r.ideal === 'number') { oc[oldname_('min', key)] = r.ideal; cc.optional.push(oc); oc = {}; oc[oldname_('max', key)] = r.ideal; cc.optional.push(oc); } else { oc[oldname_('', key)] = r.ideal; cc.optional.push(oc); } } if (r.exact !== undefined &amp;&amp; typeof r.exact !== 'number') { cc.mandatory = cc.mandatory || {}; cc.mandatory[oldname_('', key)] = r.exact; } else { ['min', 'max'].forEach(function(mix) { if (r[mix] !== undefined) { cc.mandatory = cc.mandatory || {}; cc.mandatory[oldname_(mix, key)] = r[mix]; } }); } }); if (c.advanced) { cc.optional = (cc.optional || []).concat(c.advanced); } return cc; }; var shimConstraints_ = function(constraints, func) { constraints = JSON.parse(JSON.stringify(constraints)); if (constraints &amp;&amp; constraints.audio) { constraints.audio = constraintsToChrome_(constraints.audio); } if (constraints &amp;&amp; typeof constraints.video === 'object') { // Shim facingMode for mobile &amp; surface pro. var face = constraints.video.facingMode; face = face &amp;&amp; ((typeof face === 'object') ? face : {ideal: face}); var getSupportedFacingModeLies = browserDetails.version &lt; 61; if ((face &amp;&amp; (face.exact === 'user' || face.exact === 'environment' || face.ideal === 'user' || face.ideal === 'environment')) &amp;&amp; !(navigator.mediaDevices.getSupportedConstraints &amp;&amp; navigator.mediaDevices.getSupportedConstraints().facingMode &amp;&amp; !getSupportedFacingModeLies)) { delete constraints.video.facingMode; var matches; if (face.exact === 'environment' || face.ideal === 'environment') { matches = ['back', 'rear']; } else if (face.exact === 'user' || face.ideal === 'user') { matches = ['front']; } if (matches) { // Look for matches in label, or use last cam for back (typical). return navigator.mediaDevices.enumerateDevices() .then(function(devices) { devices = devices.filter(function(d) { return d.kind === 'videoinput'; }); var dev = devices.find(function(d) { return matches.some(function(match) { return d.label.toLowerCase().indexOf(match) !== -1; }); }); if (!dev &amp;&amp; devices.length &amp;&amp; matches.indexOf('back') !== -1) { dev = devices[devices.length - 1]; // more likely the back cam } if (dev) { constraints.video.deviceId = face.exact ? {exact: dev.deviceId} : {ideal: dev.deviceId}; } constraints.video = constraintsToChrome_(constraints.video); logging('chrome: ' + JSON.stringify(constraints)); return func(constraints); }); } } constraints.video = constraintsToChrome_(constraints.video); } logging('chrome: ' + JSON.stringify(constraints)); return func(constraints); }; var shimError_ = function(e) { return { name: { ConstraintNotSatisfiedError: 'OverconstrainedError', PermissionDeniedError: 'NotAllowedError', TrackStartError: 'NotReadableError' }[e.name] || e.name, message: e.message, constraint: e.constraintName, toString: function() { return this.name + (this.message &amp;&amp; ': ') + this.message; } }; }; var getUserMedia_ = function(constraints, onSuccess, onError) { shimConstraints_(constraints, function(c) { navigator.webkitGetUserMedia(c, onSuccess, function(e) { onError(shimError_(e)); }); }); }; navigator.getUserMedia = getUserMedia_; // Returns the result of getUserMedia as a Promise. var getUserMediaPromise_ = function(constraints) { return new Promise(function(resolve, reject) { navigator.getUserMedia(constraints, resolve, reject); }); }; if (!navigator.mediaDevices) { navigator.mediaDevices = { getUserMedia: getUserMediaPromise_, enumerateDevices: function() { return new Promise(function(resolve) { var kinds = {audio: 'audioinput', video: 'videoinput'}; return MediaStreamTrack.getSources(function(devices) { resolve(devices.map(function(device) { return {label: device.label, kind: kinds[device.kind], deviceId: device.id, groupId: ''}; })); }); }); }, getSupportedConstraints: function() { return { deviceId: true, echoCancellation: true, facingMode: true, frameRate: true, height: true, width: true }; } }; } // A shim for getUserMedia method on the mediaDevices object. // TODO(KaptenJansson) remove once implemented in Chrome stable. if (!navigator.mediaDevices.getUserMedia) { navigator.mediaDevices.getUserMedia = function(constraints) { return getUserMediaPromise_(constraints); }; } else { // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia // function which returns a Promise, it does not accept spec-style // constraints. var origGetUserMedia = navigator.mediaDevices.getUserMedia. bind(navigator.mediaDevices); navigator.mediaDevices.getUserMedia = function(cs) { return shimConstraints_(cs, function(c) { return origGetUserMedia(c).then(function(stream) { if (c.audio &amp;&amp; !stream.getAudioTracks().length || c.video &amp;&amp; !stream.getVideoTracks().length) { stream.getTracks().forEach(function(track) { track.stop(); }); throw new DOMException('', 'NotFoundError'); } return stream; }, function(e) { return Promise.reject(shimError_(e)); }); }); }; } // Dummy devicechange event methods. // TODO(KaptenJansson) remove once implemented in Chrome stable. if (typeof navigator.mediaDevices.addEventListener === 'undefined') { navigator.mediaDevices.addEventListener = function() { logging('Dummy mediaDevices.addEventListener called.'); }; } if (typeof navigator.mediaDevices.removeEventListener === 'undefined') { navigator.mediaDevices.removeEventListener = function() { logging('Dummy mediaDevices.removeEventListener called.'); }; } }; },{\"../utils.js\":8}],5:[function(require,module,exports){ /* * Copyright (c) 2016 The WebRTC project authors. All Rights Reserved. * * Use of this source code is governed by a BSD-style license * that can be found in the LICENSE file in the root of the source * tree. */ /* eslint-env node */ 'use strict'; var browserDetails = require('../utils').browserDetails; var firefoxShim = { shimOnTrack: function() { if (typeof window === 'object' &amp;&amp; window.RTCPeerConnection &amp;&amp; !('ontrack' in window.RTCPeerConnection.prototype)) { Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', { get: function() { return this._ontrack; }, set: function(f) { if (this._ontrack) { this.removeEventListener('track', this._ontrack); this.removeEventListener('addstream', this._ontrackpoly); } this.addEventListener('track', this._ontrack = f); this.addEventListener('addstream', this._ontrackpoly = function(e) { e.stream.getTracks().forEach(function(track) { var event = new Event('track'); event.track = track; event.receiver = {track: track}; event.streams = [e.stream]; this.dispatchEvent(event); }.bind(this)); }.bind(this)); } }); } }, shimSourceObject: function() { // Firefox has supported mozSrcObject since FF22, unprefixed in 42. if (typeof window === 'object') { if (window.HTMLMediaElement &amp;&amp; !('srcObject' in window.HTMLMediaElement.prototype)) { // Shim the srcObject property, once, when HTMLMediaElement is found. Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', { get: function() { return this.mozSrcObject; }, set: function(stream) { this.mozSrcObject = stream; } }); } } }, shimPeerConnection: function() { if (typeof window !== 'object' || !(window.RTCPeerConnection || window.mozRTCPeerConnection)) { return; // probably media.peerconnection.enabled=false in about:config } // The RTCPeerConnection object. if (!window.RTCPeerConnection) { window.RTCPeerConnection = function(pcConfig, pcConstraints) { if (browserDetails.version &lt; 38) { // .urls is not supported in FF &lt; 38. // create RTCIceServers with a single url. if (pcConfig &amp;&amp; pcConfig.iceServers) { var newIceServers = []; for (var i = 0; i &lt; pcConfig.iceServers.length; i++) { var server = pcConfig.iceServers[i]; if (server.hasOwnProperty('urls')) { for (var j = 0; j &lt; server.urls.length; j++) { var newServer = { url: server.urls[j] }; if (server.urls[j].indexOf('turn') === 0) { newServer.username = server.username; newServer.credential = server.credential; } newIceServers.push(newServer); } } else { newIceServers.push(pcConfig.iceServers[i]); } } pcConfig.iceServers = newIceServers; } } return new mozRTCPeerConnection(pcConfig, pcConstraints); }; window.RTCPeerConnection.prototype = mozRTCPeerConnection.prototype; // wrap static methods. Currently just generateCertificate. if (mozRTCPeerConnection.generateCertificate) { Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', { get: function() { return mozRTCPeerConnection.generateCertificate; } }); } window.RTCSessionDescription = mozRTCSessionDescription; window.RTCIceCandidate = mozRTCIceCandidate; } // shim away need for obsolete RTCIceCandidate/RTCSessionDescription. ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'] .forEach(function(method) { var nativeMethod = RTCPeerConnection.prototype[method]; RTCPeerConnection.prototype[method] = function() { arguments[0] = new ((method === 'addIceCandidate') ? RTCIceCandidate : RTCSessionDescription)(arguments[0]); return nativeMethod.apply(this, arguments); }; }); // support for addIceCandidate(null or undefined) var nativeAddIceCandidate = RTCPeerConnection.prototype.addIceCandidate; RTCPeerConnection.prototype.addIceCandidate = function() { if (!arguments[0]) { if (arguments[1]) { arguments[1].apply(null); } return Promise.resolve(); } return nativeAddIceCandidate.apply(this, arguments); }; // shim getStats with maplike support var makeMapStats = function(stats) { var map = new Map(); Object.keys(stats).forEach(function(key) { map.set(key, stats[key]); map[key] = stats[key]; }); return map; }; var modernStatsTypes = { inboundrtp: 'inbound-rtp', outboundrtp: 'outbound-rtp', candidatepair: 'candidate-pair', localcandidate: 'local-candidate', remotecandidate: 'remote-candidate' }; var nativeGetStats = RTCPeerConnection.prototype.getStats; RTCPeerConnection.prototype.getStats = function(selector, onSucc, onErr) { return nativeGetStats.apply(this, [selector || null]) .then(function(stats) { if (browserDetails.version &lt; 48) { stats = makeMapStats(stats); } if (browserDetails.version &lt; 53 &amp;&amp; !onSucc) { // Shim only promise getStats with spec-hyphens in type names // Leave callback version alone; misc old uses of forEach before Map try { stats.forEach(function(stat) { stat.type = modernStatsTypes[stat.type] || stat.type; }); } catch (e) { if (e.name !== 'TypeError') { throw e; } // Avoid TypeError: \"type\" is read-only, in old versions. 34-43ish stats.forEach(function(stat, i) { stats.set(i, Object.assign({}, stat, { type: modernStatsTypes[stat.type] || stat.type })); }); } } return stats; }) .then(onSucc, onErr); }; } }; // Expose public methods. module.exports = { shimOnTrack: firefoxShim.shimOnTrack, shimSourceObject: firefoxShim.shimSourceObject, shimPeerConnection: firefoxShim.shimPeerConnection, shimGetUserMedia: require('./getusermedia') }; },{\"../utils\":8,\"./getusermedia\":6}],6:[function(require,module,exports){ /* * Copyright (c) 2016 The WebRTC project authors. All Rights Reserved. * * Use of this source code is governed by a BSD-style license * that can be found in the LICENSE file in the root of the source * tree. */ /* eslint-env node */ 'use strict'; var logging = require('../utils').log; var browserDetails = require('../utils').browserDetails; // Expose public methods. module.exports = function() { var shimError_ = function(e) { return { name: { InternalError: 'NotReadableError', NotSupportedError: 'TypeError', PermissionDeniedError: 'NotAllowedError', SecurityError: 'NotAllowedError' }[e.name] || e.name, message: { 'The operation is insecure.': 'The request is not allowed by the ' + 'user agent or the platform in the current context.' }[e.message] || e.message, constraint: e.constraint, toString: function() { return this.name + (this.message &amp;&amp; ': ') + this.message; } }; }; // getUserMedia constraints shim. var getUserMedia_ = function(constraints, onSuccess, onError) { var constraintsToFF37_ = function(c) { if (typeof c !== 'object' || c.require) { return c; } var require = []; Object.keys(c).forEach(function(key) { if (key === 'require' || key === 'advanced' || key === 'mediaSource') { return; } var r = c[key] = (typeof c[key] === 'object') ? c[key] : {ideal: c[key]}; if (r.min !== undefined || r.max !== undefined || r.exact !== undefined) { require.push(key); } if (r.exact !== undefined) { if (typeof r.exact === 'number') { r. min = r.max = r.exact; } else { c[key] = r.exact; } delete r.exact; } if (r.ideal !== undefined) { c.advanced = c.advanced || []; var oc = {}; if (typeof r.ideal === 'number') { oc[key] = {min: r.ideal, max: r.ideal}; } else { oc[key] = r.ideal; } c.advanced.push(oc); delete r.ideal; if (!Object.keys(r).length) { delete c[key]; } } }); if (require.length) { c.require = require; } return c; }; constraints = JSON.parse(JSON.stringify(constraints)); if (browserDetails.version &lt; 38) { logging('spec: ' + JSON.stringify(constraints)); if (constraints.audio) { constraints.audio = constraintsToFF37_(constraints.audio); } if (constraints.video) { constraints.video = constraintsToFF37_(constraints.video); } logging('ff37: ' + JSON.stringify(constraints)); } return navigator.mozGetUserMedia(constraints, onSuccess, function(e) { onError(shimError_(e)); }); }; // Returns the result of getUserMedia as a Promise. var getUserMediaPromise_ = function(constraints) { return new Promise(function(resolve, reject) { getUserMedia_(constraints, resolve, reject); }); }; // Shim for mediaDevices on older versions. if (!navigator.mediaDevices) { navigator.mediaDevices = {getUserMedia: getUserMediaPromise_, addEventListener: function() { }, removeEventListener: function() { } }; } navigator.mediaDevices.enumerateDevices = navigator.mediaDevices.enumerateDevices || function() { return new Promise(function(resolve) { var infos = [ {kind: 'audioinput', deviceId: 'default', label: '', groupId: ''}, {kind: 'videoinput', deviceId: 'default', label: '', groupId: ''} ]; resolve(infos); }); }; if (browserDetails.version &lt; 41) { // Work around http://bugzil.la/1169665 var orgEnumerateDevices = navigator.mediaDevices.enumerateDevices.bind(navigator.mediaDevices); navigator.mediaDevices.enumerateDevices = function() { return orgEnumerateDevices().then(undefined, function(e) { if (e.name === 'NotFoundError') { return []; } throw e; }); }; } if (browserDetails.version &lt; 49) { var origGetUserMedia = navigator.mediaDevices.getUserMedia. bind(navigator.mediaDevices); navigator.mediaDevices.getUserMedia = function(c) { return origGetUserMedia(c).then(function(stream) { // Work around https://bugzil.la/802326 if (c.audio &amp;&amp; !stream.getAudioTracks().length || c.video &amp;&amp; !stream.getVideoTracks().length) { stream.getTracks().forEach(function(track) { track.stop(); }); throw new DOMException('The object can not be found here.', 'NotFoundError'); } return stream; }, function(e) { return Promise.reject(shimError_(e)); }); }; } navigator.getUserMedia = function(constraints, onSuccess, onError) { if (browserDetails.version &lt; 44) { return getUserMedia_(constraints, onSuccess, onError); } // Replace Firefox 44+'s deprecation warning with unprefixed version. console.warn('navigator.getUserMedia has been replaced by ' + 'navigator.mediaDevices.getUserMedia'); navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError); }; }; },{\"../utils\":8}],7:[function(require,module,exports){ /* * Copyright (c) 2016 The WebRTC project authors. All Rights Reserved. * * Use of this source code is governed by a BSD-style license * that can be found in the LICENSE file in the root of the source * tree. */ 'use strict'; var safariShim = { // TODO: DrAlex, should be here, double check against LayoutTests // TODO: once the back-end for the mac port is done, add. // TODO: check for webkitGTK+ // shimPeerConnection: function() { }, shimAddStream: function() { if (typeof window === 'object' &amp;&amp; window.RTCPeerConnection &amp;&amp; !('addStream' in window.RTCPeerConnection.prototype)) { RTCPeerConnection.prototype.addStream = function(stream) { var self = this; stream.getTracks().forEach(function(track) { self.addTrack(track, stream); }); }; } }, shimOnAddStream: function() { if (typeof window === 'object' &amp;&amp; window.RTCPeerConnection &amp;&amp; !('onaddstream' in window.RTCPeerConnection.prototype)) { Object.defineProperty(window.RTCPeerConnection.prototype, 'onaddstream', { get: function() { return this._onaddstream; }, set: function(f) { if (this._onaddstream) { this.removeEventListener('addstream', this._onaddstream); this.removeEventListener('track', this._onaddstreampoly); } this.addEventListener('addstream', this._onaddstream = f); this.addEventListener('track', this._onaddstreampoly = function(e) { var stream = e.streams[0]; if (!this._streams) { this._streams = []; } if (this._streams.indexOf(stream) &gt;= 0) { return; } this._streams.push(stream); var event = new Event('addstream'); event.stream = e.streams[0]; this.dispatchEvent(event); }.bind(this)); } }); } }, shimCallbacksAPI: function() { if (typeof window !== 'object' || !window.RTCPeerConnection) { return; } var prototype = RTCPeerConnection.prototype; var createOffer = prototype.createOffer; var createAnswer = prototype.createAnswer; var setLocalDescription = prototype.setLocalDescription; var setRemoteDescription = prototype.setRemoteDescription; var addIceCandidate = prototype.addIceCandidate; prototype.createOffer = function(successCallback, failureCallback) { var options = (arguments.length &gt;= 2) ? arguments[2] : arguments[0]; var promise = createOffer.apply(this, [options]); if (!failureCallback) { return promise; } promise.then(successCallback, failureCallback); return Promise.resolve(); }; prototype.createAnswer = function(successCallback, failureCallback) { var options = (arguments.length &gt;= 2) ? arguments[2] : arguments[0]; var promise = createAnswer.apply(this, [options]); if (!failureCallback) { return promise; } promise.then(successCallback, failureCallback); return Promise.resolve(); }; var withCallback = function(description, successCallback, failureCallback) { var promise = setLocalDescription.apply(this, [description]); if (!failureCallback) { return promise; } promise.then(successCallback, failureCallback); return Promise.resolve(); }; prototype.setLocalDescription = withCallback; withCallback = function(description, successCallback, failureCallback) { var promise = setRemoteDescription.apply(this, [description]); if (!failureCallback) { return promise; } promise.then(successCallback, failureCallback); return Promise.resolve(); }; prototype.setRemoteDescription = withCallback; withCallback = function(candidate, successCallback, failureCallback) { var promise = addIceCandidate.apply(this, [candidate]); if (!failureCallback) { return promise; } promise.then(successCallback, failureCallback); return Promise.resolve(); }; prototype.addIceCandidate = withCallback; }, shimGetUserMedia: function() { if (!navigator.getUserMedia) { if (navigator.webkitGetUserMedia) { navigator.getUserMedia = navigator.webkitGetUserMedia.bind(navigator); } else if (navigator.mediaDevices &amp;&amp; navigator.mediaDevices.getUserMedia) { navigator.getUserMedia = function(constraints, cb, errcb) { navigator.mediaDevices.getUserMedia(constraints) .then(cb, errcb); }.bind(navigator); } } } }; // Expose public methods. module.exports = { shimCallbacksAPI: safariShim.shimCallbacksAPI, shimAddStream: safariShim.shimAddStream, shimOnAddStream: safariShim.shimOnAddStream, shimGetUserMedia: safariShim.shimGetUserMedia // TODO // shimPeerConnection: safariShim.shimPeerConnection }; },{}],8:[function(require,module,exports){ /* * Copyright (c) 2016 The WebRTC project authors. All Rights Reserved. * * Use of this source code is governed by a BSD-style license * that can be found in the LICENSE file in the root of the source * tree. */ /* eslint-env node */ 'use strict'; var logDisabled_ = true; // Utility methods. var utils = { disableLog: function(bool) { if (typeof bool !== 'boolean') { return new Error('Argument type: ' + typeof bool + '. Please use a boolean.'); } logDisabled_ = bool; return (bool) ? 'adapter.js logging disabled' : 'adapter.js logging enabled'; }, log: function() { if (typeof window === 'object') { if (logDisabled_) { return; } if (typeof console !== 'undefined' &amp;&amp; typeof console.log === 'function') { console.log.apply(console, arguments); } } }, /** * Extract browser version out of the provided user agent string. * * @param {!string} uastring userAgent string. * @param {!string} expr Regular expression used as match criteria. * @param {!number} pos position in the version string to be returned. * @return {!number} browser version. */ extractVersion: function(uastring, expr, pos) { var match = uastring.match(expr); return match &amp;&amp; match.length &gt;= pos &amp;&amp; parseInt(match[pos], 10); }, /** * Browser detector. * * @return {object} result containing browser and version * properties. */ detectBrowser: function() { // Returned result object. var result = {}; result.browser = null; result.version = null; // Fail early if it's not a browser if (typeof window === 'undefined' || !window.navigator) { result.browser = 'Not a browser.'; return result; } // Firefox. if (navigator.mozGetUserMedia) { result.browser = 'firefox'; result.version = this.extractVersion(navigator.userAgent, /Firefox\\/(\\d+)\\./, 1); } else if (navigator.webkitGetUserMedia) { // Chrome, Chromium, Webview, Opera, all use the chrome shim for now if (window.webkitRTCPeerConnection) { result.browser = 'chrome'; result.version = this.extractVersion(navigator.userAgent, /Chrom(e|ium)\\/(\\d+)\\./, 2); } else { // Safari (in an unpublished version) or unknown webkit-based. if (navigator.userAgent.match(/Version\\/(\\d+).(\\d+)/)) { result.browser = 'safari'; result.version = this.extractVersion(navigator.userAgent, /AppleWebKit\\/(\\d+)\\./, 1); } else { // unknown webkit-based browser. result.browser = 'Unsupported webkit-based browser ' + 'with GUM support but no WebRTC support.'; return result; } } } else if (navigator.mediaDevices &amp;&amp; navigator.userAgent.match(/Edge\\/(\\d+).(\\d+)$/)) { // Edge. result.browser = 'edge'; result.version = this.extractVersion(navigator.userAgent, /Edge\\/(\\d+).(\\d+)$/, 2); } else if (navigator.mediaDevices &amp;&amp; navigator.userAgent.match(/AppleWebKit\\/(\\d+)\\./)) { // Safari, with webkitGetUserMedia removed. result.browser = 'safari'; result.version = this.extractVersion(navigator.userAgent, /AppleWebKit\\/(\\d+)\\./, 1); } else { // Default fallthrough: not supported. result.browser = 'Not a supported browser.'; return result; } return result; }, // shimCreateObjectURL must be called before shimSourceObject to avoid loop. shimCreateObjectURL: function() { if (!(typeof window === 'object' &amp;&amp; window.HTMLMediaElement &amp;&amp; 'srcObject' in window.HTMLMediaElement.prototype)) { // Only shim CreateObjectURL using srcObject if srcObject exists. return undefined; } var nativeCreateObjectURL = URL.createObjectURL.bind(URL); var nativeRevokeObjectURL = URL.revokeObjectURL.bind(URL); var streams = new Map(), newId = 0; URL.createObjectURL = function(stream) { if ('getTracks' in stream) { var url = 'polyblob:' + (++newId); streams.set(url, stream); console.log('URL.createObjectURL(stream) is deprecated! ' + 'Use elem.srcObject = stream instead!'); return url; } return nativeCreateObjectURL(stream); }; URL.revokeObjectURL = function(url) { nativeRevokeObjectURL(url); streams.delete(url); }; var dsc = Object.getOwnPropertyDescriptor(window.HTMLMediaElement.prototype, 'src'); Object.defineProperty(window.HTMLMediaElement.prototype, 'src', { get: function() { return dsc.get.apply(this); }, set: function(url) { this.srcObject = streams.get(url) || null; return dsc.set.apply(this, [url]); } }); var nativeSetAttribute = HTMLMediaElement.prototype.setAttribute; HTMLMediaElement.prototype.setAttribute = function() { if (arguments.length === 2 &amp;&amp; ('' + arguments[0]).toLowerCase() === 'src') { this.srcObject = streams.get(arguments[1]) || null; } return nativeSetAttribute.apply(this, arguments); }; } }; // Export. module.exports = { log: utils.log, disableLog: utils.disableLog, browserDetails: utils.detectBrowser(), extractVersion: utils.extractVersion, shimCreateObjectURL: utils.shimCreateObjectURL, detectBrowser: utils.detectBrowser.bind(utils) }; },{}]},{},[2])(2) }); × Search results Close "},"elastos-trinity-plugins-qrscanner_node_modules_webrtc-adapter_out_adapter_no_edge_no_global.js.html":{"id":"elastos-trinity-plugins-qrscanner_node_modules_webrtc-adapter_out_adapter_no_edge_no_global.js.html","title":"Source: elastos-trinity-plugins-qrscanner/node_modules/webrtc-adapter/out/adapter_no_edge_no_global.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: elastos-trinity-plugins-qrscanner/node_modules/webrtc-adapter/out/adapter_no_edge_no_global.js (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&amp;&amp;require;if(!u&amp;&amp;a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&amp;&amp;require;for(var o=0;o&lt;r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){ },{}],2:[function(require,module,exports){ /* * Copyright (c) 2016 The WebRTC project authors. All Rights Reserved. * * Use of this source code is governed by a BSD-style license * that can be found in the LICENSE file in the root of the source * tree. */ /* eslint-env node */ 'use strict'; // Shimming starts here. (function() { // Utils. var utils = require('./utils'); var logging = utils.log; var browserDetails = utils.browserDetails; // Export to the adapter global object visible in the browser. module.exports.browserDetails = browserDetails; module.exports.extractVersion = utils.extractVersion; module.exports.disableLog = utils.disableLog; // Uncomment the line below if you want logging to occur, including logging // for the switch statement below. Can also be turned on in the browser via // adapter.disableLog(false), but then logging from the switch statement below // will not appear. // require('./utils').disableLog(false); // Browser shims. var chromeShim = require('./chrome/chrome_shim') || null; var edgeShim = require('./edge/edge_shim') || null; var firefoxShim = require('./firefox/firefox_shim') || null; var safariShim = require('./safari/safari_shim') || null; // Shim browser if found. switch (browserDetails.browser) { case 'chrome': if (!chromeShim || !chromeShim.shimPeerConnection) { logging('Chrome shim is not included in this adapter release.'); return; } logging('adapter.js shimming chrome.'); // Export to the adapter global object visible in the browser. module.exports.browserShim = chromeShim; chromeShim.shimGetUserMedia(); chromeShim.shimMediaStream(); utils.shimCreateObjectURL(); chromeShim.shimSourceObject(); chromeShim.shimPeerConnection(); chromeShim.shimOnTrack(); chromeShim.shimGetSendersWithDtmf(); break; case 'firefox': if (!firefoxShim || !firefoxShim.shimPeerConnection) { logging('Firefox shim is not included in this adapter release.'); return; } logging('adapter.js shimming firefox.'); // Export to the adapter global object visible in the browser. module.exports.browserShim = firefoxShim; firefoxShim.shimGetUserMedia(); utils.shimCreateObjectURL(); firefoxShim.shimSourceObject(); firefoxShim.shimPeerConnection(); firefoxShim.shimOnTrack(); break; case 'edge': if (!edgeShim || !edgeShim.shimPeerConnection) { logging('MS edge shim is not included in this adapter release.'); return; } logging('adapter.js shimming edge.'); // Export to the adapter global object visible in the browser. module.exports.browserShim = edgeShim; edgeShim.shimGetUserMedia(); utils.shimCreateObjectURL(); edgeShim.shimPeerConnection(); edgeShim.shimReplaceTrack(); break; case 'safari': if (!safariShim) { logging('Safari shim is not included in this adapter release.'); return; } logging('adapter.js shimming safari.'); // Export to the adapter global object visible in the browser. module.exports.browserShim = safariShim; safariShim.shimCallbacksAPI(); safariShim.shimAddStream(); safariShim.shimOnAddStream(); safariShim.shimGetUserMedia(); break; default: logging('Unsupported browser!'); } })(); },{\"./chrome/chrome_shim\":3,\"./edge/edge_shim\":1,\"./firefox/firefox_shim\":5,\"./safari/safari_shim\":7,\"./utils\":8}],3:[function(require,module,exports){ /* * Copyright (c) 2016 The WebRTC project authors. All Rights Reserved. * * Use of this source code is governed by a BSD-style license * that can be found in the LICENSE file in the root of the source * tree. */ /* eslint-env node */ 'use strict'; var logging = require('../utils.js').log; var browserDetails = require('../utils.js').browserDetails; var chromeShim = { shimMediaStream: function() { window.MediaStream = window.MediaStream || window.webkitMediaStream; }, shimOnTrack: function() { if (typeof window === 'object' &amp;&amp; window.RTCPeerConnection &amp;&amp; !('ontrack' in window.RTCPeerConnection.prototype)) { Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', { get: function() { return this._ontrack; }, set: function(f) { var self = this; if (this._ontrack) { this.removeEventListener('track', this._ontrack); this.removeEventListener('addstream', this._ontrackpoly); } this.addEventListener('track', this._ontrack = f); this.addEventListener('addstream', this._ontrackpoly = function(e) { // onaddstream does not fire when a track is added to an existing // stream. But stream.onaddtrack is implemented so we use that. e.stream.addEventListener('addtrack', function(te) { var receiver; if (RTCPeerConnection.prototype.getReceivers) { receiver = self.getReceivers().find(function(r) { return r.track.id === te.track.id; }); } else { receiver = {track: te.track}; } var event = new Event('track'); event.track = te.track; event.receiver = receiver; event.streams = [e.stream]; self.dispatchEvent(event); }); e.stream.getTracks().forEach(function(track) { var receiver; if (RTCPeerConnection.prototype.getReceivers) { receiver = self.getReceivers().find(function(r) { return r.track.id === track.id; }); } else { receiver = {track: track}; } var event = new Event('track'); event.track = track; event.receiver = receiver; event.streams = [e.stream]; this.dispatchEvent(event); }.bind(this)); }.bind(this)); } }); } }, shimGetSendersWithDtmf: function() { if (typeof window === 'object' &amp;&amp; window.RTCPeerConnection &amp;&amp; !('getSenders' in RTCPeerConnection.prototype) &amp;&amp; 'createDTMFSender' in RTCPeerConnection.prototype) { RTCPeerConnection.prototype.getSenders = function() { return this._senders || []; }; var origAddStream = RTCPeerConnection.prototype.addStream; var origRemoveStream = RTCPeerConnection.prototype.removeStream; if (!RTCPeerConnection.prototype.addTrack) { RTCPeerConnection.prototype.addTrack = function(track, stream) { var pc = this; if (pc.signalingState === 'closed') { throw new DOMException( 'The RTCPeerConnection\\'s signalingState is \\'closed\\'.', 'InvalidStateError'); } var streams = [].slice.call(arguments, 1); if (streams.length !== 1 || !streams[0].getTracks().find(function(t) { return t === track; })) { // this is not fully correct but all we can manage without // [[associated MediaStreams]] internal slot. throw new DOMException( 'The adapter.js addTrack polyfill only supports a single ' + ' stream which is associated with the specified track.', 'NotSupportedError'); } pc._senders = pc._senders || []; var alreadyExists = pc._senders.find(function(t) { return t.track === track; }); if (alreadyExists) { throw new DOMException('Track already exists.', 'InvalidAccessError'); } pc._streams = pc._streams || {}; var oldStream = pc._streams[stream.id]; if (oldStream) { oldStream.addTrack(track); pc.removeStream(oldStream); pc.addStream(oldStream); } else { var newStream = new MediaStream([track]); pc._streams[stream.id] = newStream; pc.addStream(newStream); } var sender = { track: track, get dtmf() { if (this._dtmf === undefined) { if (track.kind === 'audio') { this._dtmf = pc.createDTMFSender(track); } else { this._dtmf = null; } } return this._dtmf; } }; pc._senders.push(sender); return sender; }; } RTCPeerConnection.prototype.addStream = function(stream) { var pc = this; pc._senders = pc._senders || []; origAddStream.apply(pc, [stream]); stream.getTracks().forEach(function(track) { pc._senders.push({ track: track, get dtmf() { if (this._dtmf === undefined) { if (track.kind === 'audio') { this._dtmf = pc.createDTMFSender(track); } else { this._dtmf = null; } } return this._dtmf; } }); }); }; RTCPeerConnection.prototype.removeStream = function(stream) { var pc = this; pc._senders = pc._senders || []; origRemoveStream.apply(pc, [stream]); stream.getTracks().forEach(function(track) { var sender = pc._senders.find(function(s) { return s.track === track; }); if (sender) { pc._senders.splice(pc._senders.indexOf(sender), 1); // remove sender } }); }; } }, shimSourceObject: function() { if (typeof window === 'object') { if (window.HTMLMediaElement &amp;&amp; !('srcObject' in window.HTMLMediaElement.prototype)) { // Shim the srcObject property, once, when HTMLMediaElement is found. Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', { get: function() { return this._srcObject; }, set: function(stream) { var self = this; // Use _srcObject as a private property for this shim this._srcObject = stream; if (this.src) { URL.revokeObjectURL(this.src); } if (!stream) { this.src = ''; return undefined; } this.src = URL.createObjectURL(stream); // We need to recreate the blob url when a track is added or // removed. Doing it manually since we want to avoid a recursion. stream.addEventListener('addtrack', function() { if (self.src) { URL.revokeObjectURL(self.src); } self.src = URL.createObjectURL(stream); }); stream.addEventListener('removetrack', function() { if (self.src) { URL.revokeObjectURL(self.src); } self.src = URL.createObjectURL(stream); }); } }); } } }, shimPeerConnection: function() { // The RTCPeerConnection object. if (!window.RTCPeerConnection) { window.RTCPeerConnection = function(pcConfig, pcConstraints) { // Translate iceTransportPolicy to iceTransports, // see https://code.google.com/p/webrtc/issues/detail?id=4869 // this was fixed in M56 along with unprefixing RTCPeerConnection. logging('PeerConnection'); if (pcConfig &amp;&amp; pcConfig.iceTransportPolicy) { pcConfig.iceTransports = pcConfig.iceTransportPolicy; } return new webkitRTCPeerConnection(pcConfig, pcConstraints); }; window.RTCPeerConnection.prototype = webkitRTCPeerConnection.prototype; // wrap static methods. Currently just generateCertificate. if (webkitRTCPeerConnection.generateCertificate) { Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', { get: function() { return webkitRTCPeerConnection.generateCertificate; } }); } } else { // migrate from non-spec RTCIceServer.url to RTCIceServer.urls var OrigPeerConnection = RTCPeerConnection; window.RTCPeerConnection = function(pcConfig, pcConstraints) { if (pcConfig &amp;&amp; pcConfig.iceServers) { var newIceServers = []; for (var i = 0; i &lt; pcConfig.iceServers.length; i++) { var server = pcConfig.iceServers[i]; if (!server.hasOwnProperty('urls') &amp;&amp; server.hasOwnProperty('url')) { console.warn('RTCIceServer.url is deprecated! Use urls instead.'); server = JSON.parse(JSON.stringify(server)); server.urls = server.url; newIceServers.push(server); } else { newIceServers.push(pcConfig.iceServers[i]); } } pcConfig.iceServers = newIceServers; } return new OrigPeerConnection(pcConfig, pcConstraints); }; window.RTCPeerConnection.prototype = OrigPeerConnection.prototype; // wrap static methods. Currently just generateCertificate. Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', { get: function() { return OrigPeerConnection.generateCertificate; } }); } var origGetStats = RTCPeerConnection.prototype.getStats; RTCPeerConnection.prototype.getStats = function(selector, successCallback, errorCallback) { var self = this; var args = arguments; // If selector is a function then we are in the old style stats so just // pass back the original getStats format to avoid breaking old users. if (arguments.length &gt; 0 &amp;&amp; typeof selector === 'function') { return origGetStats.apply(this, arguments); } // When spec-style getStats is supported, return those when called with // either no arguments or the selector argument is null. if (origGetStats.length === 0 &amp;&amp; (arguments.length === 0 || typeof arguments[0] !== 'function')) { return origGetStats.apply(this, []); } var fixChromeStats_ = function(response) { var standardReport = {}; var reports = response.result(); reports.forEach(function(report) { var standardStats = { id: report.id, timestamp: report.timestamp, type: { localcandidate: 'local-candidate', remotecandidate: 'remote-candidate' }[report.type] || report.type }; report.names().forEach(function(name) { standardStats[name] = report.stat(name); }); standardReport[standardStats.id] = standardStats; }); return standardReport; }; // shim getStats with maplike support var makeMapStats = function(stats) { return new Map(Object.keys(stats).map(function(key) { return [key, stats[key]]; })); }; if (arguments.length &gt;= 2) { var successCallbackWrapper_ = function(response) { args[1](makeMapStats(fixChromeStats_(response))); }; return origGetStats.apply(this, [successCallbackWrapper_, arguments[0]]); } // promise-support return new Promise(function(resolve, reject) { origGetStats.apply(self, [ function(response) { resolve(makeMapStats(fixChromeStats_(response))); }, reject]); }).then(successCallback, errorCallback); }; // add promise support -- natively available in Chrome 51 if (browserDetails.version &lt; 51) { ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'] .forEach(function(method) { var nativeMethod = RTCPeerConnection.prototype[method]; RTCPeerConnection.prototype[method] = function() { var args = arguments; var self = this; var promise = new Promise(function(resolve, reject) { nativeMethod.apply(self, [args[0], resolve, reject]); }); if (args.length &lt; 2) { return promise; } return promise.then(function() { args[1].apply(null, []); }, function(err) { if (args.length &gt;= 3) { args[2].apply(null, [err]); } }); }; }); } // promise support for createOffer and createAnswer. Available (without // bugs) since M52: crbug/619289 if (browserDetails.version &lt; 52) { ['createOffer', 'createAnswer'].forEach(function(method) { var nativeMethod = RTCPeerConnection.prototype[method]; RTCPeerConnection.prototype[method] = function() { var self = this; if (arguments.length &lt; 1 || (arguments.length === 1 &amp;&amp; typeof arguments[0] === 'object')) { var opts = arguments.length === 1 ? arguments[0] : undefined; return new Promise(function(resolve, reject) { nativeMethod.apply(self, [resolve, reject, opts]); }); } return nativeMethod.apply(this, arguments); }; }); } // shim implicit creation of RTCSessionDescription/RTCIceCandidate ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'] .forEach(function(method) { var nativeMethod = RTCPeerConnection.prototype[method]; RTCPeerConnection.prototype[method] = function() { arguments[0] = new ((method === 'addIceCandidate') ? RTCIceCandidate : RTCSessionDescription)(arguments[0]); return nativeMethod.apply(this, arguments); }; }); // support for addIceCandidate(null or undefined) var nativeAddIceCandidate = RTCPeerConnection.prototype.addIceCandidate; RTCPeerConnection.prototype.addIceCandidate = function() { if (!arguments[0]) { if (arguments[1]) { arguments[1].apply(null); } return Promise.resolve(); } return nativeAddIceCandidate.apply(this, arguments); }; } }; // Expose public methods. module.exports = { shimMediaStream: chromeShim.shimMediaStream, shimOnTrack: chromeShim.shimOnTrack, shimGetSendersWithDtmf: chromeShim.shimGetSendersWithDtmf, shimSourceObject: chromeShim.shimSourceObject, shimPeerConnection: chromeShim.shimPeerConnection, shimGetUserMedia: require('./getusermedia') }; },{\"../utils.js\":8,\"./getusermedia\":4}],4:[function(require,module,exports){ /* * Copyright (c) 2016 The WebRTC project authors. All Rights Reserved. * * Use of this source code is governed by a BSD-style license * that can be found in the LICENSE file in the root of the source * tree. */ /* eslint-env node */ 'use strict'; var logging = require('../utils.js').log; var browserDetails = require('../utils.js').browserDetails; // Expose public methods. module.exports = function() { var constraintsToChrome_ = function(c) { if (typeof c !== 'object' || c.mandatory || c.optional) { return c; } var cc = {}; Object.keys(c).forEach(function(key) { if (key === 'require' || key === 'advanced' || key === 'mediaSource') { return; } var r = (typeof c[key] === 'object') ? c[key] : {ideal: c[key]}; if (r.exact !== undefined &amp;&amp; typeof r.exact === 'number') { r.min = r.max = r.exact; } var oldname_ = function(prefix, name) { if (prefix) { return prefix + name.charAt(0).toUpperCase() + name.slice(1); } return (name === 'deviceId') ? 'sourceId' : name; }; if (r.ideal !== undefined) { cc.optional = cc.optional || []; var oc = {}; if (typeof r.ideal === 'number') { oc[oldname_('min', key)] = r.ideal; cc.optional.push(oc); oc = {}; oc[oldname_('max', key)] = r.ideal; cc.optional.push(oc); } else { oc[oldname_('', key)] = r.ideal; cc.optional.push(oc); } } if (r.exact !== undefined &amp;&amp; typeof r.exact !== 'number') { cc.mandatory = cc.mandatory || {}; cc.mandatory[oldname_('', key)] = r.exact; } else { ['min', 'max'].forEach(function(mix) { if (r[mix] !== undefined) { cc.mandatory = cc.mandatory || {}; cc.mandatory[oldname_(mix, key)] = r[mix]; } }); } }); if (c.advanced) { cc.optional = (cc.optional || []).concat(c.advanced); } return cc; }; var shimConstraints_ = function(constraints, func) { constraints = JSON.parse(JSON.stringify(constraints)); if (constraints &amp;&amp; constraints.audio) { constraints.audio = constraintsToChrome_(constraints.audio); } if (constraints &amp;&amp; typeof constraints.video === 'object') { // Shim facingMode for mobile &amp; surface pro. var face = constraints.video.facingMode; face = face &amp;&amp; ((typeof face === 'object') ? face : {ideal: face}); var getSupportedFacingModeLies = browserDetails.version &lt; 61; if ((face &amp;&amp; (face.exact === 'user' || face.exact === 'environment' || face.ideal === 'user' || face.ideal === 'environment')) &amp;&amp; !(navigator.mediaDevices.getSupportedConstraints &amp;&amp; navigator.mediaDevices.getSupportedConstraints().facingMode &amp;&amp; !getSupportedFacingModeLies)) { delete constraints.video.facingMode; var matches; if (face.exact === 'environment' || face.ideal === 'environment') { matches = ['back', 'rear']; } else if (face.exact === 'user' || face.ideal === 'user') { matches = ['front']; } if (matches) { // Look for matches in label, or use last cam for back (typical). return navigator.mediaDevices.enumerateDevices() .then(function(devices) { devices = devices.filter(function(d) { return d.kind === 'videoinput'; }); var dev = devices.find(function(d) { return matches.some(function(match) { return d.label.toLowerCase().indexOf(match) !== -1; }); }); if (!dev &amp;&amp; devices.length &amp;&amp; matches.indexOf('back') !== -1) { dev = devices[devices.length - 1]; // more likely the back cam } if (dev) { constraints.video.deviceId = face.exact ? {exact: dev.deviceId} : {ideal: dev.deviceId}; } constraints.video = constraintsToChrome_(constraints.video); logging('chrome: ' + JSON.stringify(constraints)); return func(constraints); }); } } constraints.video = constraintsToChrome_(constraints.video); } logging('chrome: ' + JSON.stringify(constraints)); return func(constraints); }; var shimError_ = function(e) { return { name: { ConstraintNotSatisfiedError: 'OverconstrainedError', PermissionDeniedError: 'NotAllowedError', TrackStartError: 'NotReadableError' }[e.name] || e.name, message: e.message, constraint: e.constraintName, toString: function() { return this.name + (this.message &amp;&amp; ': ') + this.message; } }; }; var getUserMedia_ = function(constraints, onSuccess, onError) { shimConstraints_(constraints, function(c) { navigator.webkitGetUserMedia(c, onSuccess, function(e) { onError(shimError_(e)); }); }); }; navigator.getUserMedia = getUserMedia_; // Returns the result of getUserMedia as a Promise. var getUserMediaPromise_ = function(constraints) { return new Promise(function(resolve, reject) { navigator.getUserMedia(constraints, resolve, reject); }); }; if (!navigator.mediaDevices) { navigator.mediaDevices = { getUserMedia: getUserMediaPromise_, enumerateDevices: function() { return new Promise(function(resolve) { var kinds = {audio: 'audioinput', video: 'videoinput'}; return MediaStreamTrack.getSources(function(devices) { resolve(devices.map(function(device) { return {label: device.label, kind: kinds[device.kind], deviceId: device.id, groupId: ''}; })); }); }); }, getSupportedConstraints: function() { return { deviceId: true, echoCancellation: true, facingMode: true, frameRate: true, height: true, width: true }; } }; } // A shim for getUserMedia method on the mediaDevices object. // TODO(KaptenJansson) remove once implemented in Chrome stable. if (!navigator.mediaDevices.getUserMedia) { navigator.mediaDevices.getUserMedia = function(constraints) { return getUserMediaPromise_(constraints); }; } else { // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia // function which returns a Promise, it does not accept spec-style // constraints. var origGetUserMedia = navigator.mediaDevices.getUserMedia. bind(navigator.mediaDevices); navigator.mediaDevices.getUserMedia = function(cs) { return shimConstraints_(cs, function(c) { return origGetUserMedia(c).then(function(stream) { if (c.audio &amp;&amp; !stream.getAudioTracks().length || c.video &amp;&amp; !stream.getVideoTracks().length) { stream.getTracks().forEach(function(track) { track.stop(); }); throw new DOMException('', 'NotFoundError'); } return stream; }, function(e) { return Promise.reject(shimError_(e)); }); }); }; } // Dummy devicechange event methods. // TODO(KaptenJansson) remove once implemented in Chrome stable. if (typeof navigator.mediaDevices.addEventListener === 'undefined') { navigator.mediaDevices.addEventListener = function() { logging('Dummy mediaDevices.addEventListener called.'); }; } if (typeof navigator.mediaDevices.removeEventListener === 'undefined') { navigator.mediaDevices.removeEventListener = function() { logging('Dummy mediaDevices.removeEventListener called.'); }; } }; },{\"../utils.js\":8}],5:[function(require,module,exports){ /* * Copyright (c) 2016 The WebRTC project authors. All Rights Reserved. * * Use of this source code is governed by a BSD-style license * that can be found in the LICENSE file in the root of the source * tree. */ /* eslint-env node */ 'use strict'; var browserDetails = require('../utils').browserDetails; var firefoxShim = { shimOnTrack: function() { if (typeof window === 'object' &amp;&amp; window.RTCPeerConnection &amp;&amp; !('ontrack' in window.RTCPeerConnection.prototype)) { Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', { get: function() { return this._ontrack; }, set: function(f) { if (this._ontrack) { this.removeEventListener('track', this._ontrack); this.removeEventListener('addstream', this._ontrackpoly); } this.addEventListener('track', this._ontrack = f); this.addEventListener('addstream', this._ontrackpoly = function(e) { e.stream.getTracks().forEach(function(track) { var event = new Event('track'); event.track = track; event.receiver = {track: track}; event.streams = [e.stream]; this.dispatchEvent(event); }.bind(this)); }.bind(this)); } }); } }, shimSourceObject: function() { // Firefox has supported mozSrcObject since FF22, unprefixed in 42. if (typeof window === 'object') { if (window.HTMLMediaElement &amp;&amp; !('srcObject' in window.HTMLMediaElement.prototype)) { // Shim the srcObject property, once, when HTMLMediaElement is found. Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', { get: function() { return this.mozSrcObject; }, set: function(stream) { this.mozSrcObject = stream; } }); } } }, shimPeerConnection: function() { if (typeof window !== 'object' || !(window.RTCPeerConnection || window.mozRTCPeerConnection)) { return; // probably media.peerconnection.enabled=false in about:config } // The RTCPeerConnection object. if (!window.RTCPeerConnection) { window.RTCPeerConnection = function(pcConfig, pcConstraints) { if (browserDetails.version &lt; 38) { // .urls is not supported in FF &lt; 38. // create RTCIceServers with a single url. if (pcConfig &amp;&amp; pcConfig.iceServers) { var newIceServers = []; for (var i = 0; i &lt; pcConfig.iceServers.length; i++) { var server = pcConfig.iceServers[i]; if (server.hasOwnProperty('urls')) { for (var j = 0; j &lt; server.urls.length; j++) { var newServer = { url: server.urls[j] }; if (server.urls[j].indexOf('turn') === 0) { newServer.username = server.username; newServer.credential = server.credential; } newIceServers.push(newServer); } } else { newIceServers.push(pcConfig.iceServers[i]); } } pcConfig.iceServers = newIceServers; } } return new mozRTCPeerConnection(pcConfig, pcConstraints); }; window.RTCPeerConnection.prototype = mozRTCPeerConnection.prototype; // wrap static methods. Currently just generateCertificate. if (mozRTCPeerConnection.generateCertificate) { Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', { get: function() { return mozRTCPeerConnection.generateCertificate; } }); } window.RTCSessionDescription = mozRTCSessionDescription; window.RTCIceCandidate = mozRTCIceCandidate; } // shim away need for obsolete RTCIceCandidate/RTCSessionDescription. ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'] .forEach(function(method) { var nativeMethod = RTCPeerConnection.prototype[method]; RTCPeerConnection.prototype[method] = function() { arguments[0] = new ((method === 'addIceCandidate') ? RTCIceCandidate : RTCSessionDescription)(arguments[0]); return nativeMethod.apply(this, arguments); }; }); // support for addIceCandidate(null or undefined) var nativeAddIceCandidate = RTCPeerConnection.prototype.addIceCandidate; RTCPeerConnection.prototype.addIceCandidate = function() { if (!arguments[0]) { if (arguments[1]) { arguments[1].apply(null); } return Promise.resolve(); } return nativeAddIceCandidate.apply(this, arguments); }; // shim getStats with maplike support var makeMapStats = function(stats) { var map = new Map(); Object.keys(stats).forEach(function(key) { map.set(key, stats[key]); map[key] = stats[key]; }); return map; }; var modernStatsTypes = { inboundrtp: 'inbound-rtp', outboundrtp: 'outbound-rtp', candidatepair: 'candidate-pair', localcandidate: 'local-candidate', remotecandidate: 'remote-candidate' }; var nativeGetStats = RTCPeerConnection.prototype.getStats; RTCPeerConnection.prototype.getStats = function(selector, onSucc, onErr) { return nativeGetStats.apply(this, [selector || null]) .then(function(stats) { if (browserDetails.version &lt; 48) { stats = makeMapStats(stats); } if (browserDetails.version &lt; 53 &amp;&amp; !onSucc) { // Shim only promise getStats with spec-hyphens in type names // Leave callback version alone; misc old uses of forEach before Map try { stats.forEach(function(stat) { stat.type = modernStatsTypes[stat.type] || stat.type; }); } catch (e) { if (e.name !== 'TypeError') { throw e; } // Avoid TypeError: \"type\" is read-only, in old versions. 34-43ish stats.forEach(function(stat, i) { stats.set(i, Object.assign({}, stat, { type: modernStatsTypes[stat.type] || stat.type })); }); } } return stats; }) .then(onSucc, onErr); }; } }; // Expose public methods. module.exports = { shimOnTrack: firefoxShim.shimOnTrack, shimSourceObject: firefoxShim.shimSourceObject, shimPeerConnection: firefoxShim.shimPeerConnection, shimGetUserMedia: require('./getusermedia') }; },{\"../utils\":8,\"./getusermedia\":6}],6:[function(require,module,exports){ /* * Copyright (c) 2016 The WebRTC project authors. All Rights Reserved. * * Use of this source code is governed by a BSD-style license * that can be found in the LICENSE file in the root of the source * tree. */ /* eslint-env node */ 'use strict'; var logging = require('../utils').log; var browserDetails = require('../utils').browserDetails; // Expose public methods. module.exports = function() { var shimError_ = function(e) { return { name: { InternalError: 'NotReadableError', NotSupportedError: 'TypeError', PermissionDeniedError: 'NotAllowedError', SecurityError: 'NotAllowedError' }[e.name] || e.name, message: { 'The operation is insecure.': 'The request is not allowed by the ' + 'user agent or the platform in the current context.' }[e.message] || e.message, constraint: e.constraint, toString: function() { return this.name + (this.message &amp;&amp; ': ') + this.message; } }; }; // getUserMedia constraints shim. var getUserMedia_ = function(constraints, onSuccess, onError) { var constraintsToFF37_ = function(c) { if (typeof c !== 'object' || c.require) { return c; } var require = []; Object.keys(c).forEach(function(key) { if (key === 'require' || key === 'advanced' || key === 'mediaSource') { return; } var r = c[key] = (typeof c[key] === 'object') ? c[key] : {ideal: c[key]}; if (r.min !== undefined || r.max !== undefined || r.exact !== undefined) { require.push(key); } if (r.exact !== undefined) { if (typeof r.exact === 'number') { r. min = r.max = r.exact; } else { c[key] = r.exact; } delete r.exact; } if (r.ideal !== undefined) { c.advanced = c.advanced || []; var oc = {}; if (typeof r.ideal === 'number') { oc[key] = {min: r.ideal, max: r.ideal}; } else { oc[key] = r.ideal; } c.advanced.push(oc); delete r.ideal; if (!Object.keys(r).length) { delete c[key]; } } }); if (require.length) { c.require = require; } return c; }; constraints = JSON.parse(JSON.stringify(constraints)); if (browserDetails.version &lt; 38) { logging('spec: ' + JSON.stringify(constraints)); if (constraints.audio) { constraints.audio = constraintsToFF37_(constraints.audio); } if (constraints.video) { constraints.video = constraintsToFF37_(constraints.video); } logging('ff37: ' + JSON.stringify(constraints)); } return navigator.mozGetUserMedia(constraints, onSuccess, function(e) { onError(shimError_(e)); }); }; // Returns the result of getUserMedia as a Promise. var getUserMediaPromise_ = function(constraints) { return new Promise(function(resolve, reject) { getUserMedia_(constraints, resolve, reject); }); }; // Shim for mediaDevices on older versions. if (!navigator.mediaDevices) { navigator.mediaDevices = {getUserMedia: getUserMediaPromise_, addEventListener: function() { }, removeEventListener: function() { } }; } navigator.mediaDevices.enumerateDevices = navigator.mediaDevices.enumerateDevices || function() { return new Promise(function(resolve) { var infos = [ {kind: 'audioinput', deviceId: 'default', label: '', groupId: ''}, {kind: 'videoinput', deviceId: 'default', label: '', groupId: ''} ]; resolve(infos); }); }; if (browserDetails.version &lt; 41) { // Work around http://bugzil.la/1169665 var orgEnumerateDevices = navigator.mediaDevices.enumerateDevices.bind(navigator.mediaDevices); navigator.mediaDevices.enumerateDevices = function() { return orgEnumerateDevices().then(undefined, function(e) { if (e.name === 'NotFoundError') { return []; } throw e; }); }; } if (browserDetails.version &lt; 49) { var origGetUserMedia = navigator.mediaDevices.getUserMedia. bind(navigator.mediaDevices); navigator.mediaDevices.getUserMedia = function(c) { return origGetUserMedia(c).then(function(stream) { // Work around https://bugzil.la/802326 if (c.audio &amp;&amp; !stream.getAudioTracks().length || c.video &amp;&amp; !stream.getVideoTracks().length) { stream.getTracks().forEach(function(track) { track.stop(); }); throw new DOMException('The object can not be found here.', 'NotFoundError'); } return stream; }, function(e) { return Promise.reject(shimError_(e)); }); }; } navigator.getUserMedia = function(constraints, onSuccess, onError) { if (browserDetails.version &lt; 44) { return getUserMedia_(constraints, onSuccess, onError); } // Replace Firefox 44+'s deprecation warning with unprefixed version. console.warn('navigator.getUserMedia has been replaced by ' + 'navigator.mediaDevices.getUserMedia'); navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError); }; }; },{\"../utils\":8}],7:[function(require,module,exports){ /* * Copyright (c) 2016 The WebRTC project authors. All Rights Reserved. * * Use of this source code is governed by a BSD-style license * that can be found in the LICENSE file in the root of the source * tree. */ 'use strict'; var safariShim = { // TODO: DrAlex, should be here, double check against LayoutTests // TODO: once the back-end for the mac port is done, add. // TODO: check for webkitGTK+ // shimPeerConnection: function() { }, shimAddStream: function() { if (typeof window === 'object' &amp;&amp; window.RTCPeerConnection &amp;&amp; !('addStream' in window.RTCPeerConnection.prototype)) { RTCPeerConnection.prototype.addStream = function(stream) { var self = this; stream.getTracks().forEach(function(track) { self.addTrack(track, stream); }); }; } }, shimOnAddStream: function() { if (typeof window === 'object' &amp;&amp; window.RTCPeerConnection &amp;&amp; !('onaddstream' in window.RTCPeerConnection.prototype)) { Object.defineProperty(window.RTCPeerConnection.prototype, 'onaddstream', { get: function() { return this._onaddstream; }, set: function(f) { if (this._onaddstream) { this.removeEventListener('addstream', this._onaddstream); this.removeEventListener('track', this._onaddstreampoly); } this.addEventListener('addstream', this._onaddstream = f); this.addEventListener('track', this._onaddstreampoly = function(e) { var stream = e.streams[0]; if (!this._streams) { this._streams = []; } if (this._streams.indexOf(stream) &gt;= 0) { return; } this._streams.push(stream); var event = new Event('addstream'); event.stream = e.streams[0]; this.dispatchEvent(event); }.bind(this)); } }); } }, shimCallbacksAPI: function() { if (typeof window !== 'object' || !window.RTCPeerConnection) { return; } var prototype = RTCPeerConnection.prototype; var createOffer = prototype.createOffer; var createAnswer = prototype.createAnswer; var setLocalDescription = prototype.setLocalDescription; var setRemoteDescription = prototype.setRemoteDescription; var addIceCandidate = prototype.addIceCandidate; prototype.createOffer = function(successCallback, failureCallback) { var options = (arguments.length &gt;= 2) ? arguments[2] : arguments[0]; var promise = createOffer.apply(this, [options]); if (!failureCallback) { return promise; } promise.then(successCallback, failureCallback); return Promise.resolve(); }; prototype.createAnswer = function(successCallback, failureCallback) { var options = (arguments.length &gt;= 2) ? arguments[2] : arguments[0]; var promise = createAnswer.apply(this, [options]); if (!failureCallback) { return promise; } promise.then(successCallback, failureCallback); return Promise.resolve(); }; var withCallback = function(description, successCallback, failureCallback) { var promise = setLocalDescription.apply(this, [description]); if (!failureCallback) { return promise; } promise.then(successCallback, failureCallback); return Promise.resolve(); }; prototype.setLocalDescription = withCallback; withCallback = function(description, successCallback, failureCallback) { var promise = setRemoteDescription.apply(this, [description]); if (!failureCallback) { return promise; } promise.then(successCallback, failureCallback); return Promise.resolve(); }; prototype.setRemoteDescription = withCallback; withCallback = function(candidate, successCallback, failureCallback) { var promise = addIceCandidate.apply(this, [candidate]); if (!failureCallback) { return promise; } promise.then(successCallback, failureCallback); return Promise.resolve(); }; prototype.addIceCandidate = withCallback; }, shimGetUserMedia: function() { if (!navigator.getUserMedia) { if (navigator.webkitGetUserMedia) { navigator.getUserMedia = navigator.webkitGetUserMedia.bind(navigator); } else if (navigator.mediaDevices &amp;&amp; navigator.mediaDevices.getUserMedia) { navigator.getUserMedia = function(constraints, cb, errcb) { navigator.mediaDevices.getUserMedia(constraints) .then(cb, errcb); }.bind(navigator); } } } }; // Expose public methods. module.exports = { shimCallbacksAPI: safariShim.shimCallbacksAPI, shimAddStream: safariShim.shimAddStream, shimOnAddStream: safariShim.shimOnAddStream, shimGetUserMedia: safariShim.shimGetUserMedia // TODO // shimPeerConnection: safariShim.shimPeerConnection }; },{}],8:[function(require,module,exports){ /* * Copyright (c) 2016 The WebRTC project authors. All Rights Reserved. * * Use of this source code is governed by a BSD-style license * that can be found in the LICENSE file in the root of the source * tree. */ /* eslint-env node */ 'use strict'; var logDisabled_ = true; // Utility methods. var utils = { disableLog: function(bool) { if (typeof bool !== 'boolean') { return new Error('Argument type: ' + typeof bool + '. Please use a boolean.'); } logDisabled_ = bool; return (bool) ? 'adapter.js logging disabled' : 'adapter.js logging enabled'; }, log: function() { if (typeof window === 'object') { if (logDisabled_) { return; } if (typeof console !== 'undefined' &amp;&amp; typeof console.log === 'function') { console.log.apply(console, arguments); } } }, /** * Extract browser version out of the provided user agent string. * * @param {!string} uastring userAgent string. * @param {!string} expr Regular expression used as match criteria. * @param {!number} pos position in the version string to be returned. * @return {!number} browser version. */ extractVersion: function(uastring, expr, pos) { var match = uastring.match(expr); return match &amp;&amp; match.length &gt;= pos &amp;&amp; parseInt(match[pos], 10); }, /** * Browser detector. * * @return {object} result containing browser and version * properties. */ detectBrowser: function() { // Returned result object. var result = {}; result.browser = null; result.version = null; // Fail early if it's not a browser if (typeof window === 'undefined' || !window.navigator) { result.browser = 'Not a browser.'; return result; } // Firefox. if (navigator.mozGetUserMedia) { result.browser = 'firefox'; result.version = this.extractVersion(navigator.userAgent, /Firefox\\/(\\d+)\\./, 1); } else if (navigator.webkitGetUserMedia) { // Chrome, Chromium, Webview, Opera, all use the chrome shim for now if (window.webkitRTCPeerConnection) { result.browser = 'chrome'; result.version = this.extractVersion(navigator.userAgent, /Chrom(e|ium)\\/(\\d+)\\./, 2); } else { // Safari (in an unpublished version) or unknown webkit-based. if (navigator.userAgent.match(/Version\\/(\\d+).(\\d+)/)) { result.browser = 'safari'; result.version = this.extractVersion(navigator.userAgent, /AppleWebKit\\/(\\d+)\\./, 1); } else { // unknown webkit-based browser. result.browser = 'Unsupported webkit-based browser ' + 'with GUM support but no WebRTC support.'; return result; } } } else if (navigator.mediaDevices &amp;&amp; navigator.userAgent.match(/Edge\\/(\\d+).(\\d+)$/)) { // Edge. result.browser = 'edge'; result.version = this.extractVersion(navigator.userAgent, /Edge\\/(\\d+).(\\d+)$/, 2); } else if (navigator.mediaDevices &amp;&amp; navigator.userAgent.match(/AppleWebKit\\/(\\d+)\\./)) { // Safari, with webkitGetUserMedia removed. result.browser = 'safari'; result.version = this.extractVersion(navigator.userAgent, /AppleWebKit\\/(\\d+)\\./, 1); } else { // Default fallthrough: not supported. result.browser = 'Not a supported browser.'; return result; } return result; }, // shimCreateObjectURL must be called before shimSourceObject to avoid loop. shimCreateObjectURL: function() { if (!(typeof window === 'object' &amp;&amp; window.HTMLMediaElement &amp;&amp; 'srcObject' in window.HTMLMediaElement.prototype)) { // Only shim CreateObjectURL using srcObject if srcObject exists. return undefined; } var nativeCreateObjectURL = URL.createObjectURL.bind(URL); var nativeRevokeObjectURL = URL.revokeObjectURL.bind(URL); var streams = new Map(), newId = 0; URL.createObjectURL = function(stream) { if ('getTracks' in stream) { var url = 'polyblob:' + (++newId); streams.set(url, stream); console.log('URL.createObjectURL(stream) is deprecated! ' + 'Use elem.srcObject = stream instead!'); return url; } return nativeCreateObjectURL(stream); }; URL.revokeObjectURL = function(url) { nativeRevokeObjectURL(url); streams.delete(url); }; var dsc = Object.getOwnPropertyDescriptor(window.HTMLMediaElement.prototype, 'src'); Object.defineProperty(window.HTMLMediaElement.prototype, 'src', { get: function() { return dsc.get.apply(this); }, set: function(url) { this.srcObject = streams.get(url) || null; return dsc.set.apply(this, [url]); } }); var nativeSetAttribute = HTMLMediaElement.prototype.setAttribute; HTMLMediaElement.prototype.setAttribute = function() { if (arguments.length === 2 &amp;&amp; ('' + arguments[0]).toLowerCase() === 'src') { this.srcObject = streams.get(arguments[1]) || null; } return nativeSetAttribute.apply(this, arguments); }; } }; // Export. module.exports = { log: utils.log, disableLog: utils.disableLog, browserDetails: utils.detectBrowser(), extractVersion: utils.extractVersion, shimCreateObjectURL: utils.shimCreateObjectURL, detectBrowser: utils.detectBrowser.bind(utils) }; },{}]},{},[2]); × Search results Close "},"elastos-trinity-plugins-qrscanner_node_modules_webrtc-adapter_out_adapter_no_global.js.html":{"id":"elastos-trinity-plugins-qrscanner_node_modules_webrtc-adapter_out_adapter_no_global.js.html","title":"Source: elastos-trinity-plugins-qrscanner/node_modules/webrtc-adapter/out/adapter_no_global.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: elastos-trinity-plugins-qrscanner/node_modules/webrtc-adapter/out/adapter_no_global.js (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&amp;&amp;require;if(!u&amp;&amp;a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&amp;&amp;require;for(var o=0;o&lt;r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){ /* eslint-env node */ 'use strict'; // SDP helpers. var SDPUtils = {}; // Generate an alphanumeric identifier for cname or mids. // TODO: use UUIDs instead? https://gist.github.com/jed/982883 SDPUtils.generateIdentifier = function() { return Math.random().toString(36).substr(2, 10); }; // The RTCP CNAME used by all peerconnections from the same JS. SDPUtils.localCName = SDPUtils.generateIdentifier(); // Splits SDP into lines, dealing with both CRLF and LF. SDPUtils.splitLines = function(blob) { return blob.trim().split('\\n').map(function(line) { return line.trim(); }); }; // Splits SDP into sessionpart and mediasections. Ensures CRLF. SDPUtils.splitSections = function(blob) { var parts = blob.split('\\nm='); return parts.map(function(part, index) { return (index &gt; 0 ? 'm=' + part : part).trim() + '\\r\\n'; }); }; // Returns lines that start with a certain prefix. SDPUtils.matchPrefix = function(blob, prefix) { return SDPUtils.splitLines(blob).filter(function(line) { return line.indexOf(prefix) === 0; }); }; // Parses an ICE candidate line. Sample input: // candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8 // rport 55996\" SDPUtils.parseCandidate = function(line) { var parts; // Parse both variants. if (line.indexOf('a=candidate:') === 0) { parts = line.substring(12).split(' '); } else { parts = line.substring(10).split(' '); } var candidate = { foundation: parts[0], component: parseInt(parts[1], 10), protocol: parts[2].toLowerCase(), priority: parseInt(parts[3], 10), ip: parts[4], port: parseInt(parts[5], 10), // skip parts[6] == 'typ' type: parts[7] }; for (var i = 8; i &lt; parts.length; i += 2) { switch (parts[i]) { case 'raddr': candidate.relatedAddress = parts[i + 1]; break; case 'rport': candidate.relatedPort = parseInt(parts[i + 1], 10); break; case 'tcptype': candidate.tcpType = parts[i + 1]; break; default: // extension handling, in particular ufrag candidate[parts[i]] = parts[i + 1]; break; } } return candidate; }; // Translates a candidate object into SDP candidate attribute. SDPUtils.writeCandidate = function(candidate) { var sdp = []; sdp.push(candidate.foundation); sdp.push(candidate.component); sdp.push(candidate.protocol.toUpperCase()); sdp.push(candidate.priority); sdp.push(candidate.ip); sdp.push(candidate.port); var type = candidate.type; sdp.push('typ'); sdp.push(type); if (type !== 'host' &amp;&amp; candidate.relatedAddress &amp;&amp; candidate.relatedPort) { sdp.push('raddr'); sdp.push(candidate.relatedAddress); // was: relAddr sdp.push('rport'); sdp.push(candidate.relatedPort); // was: relPort } if (candidate.tcpType &amp;&amp; candidate.protocol.toLowerCase() === 'tcp') { sdp.push('tcptype'); sdp.push(candidate.tcpType); } return 'candidate:' + sdp.join(' '); }; // Parses an ice-options line, returns an array of option tags. // a=ice-options:foo bar SDPUtils.parseIceOptions = function(line) { return line.substr(14).split(' '); } // Parses an rtpmap line, returns RTCRtpCoddecParameters. Sample input: // a=rtpmap:111 opus/48000/2 SDPUtils.parseRtpMap = function(line) { var parts = line.substr(9).split(' '); var parsed = { payloadType: parseInt(parts.shift(), 10) // was: id }; parts = parts[0].split('/'); parsed.name = parts[0]; parsed.clockRate = parseInt(parts[1], 10); // was: clockrate // was: channels parsed.numChannels = parts.length === 3 ? parseInt(parts[2], 10) : 1; return parsed; }; // Generate an a=rtpmap line from RTCRtpCodecCapability or // RTCRtpCodecParameters. SDPUtils.writeRtpMap = function(codec) { var pt = codec.payloadType; if (codec.preferredPayloadType !== undefined) { pt = codec.preferredPayloadType; } return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate + (codec.numChannels !== 1 ? '/' + codec.numChannels : '') + '\\r\\n'; }; // Parses an a=extmap line (headerextension from RFC 5285). Sample input: // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset // a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset SDPUtils.parseExtmap = function(line) { var parts = line.substr(9).split(' '); return { id: parseInt(parts[0], 10), direction: parts[0].indexOf('/') &gt; 0 ? parts[0].split('/')[1] : 'sendrecv', uri: parts[1] }; }; // Generates a=extmap line from RTCRtpHeaderExtensionParameters or // RTCRtpHeaderExtension. SDPUtils.writeExtmap = function(headerExtension) { return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) + (headerExtension.direction &amp;&amp; headerExtension.direction !== 'sendrecv' ? '/' + headerExtension.direction : '') + ' ' + headerExtension.uri + '\\r\\n'; }; // Parses an ftmp line, returns dictionary. Sample input: // a=fmtp:96 vbr=on;cng=on // Also deals with vbr=on; cng=on SDPUtils.parseFmtp = function(line) { var parsed = {}; var kv; var parts = line.substr(line.indexOf(' ') + 1).split(';'); for (var j = 0; j &lt; parts.length; j++) { kv = parts[j].trim().split('='); parsed[kv[0].trim()] = kv[1]; } return parsed; }; // Generates an a=ftmp line from RTCRtpCodecCapability or RTCRtpCodecParameters. SDPUtils.writeFmtp = function(codec) { var line = ''; var pt = codec.payloadType; if (codec.preferredPayloadType !== undefined) { pt = codec.preferredPayloadType; } if (codec.parameters &amp;&amp; Object.keys(codec.parameters).length) { var params = []; Object.keys(codec.parameters).forEach(function(param) { params.push(param + '=' + codec.parameters[param]); }); line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\\r\\n'; } return line; }; // Parses an rtcp-fb line, returns RTCPRtcpFeedback object. Sample input: // a=rtcp-fb:98 nack rpsi SDPUtils.parseRtcpFb = function(line) { var parts = line.substr(line.indexOf(' ') + 1).split(' '); return { type: parts.shift(), parameter: parts.join(' ') }; }; // Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters. SDPUtils.writeRtcpFb = function(codec) { var lines = ''; var pt = codec.payloadType; if (codec.preferredPayloadType !== undefined) { pt = codec.preferredPayloadType; } if (codec.rtcpFeedback &amp;&amp; codec.rtcpFeedback.length) { // FIXME: special handling for trr-int? codec.rtcpFeedback.forEach(function(fb) { lines += 'a=rtcp-fb:' + pt + ' ' + fb.type + (fb.parameter &amp;&amp; fb.parameter.length ? ' ' + fb.parameter : '') + '\\r\\n'; }); } return lines; }; // Parses an RFC 5576 ssrc media attribute. Sample input: // a=ssrc:3735928559 cname:something SDPUtils.parseSsrcMedia = function(line) { var sp = line.indexOf(' '); var parts = { ssrc: parseInt(line.substr(7, sp - 7), 10) }; var colon = line.indexOf(':', sp); if (colon &gt; -1) { parts.attribute = line.substr(sp + 1, colon - sp - 1); parts.value = line.substr(colon + 1); } else { parts.attribute = line.substr(sp + 1); } return parts; }; // Extracts the MID (RFC 5888) from a media section. // returns the MID or undefined if no mid line was found. SDPUtils.getMid = function(mediaSection) { var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0]; if (mid) { return mid.substr(6); } } SDPUtils.parseFingerprint = function(line) { var parts = line.substr(14).split(' '); return { algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge. value: parts[1] }; }; // Extracts DTLS parameters from SDP media section or sessionpart. // FIXME: for consistency with other functions this should only // get the fingerprint line as input. See also getIceParameters. SDPUtils.getDtlsParameters = function(mediaSection, sessionpart) { var lines = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=fingerprint:'); // Note: a=setup line is ignored since we use the 'auto' role. // Note2: 'algorithm' is not case sensitive except in Edge. return { role: 'auto', fingerprints: lines.map(SDPUtils.parseFingerprint) }; }; // Serializes DTLS parameters to SDP. SDPUtils.writeDtlsParameters = function(params, setupType) { var sdp = 'a=setup:' + setupType + '\\r\\n'; params.fingerprints.forEach(function(fp) { sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\\r\\n'; }); return sdp; }; // Parses ICE information from SDP media section or sessionpart. // FIXME: for consistency with other functions this should only // get the ice-ufrag and ice-pwd lines as input. SDPUtils.getIceParameters = function(mediaSection, sessionpart) { var lines = SDPUtils.splitLines(mediaSection); // Search in session part, too. lines = lines.concat(SDPUtils.splitLines(sessionpart)); var iceParameters = { usernameFragment: lines.filter(function(line) { return line.indexOf('a=ice-ufrag:') === 0; })[0].substr(12), password: lines.filter(function(line) { return line.indexOf('a=ice-pwd:') === 0; })[0].substr(10) }; return iceParameters; }; // Serializes ICE parameters to SDP. SDPUtils.writeIceParameters = function(params) { return 'a=ice-ufrag:' + params.usernameFragment + '\\r\\n' + 'a=ice-pwd:' + params.password + '\\r\\n'; }; // Parses the SDP media section and returns RTCRtpParameters. SDPUtils.parseRtpParameters = function(mediaSection) { var description = { codecs: [], headerExtensions: [], fecMechanisms: [], rtcp: [] }; var lines = SDPUtils.splitLines(mediaSection); var mline = lines[0].split(' '); for (var i = 3; i &lt; mline.length; i++) { // find all codecs from mline[3..] var pt = mline[i]; var rtpmapline = SDPUtils.matchPrefix( mediaSection, 'a=rtpmap:' + pt + ' ')[0]; if (rtpmapline) { var codec = SDPUtils.parseRtpMap(rtpmapline); var fmtps = SDPUtils.matchPrefix( mediaSection, 'a=fmtp:' + pt + ' '); // Only the first a=fmtp:&lt;pt&gt; is considered. codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {}; codec.rtcpFeedback = SDPUtils.matchPrefix( mediaSection, 'a=rtcp-fb:' + pt + ' ') .map(SDPUtils.parseRtcpFb); description.codecs.push(codec); // parse FEC mechanisms from rtpmap lines. switch (codec.name.toUpperCase()) { case 'RED': case 'ULPFEC': description.fecMechanisms.push(codec.name.toUpperCase()); break; default: // only RED and ULPFEC are recognized as FEC mechanisms. break; } } } SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(function(line) { description.headerExtensions.push(SDPUtils.parseExtmap(line)); }); // FIXME: parse rtcp. return description; }; // Generates parts of the SDP media section describing the capabilities / // parameters. SDPUtils.writeRtpDescription = function(kind, caps) { var sdp = ''; // Build the mline. sdp += 'm=' + kind + ' '; sdp += caps.codecs.length &gt; 0 ? '9' : '0'; // reject if no codecs. sdp += ' UDP/TLS/RTP/SAVPF '; sdp += caps.codecs.map(function(codec) { if (codec.preferredPayloadType !== undefined) { return codec.preferredPayloadType; } return codec.payloadType; }).join(' ') + '\\r\\n'; sdp += 'c=IN IP4 0.0.0.0\\r\\n'; sdp += 'a=rtcp:9 IN IP4 0.0.0.0\\r\\n'; // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb. caps.codecs.forEach(function(codec) { sdp += SDPUtils.writeRtpMap(codec); sdp += SDPUtils.writeFmtp(codec); sdp += SDPUtils.writeRtcpFb(codec); }); var maxptime = 0; caps.codecs.forEach(function(codec) { if (codec.maxptime &gt; maxptime) { maxptime = codec.maxptime; } }); if (maxptime &gt; 0) { sdp += 'a=maxptime:' + maxptime + '\\r\\n'; } sdp += 'a=rtcp-mux\\r\\n'; caps.headerExtensions.forEach(function(extension) { sdp += SDPUtils.writeExtmap(extension); }); // FIXME: write fecMechanisms. return sdp; }; // Parses the SDP media section and returns an array of // RTCRtpEncodingParameters. SDPUtils.parseRtpEncodingParameters = function(mediaSection) { var encodingParameters = []; var description = SDPUtils.parseRtpParameters(mediaSection); var hasRed = description.fecMechanisms.indexOf('RED') !== -1; var hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1; // filter a=ssrc:... cname:, ignore PlanB-msid var ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:') .map(function(line) { return SDPUtils.parseSsrcMedia(line); }) .filter(function(parts) { return parts.attribute === 'cname'; }); var primarySsrc = ssrcs.length &gt; 0 &amp;&amp; ssrcs[0].ssrc; var secondarySsrc; var flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID') .map(function(line) { var parts = line.split(' '); parts.shift(); return parts.map(function(part) { return parseInt(part, 10); }); }); if (flows.length &gt; 0 &amp;&amp; flows[0].length &gt; 1 &amp;&amp; flows[0][0] === primarySsrc) { secondarySsrc = flows[0][1]; } description.codecs.forEach(function(codec) { if (codec.name.toUpperCase() === 'RTX' &amp;&amp; codec.parameters.apt) { var encParam = { ssrc: primarySsrc, codecPayloadType: parseInt(codec.parameters.apt, 10), rtx: { ssrc: secondarySsrc } }; encodingParameters.push(encParam); if (hasRed) { encParam = JSON.parse(JSON.stringify(encParam)); encParam.fec = { ssrc: secondarySsrc, mechanism: hasUlpfec ? 'red+ulpfec' : 'red' }; encodingParameters.push(encParam); } } }); if (encodingParameters.length === 0 &amp;&amp; primarySsrc) { encodingParameters.push({ ssrc: primarySsrc }); } // we support both b=AS and b=TIAS but interpret AS as TIAS. var bandwidth = SDPUtils.matchPrefix(mediaSection, 'b='); if (bandwidth.length) { if (bandwidth[0].indexOf('b=TIAS:') === 0) { bandwidth = parseInt(bandwidth[0].substr(7), 10); } else if (bandwidth[0].indexOf('b=AS:') === 0) { bandwidth = parseInt(bandwidth[0].substr(5), 10); } encodingParameters.forEach(function(params) { params.maxBitrate = bandwidth; }); } return encodingParameters; }; // parses http://draft.ortc.org/#rtcrtcpparameters* SDPUtils.parseRtcpParameters = function(mediaSection) { var rtcpParameters = {}; var cname; // Gets the first SSRC. Note that with RTX there might be multiple // SSRCs. var remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:') .map(function(line) { return SDPUtils.parseSsrcMedia(line); }) .filter(function(obj) { return obj.attribute === 'cname'; })[0]; if (remoteSsrc) { rtcpParameters.cname = remoteSsrc.value; rtcpParameters.ssrc = remoteSsrc.ssrc; } // Edge uses the compound attribute instead of reducedSize // compound is !reducedSize var rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize'); rtcpParameters.reducedSize = rsize.length &gt; 0; rtcpParameters.compound = rsize.length === 0; // parses the rtcp-mux attrіbute. // Note that Edge does not support unmuxed RTCP. var mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux'); rtcpParameters.mux = mux.length &gt; 0; return rtcpParameters; }; // parses either a=msid: or a=ssrc:... msid lines an returns // the id of the MediaStream and MediaStreamTrack. SDPUtils.parseMsid = function(mediaSection) { var parts; var spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:'); if (spec.length === 1) { parts = spec[0].substr(7).split(' '); return {stream: parts[0], track: parts[1]}; } var planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:') .map(function(line) { return SDPUtils.parseSsrcMedia(line); }) .filter(function(parts) { return parts.attribute === 'msid'; }); if (planB.length &gt; 0) { parts = planB[0].value.split(' '); return {stream: parts[0], track: parts[1]}; } }; SDPUtils.writeSessionBoilerplate = function() { // FIXME: sess-id should be an NTP timestamp. return 'v=0\\r\\n' + 'o=thisisadapterortc 8169639915646943137 2 IN IP4 127.0.0.1\\r\\n' + 's=-\\r\\n' + 't=0 0\\r\\n'; }; SDPUtils.writeMediaSection = function(transceiver, caps, type, stream) { var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps); // Map ICE parameters (ufrag, pwd) to SDP. sdp += SDPUtils.writeIceParameters( transceiver.iceGatherer.getLocalParameters()); // Map DTLS parameters to SDP. sdp += SDPUtils.writeDtlsParameters( transceiver.dtlsTransport.getLocalParameters(), type === 'offer' ? 'actpass' : 'active'); sdp += 'a=mid:' + transceiver.mid + '\\r\\n'; if (transceiver.direction) { sdp += 'a=' + transceiver.direction + '\\r\\n'; } else if (transceiver.rtpSender &amp;&amp; transceiver.rtpReceiver) { sdp += 'a=sendrecv\\r\\n'; } else if (transceiver.rtpSender) { sdp += 'a=sendonly\\r\\n'; } else if (transceiver.rtpReceiver) { sdp += 'a=recvonly\\r\\n'; } else { sdp += 'a=inactive\\r\\n'; } if (transceiver.rtpSender) { // spec. var msid = 'msid:' + stream.id + ' ' + transceiver.rtpSender.track.id + '\\r\\n'; sdp += 'a=' + msid; // for Chrome. sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc + ' ' + msid; if (transceiver.sendEncodingParameters[0].rtx) { sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc + ' ' + msid; sdp += 'a=ssrc-group:FID ' + transceiver.sendEncodingParameters[0].ssrc + ' ' + transceiver.sendEncodingParameters[0].rtx.ssrc + '\\r\\n'; } } // FIXME: this should be written by writeRtpDescription. sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc + ' cname:' + SDPUtils.localCName + '\\r\\n'; if (transceiver.rtpSender &amp;&amp; transceiver.sendEncodingParameters[0].rtx) { sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc + ' cname:' + SDPUtils.localCName + '\\r\\n'; } return sdp; }; // Gets the direction from the mediaSection or the sessionpart. SDPUtils.getDirection = function(mediaSection, sessionpart) { // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv. var lines = SDPUtils.splitLines(mediaSection); for (var i = 0; i &lt; lines.length; i++) { switch (lines[i]) { case 'a=sendrecv': case 'a=sendonly': case 'a=recvonly': case 'a=inactive': return lines[i].substr(2); default: // FIXME: What should happen here? } } if (sessionpart) { return SDPUtils.getDirection(sessionpart); } return 'sendrecv'; }; SDPUtils.getKind = function(mediaSection) { var lines = SDPUtils.splitLines(mediaSection); var mline = lines[0].split(' '); return mline[0].substr(2); }; SDPUtils.isRejected = function(mediaSection) { return mediaSection.split(' ', 2)[1] === '0'; }; // Expose public methods. module.exports = SDPUtils; },{}],2:[function(require,module,exports){ /* * Copyright (c) 2016 The WebRTC project authors. All Rights Reserved. * * Use of this source code is governed by a BSD-style license * that can be found in the LICENSE file in the root of the source * tree. */ /* eslint-env node */ 'use strict'; // Shimming starts here. (function() { // Utils. var utils = require('./utils'); var logging = utils.log; var browserDetails = utils.browserDetails; // Export to the adapter global object visible in the browser. module.exports.browserDetails = browserDetails; module.exports.extractVersion = utils.extractVersion; module.exports.disableLog = utils.disableLog; // Uncomment the line below if you want logging to occur, including logging // for the switch statement below. Can also be turned on in the browser via // adapter.disableLog(false), but then logging from the switch statement below // will not appear. // require('./utils').disableLog(false); // Browser shims. var chromeShim = require('./chrome/chrome_shim') || null; var edgeShim = require('./edge/edge_shim') || null; var firefoxShim = require('./firefox/firefox_shim') || null; var safariShim = require('./safari/safari_shim') || null; // Shim browser if found. switch (browserDetails.browser) { case 'chrome': if (!chromeShim || !chromeShim.shimPeerConnection) { logging('Chrome shim is not included in this adapter release.'); return; } logging('adapter.js shimming chrome.'); // Export to the adapter global object visible in the browser. module.exports.browserShim = chromeShim; chromeShim.shimGetUserMedia(); chromeShim.shimMediaStream(); utils.shimCreateObjectURL(); chromeShim.shimSourceObject(); chromeShim.shimPeerConnection(); chromeShim.shimOnTrack(); chromeShim.shimGetSendersWithDtmf(); break; case 'firefox': if (!firefoxShim || !firefoxShim.shimPeerConnection) { logging('Firefox shim is not included in this adapter release.'); return; } logging('adapter.js shimming firefox.'); // Export to the adapter global object visible in the browser. module.exports.browserShim = firefoxShim; firefoxShim.shimGetUserMedia(); utils.shimCreateObjectURL(); firefoxShim.shimSourceObject(); firefoxShim.shimPeerConnection(); firefoxShim.shimOnTrack(); break; case 'edge': if (!edgeShim || !edgeShim.shimPeerConnection) { logging('MS edge shim is not included in this adapter release.'); return; } logging('adapter.js shimming edge.'); // Export to the adapter global object visible in the browser. module.exports.browserShim = edgeShim; edgeShim.shimGetUserMedia(); utils.shimCreateObjectURL(); edgeShim.shimPeerConnection(); edgeShim.shimReplaceTrack(); break; case 'safari': if (!safariShim) { logging('Safari shim is not included in this adapter release.'); return; } logging('adapter.js shimming safari.'); // Export to the adapter global object visible in the browser. module.exports.browserShim = safariShim; safariShim.shimCallbacksAPI(); safariShim.shimAddStream(); safariShim.shimOnAddStream(); safariShim.shimGetUserMedia(); break; default: logging('Unsupported browser!'); } })(); },{\"./chrome/chrome_shim\":3,\"./edge/edge_shim\":5,\"./firefox/firefox_shim\":8,\"./safari/safari_shim\":10,\"./utils\":11}],3:[function(require,module,exports){ /* * Copyright (c) 2016 The WebRTC project authors. All Rights Reserved. * * Use of this source code is governed by a BSD-style license * that can be found in the LICENSE file in the root of the source * tree. */ /* eslint-env node */ 'use strict'; var logging = require('../utils.js').log; var browserDetails = require('../utils.js').browserDetails; var chromeShim = { shimMediaStream: function() { window.MediaStream = window.MediaStream || window.webkitMediaStream; }, shimOnTrack: function() { if (typeof window === 'object' &amp;&amp; window.RTCPeerConnection &amp;&amp; !('ontrack' in window.RTCPeerConnection.prototype)) { Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', { get: function() { return this._ontrack; }, set: function(f) { var self = this; if (this._ontrack) { this.removeEventListener('track', this._ontrack); this.removeEventListener('addstream', this._ontrackpoly); } this.addEventListener('track', this._ontrack = f); this.addEventListener('addstream', this._ontrackpoly = function(e) { // onaddstream does not fire when a track is added to an existing // stream. But stream.onaddtrack is implemented so we use that. e.stream.addEventListener('addtrack', function(te) { var receiver; if (RTCPeerConnection.prototype.getReceivers) { receiver = self.getReceivers().find(function(r) { return r.track.id === te.track.id; }); } else { receiver = {track: te.track}; } var event = new Event('track'); event.track = te.track; event.receiver = receiver; event.streams = [e.stream]; self.dispatchEvent(event); }); e.stream.getTracks().forEach(function(track) { var receiver; if (RTCPeerConnection.prototype.getReceivers) { receiver = self.getReceivers().find(function(r) { return r.track.id === track.id; }); } else { receiver = {track: track}; } var event = new Event('track'); event.track = track; event.receiver = receiver; event.streams = [e.stream]; this.dispatchEvent(event); }.bind(this)); }.bind(this)); } }); } }, shimGetSendersWithDtmf: function() { if (typeof window === 'object' &amp;&amp; window.RTCPeerConnection &amp;&amp; !('getSenders' in RTCPeerConnection.prototype) &amp;&amp; 'createDTMFSender' in RTCPeerConnection.prototype) { RTCPeerConnection.prototype.getSenders = function() { return this._senders || []; }; var origAddStream = RTCPeerConnection.prototype.addStream; var origRemoveStream = RTCPeerConnection.prototype.removeStream; if (!RTCPeerConnection.prototype.addTrack) { RTCPeerConnection.prototype.addTrack = function(track, stream) { var pc = this; if (pc.signalingState === 'closed') { throw new DOMException( 'The RTCPeerConnection\\'s signalingState is \\'closed\\'.', 'InvalidStateError'); } var streams = [].slice.call(arguments, 1); if (streams.length !== 1 || !streams[0].getTracks().find(function(t) { return t === track; })) { // this is not fully correct but all we can manage without // [[associated MediaStreams]] internal slot. throw new DOMException( 'The adapter.js addTrack polyfill only supports a single ' + ' stream which is associated with the specified track.', 'NotSupportedError'); } pc._senders = pc._senders || []; var alreadyExists = pc._senders.find(function(t) { return t.track === track; }); if (alreadyExists) { throw new DOMException('Track already exists.', 'InvalidAccessError'); } pc._streams = pc._streams || {}; var oldStream = pc._streams[stream.id]; if (oldStream) { oldStream.addTrack(track); pc.removeStream(oldStream); pc.addStream(oldStream); } else { var newStream = new MediaStream([track]); pc._streams[stream.id] = newStream; pc.addStream(newStream); } var sender = { track: track, get dtmf() { if (this._dtmf === undefined) { if (track.kind === 'audio') { this._dtmf = pc.createDTMFSender(track); } else { this._dtmf = null; } } return this._dtmf; } }; pc._senders.push(sender); return sender; }; } RTCPeerConnection.prototype.addStream = function(stream) { var pc = this; pc._senders = pc._senders || []; origAddStream.apply(pc, [stream]); stream.getTracks().forEach(function(track) { pc._senders.push({ track: track, get dtmf() { if (this._dtmf === undefined) { if (track.kind === 'audio') { this._dtmf = pc.createDTMFSender(track); } else { this._dtmf = null; } } return this._dtmf; } }); }); }; RTCPeerConnection.prototype.removeStream = function(stream) { var pc = this; pc._senders = pc._senders || []; origRemoveStream.apply(pc, [stream]); stream.getTracks().forEach(function(track) { var sender = pc._senders.find(function(s) { return s.track === track; }); if (sender) { pc._senders.splice(pc._senders.indexOf(sender), 1); // remove sender } }); }; } }, shimSourceObject: function() { if (typeof window === 'object') { if (window.HTMLMediaElement &amp;&amp; !('srcObject' in window.HTMLMediaElement.prototype)) { // Shim the srcObject property, once, when HTMLMediaElement is found. Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', { get: function() { return this._srcObject; }, set: function(stream) { var self = this; // Use _srcObject as a private property for this shim this._srcObject = stream; if (this.src) { URL.revokeObjectURL(this.src); } if (!stream) { this.src = ''; return undefined; } this.src = URL.createObjectURL(stream); // We need to recreate the blob url when a track is added or // removed. Doing it manually since we want to avoid a recursion. stream.addEventListener('addtrack', function() { if (self.src) { URL.revokeObjectURL(self.src); } self.src = URL.createObjectURL(stream); }); stream.addEventListener('removetrack', function() { if (self.src) { URL.revokeObjectURL(self.src); } self.src = URL.createObjectURL(stream); }); } }); } } }, shimPeerConnection: function() { // The RTCPeerConnection object. if (!window.RTCPeerConnection) { window.RTCPeerConnection = function(pcConfig, pcConstraints) { // Translate iceTransportPolicy to iceTransports, // see https://code.google.com/p/webrtc/issues/detail?id=4869 // this was fixed in M56 along with unprefixing RTCPeerConnection. logging('PeerConnection'); if (pcConfig &amp;&amp; pcConfig.iceTransportPolicy) { pcConfig.iceTransports = pcConfig.iceTransportPolicy; } return new webkitRTCPeerConnection(pcConfig, pcConstraints); }; window.RTCPeerConnection.prototype = webkitRTCPeerConnection.prototype; // wrap static methods. Currently just generateCertificate. if (webkitRTCPeerConnection.generateCertificate) { Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', { get: function() { return webkitRTCPeerConnection.generateCertificate; } }); } } else { // migrate from non-spec RTCIceServer.url to RTCIceServer.urls var OrigPeerConnection = RTCPeerConnection; window.RTCPeerConnection = function(pcConfig, pcConstraints) { if (pcConfig &amp;&amp; pcConfig.iceServers) { var newIceServers = []; for (var i = 0; i &lt; pcConfig.iceServers.length; i++) { var server = pcConfig.iceServers[i]; if (!server.hasOwnProperty('urls') &amp;&amp; server.hasOwnProperty('url')) { console.warn('RTCIceServer.url is deprecated! Use urls instead.'); server = JSON.parse(JSON.stringify(server)); server.urls = server.url; newIceServers.push(server); } else { newIceServers.push(pcConfig.iceServers[i]); } } pcConfig.iceServers = newIceServers; } return new OrigPeerConnection(pcConfig, pcConstraints); }; window.RTCPeerConnection.prototype = OrigPeerConnection.prototype; // wrap static methods. Currently just generateCertificate. Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', { get: function() { return OrigPeerConnection.generateCertificate; } }); } var origGetStats = RTCPeerConnection.prototype.getStats; RTCPeerConnection.prototype.getStats = function(selector, successCallback, errorCallback) { var self = this; var args = arguments; // If selector is a function then we are in the old style stats so just // pass back the original getStats format to avoid breaking old users. if (arguments.length &gt; 0 &amp;&amp; typeof selector === 'function') { return origGetStats.apply(this, arguments); } // When spec-style getStats is supported, return those when called with // either no arguments or the selector argument is null. if (origGetStats.length === 0 &amp;&amp; (arguments.length === 0 || typeof arguments[0] !== 'function')) { return origGetStats.apply(this, []); } var fixChromeStats_ = function(response) { var standardReport = {}; var reports = response.result(); reports.forEach(function(report) { var standardStats = { id: report.id, timestamp: report.timestamp, type: { localcandidate: 'local-candidate', remotecandidate: 'remote-candidate' }[report.type] || report.type }; report.names().forEach(function(name) { standardStats[name] = report.stat(name); }); standardReport[standardStats.id] = standardStats; }); return standardReport; }; // shim getStats with maplike support var makeMapStats = function(stats) { return new Map(Object.keys(stats).map(function(key) { return [key, stats[key]]; })); }; if (arguments.length &gt;= 2) { var successCallbackWrapper_ = function(response) { args[1](makeMapStats(fixChromeStats_(response))); }; return origGetStats.apply(this, [successCallbackWrapper_, arguments[0]]); } // promise-support return new Promise(function(resolve, reject) { origGetStats.apply(self, [ function(response) { resolve(makeMapStats(fixChromeStats_(response))); }, reject]); }).then(successCallback, errorCallback); }; // add promise support -- natively available in Chrome 51 if (browserDetails.version &lt; 51) { ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'] .forEach(function(method) { var nativeMethod = RTCPeerConnection.prototype[method]; RTCPeerConnection.prototype[method] = function() { var args = arguments; var self = this; var promise = new Promise(function(resolve, reject) { nativeMethod.apply(self, [args[0], resolve, reject]); }); if (args.length &lt; 2) { return promise; } return promise.then(function() { args[1].apply(null, []); }, function(err) { if (args.length &gt;= 3) { args[2].apply(null, [err]); } }); }; }); } // promise support for createOffer and createAnswer. Available (without // bugs) since M52: crbug/619289 if (browserDetails.version &lt; 52) { ['createOffer', 'createAnswer'].forEach(function(method) { var nativeMethod = RTCPeerConnection.prototype[method]; RTCPeerConnection.prototype[method] = function() { var self = this; if (arguments.length &lt; 1 || (arguments.length === 1 &amp;&amp; typeof arguments[0] === 'object')) { var opts = arguments.length === 1 ? arguments[0] : undefined; return new Promise(function(resolve, reject) { nativeMethod.apply(self, [resolve, reject, opts]); }); } return nativeMethod.apply(this, arguments); }; }); } // shim implicit creation of RTCSessionDescription/RTCIceCandidate ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'] .forEach(function(method) { var nativeMethod = RTCPeerConnection.prototype[method]; RTCPeerConnection.prototype[method] = function() { arguments[0] = new ((method === 'addIceCandidate') ? RTCIceCandidate : RTCSessionDescription)(arguments[0]); return nativeMethod.apply(this, arguments); }; }); // support for addIceCandidate(null or undefined) var nativeAddIceCandidate = RTCPeerConnection.prototype.addIceCandidate; RTCPeerConnection.prototype.addIceCandidate = function() { if (!arguments[0]) { if (arguments[1]) { arguments[1].apply(null); } return Promise.resolve(); } return nativeAddIceCandidate.apply(this, arguments); }; } }; // Expose public methods. module.exports = { shimMediaStream: chromeShim.shimMediaStream, shimOnTrack: chromeShim.shimOnTrack, shimGetSendersWithDtmf: chromeShim.shimGetSendersWithDtmf, shimSourceObject: chromeShim.shimSourceObject, shimPeerConnection: chromeShim.shimPeerConnection, shimGetUserMedia: require('./getusermedia') }; },{\"../utils.js\":11,\"./getusermedia\":4}],4:[function(require,module,exports){ /* * Copyright (c) 2016 The WebRTC project authors. All Rights Reserved. * * Use of this source code is governed by a BSD-style license * that can be found in the LICENSE file in the root of the source * tree. */ /* eslint-env node */ 'use strict'; var logging = require('../utils.js').log; var browserDetails = require('../utils.js').browserDetails; // Expose public methods. module.exports = function() { var constraintsToChrome_ = function(c) { if (typeof c !== 'object' || c.mandatory || c.optional) { return c; } var cc = {}; Object.keys(c).forEach(function(key) { if (key === 'require' || key === 'advanced' || key === 'mediaSource') { return; } var r = (typeof c[key] === 'object') ? c[key] : {ideal: c[key]}; if (r.exact !== undefined &amp;&amp; typeof r.exact === 'number') { r.min = r.max = r.exact; } var oldname_ = function(prefix, name) { if (prefix) { return prefix + name.charAt(0).toUpperCase() + name.slice(1); } return (name === 'deviceId') ? 'sourceId' : name; }; if (r.ideal !== undefined) { cc.optional = cc.optional || []; var oc = {}; if (typeof r.ideal === 'number') { oc[oldname_('min', key)] = r.ideal; cc.optional.push(oc); oc = {}; oc[oldname_('max', key)] = r.ideal; cc.optional.push(oc); } else { oc[oldname_('', key)] = r.ideal; cc.optional.push(oc); } } if (r.exact !== undefined &amp;&amp; typeof r.exact !== 'number') { cc.mandatory = cc.mandatory || {}; cc.mandatory[oldname_('', key)] = r.exact; } else { ['min', 'max'].forEach(function(mix) { if (r[mix] !== undefined) { cc.mandatory = cc.mandatory || {}; cc.mandatory[oldname_(mix, key)] = r[mix]; } }); } }); if (c.advanced) { cc.optional = (cc.optional || []).concat(c.advanced); } return cc; }; var shimConstraints_ = function(constraints, func) { constraints = JSON.parse(JSON.stringify(constraints)); if (constraints &amp;&amp; constraints.audio) { constraints.audio = constraintsToChrome_(constraints.audio); } if (constraints &amp;&amp; typeof constraints.video === 'object') { // Shim facingMode for mobile &amp; surface pro. var face = constraints.video.facingMode; face = face &amp;&amp; ((typeof face === 'object') ? face : {ideal: face}); var getSupportedFacingModeLies = browserDetails.version &lt; 61; if ((face &amp;&amp; (face.exact === 'user' || face.exact === 'environment' || face.ideal === 'user' || face.ideal === 'environment')) &amp;&amp; !(navigator.mediaDevices.getSupportedConstraints &amp;&amp; navigator.mediaDevices.getSupportedConstraints().facingMode &amp;&amp; !getSupportedFacingModeLies)) { delete constraints.video.facingMode; var matches; if (face.exact === 'environment' || face.ideal === 'environment') { matches = ['back', 'rear']; } else if (face.exact === 'user' || face.ideal === 'user') { matches = ['front']; } if (matches) { // Look for matches in label, or use last cam for back (typical). return navigator.mediaDevices.enumerateDevices() .then(function(devices) { devices = devices.filter(function(d) { return d.kind === 'videoinput'; }); var dev = devices.find(function(d) { return matches.some(function(match) { return d.label.toLowerCase().indexOf(match) !== -1; }); }); if (!dev &amp;&amp; devices.length &amp;&amp; matches.indexOf('back') !== -1) { dev = devices[devices.length - 1]; // more likely the back cam } if (dev) { constraints.video.deviceId = face.exact ? {exact: dev.deviceId} : {ideal: dev.deviceId}; } constraints.video = constraintsToChrome_(constraints.video); logging('chrome: ' + JSON.stringify(constraints)); return func(constraints); }); } } constraints.video = constraintsToChrome_(constraints.video); } logging('chrome: ' + JSON.stringify(constraints)); return func(constraints); }; var shimError_ = function(e) { return { name: { ConstraintNotSatisfiedError: 'OverconstrainedError', PermissionDeniedError: 'NotAllowedError', TrackStartError: 'NotReadableError' }[e.name] || e.name, message: e.message, constraint: e.constraintName, toString: function() { return this.name + (this.message &amp;&amp; ': ') + this.message; } }; }; var getUserMedia_ = function(constraints, onSuccess, onError) { shimConstraints_(constraints, function(c) { navigator.webkitGetUserMedia(c, onSuccess, function(e) { onError(shimError_(e)); }); }); }; navigator.getUserMedia = getUserMedia_; // Returns the result of getUserMedia as a Promise. var getUserMediaPromise_ = function(constraints) { return new Promise(function(resolve, reject) { navigator.getUserMedia(constraints, resolve, reject); }); }; if (!navigator.mediaDevices) { navigator.mediaDevices = { getUserMedia: getUserMediaPromise_, enumerateDevices: function() { return new Promise(function(resolve) { var kinds = {audio: 'audioinput', video: 'videoinput'}; return MediaStreamTrack.getSources(function(devices) { resolve(devices.map(function(device) { return {label: device.label, kind: kinds[device.kind], deviceId: device.id, groupId: ''}; })); }); }); }, getSupportedConstraints: function() { return { deviceId: true, echoCancellation: true, facingMode: true, frameRate: true, height: true, width: true }; } }; } // A shim for getUserMedia method on the mediaDevices object. // TODO(KaptenJansson) remove once implemented in Chrome stable. if (!navigator.mediaDevices.getUserMedia) { navigator.mediaDevices.getUserMedia = function(constraints) { return getUserMediaPromise_(constraints); }; } else { // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia // function which returns a Promise, it does not accept spec-style // constraints. var origGetUserMedia = navigator.mediaDevices.getUserMedia. bind(navigator.mediaDevices); navigator.mediaDevices.getUserMedia = function(cs) { return shimConstraints_(cs, function(c) { return origGetUserMedia(c).then(function(stream) { if (c.audio &amp;&amp; !stream.getAudioTracks().length || c.video &amp;&amp; !stream.getVideoTracks().length) { stream.getTracks().forEach(function(track) { track.stop(); }); throw new DOMException('', 'NotFoundError'); } return stream; }, function(e) { return Promise.reject(shimError_(e)); }); }); }; } // Dummy devicechange event methods. // TODO(KaptenJansson) remove once implemented in Chrome stable. if (typeof navigator.mediaDevices.addEventListener === 'undefined') { navigator.mediaDevices.addEventListener = function() { logging('Dummy mediaDevices.addEventListener called.'); }; } if (typeof navigator.mediaDevices.removeEventListener === 'undefined') { navigator.mediaDevices.removeEventListener = function() { logging('Dummy mediaDevices.removeEventListener called.'); }; } }; },{\"../utils.js\":11}],5:[function(require,module,exports){ /* * Copyright (c) 2016 The WebRTC project authors. All Rights Reserved. * * Use of this source code is governed by a BSD-style license * that can be found in the LICENSE file in the root of the source * tree. */ /* eslint-env node */ 'use strict'; var browserDetails = require('../utils').browserDetails; var shimRTCPeerConnection = require('./rtcpeerconnection_shim'); module.exports = { shimGetUserMedia: require('./getusermedia'), shimPeerConnection: function() { if (window.RTCIceGatherer) { // ORTC defines an RTCIceCandidate object but no constructor. // Not implemented in Edge. if (!window.RTCIceCandidate) { window.RTCIceCandidate = function(args) { return args; }; } // ORTC does not have a session description object but // other browsers (i.e. Chrome) that will support both PC and ORTC // in the future might have this defined already. if (!window.RTCSessionDescription) { window.RTCSessionDescription = function(args) { return args; }; } // this adds an additional event listener to MediaStrackTrack that signals // when a tracks enabled property was changed. Workaround for a bug in // addStream, see below. No longer required in 15025+ if (browserDetails.version &lt; 15025) { var origMSTEnabled = Object.getOwnPropertyDescriptor( MediaStreamTrack.prototype, 'enabled'); Object.defineProperty(MediaStreamTrack.prototype, 'enabled', { set: function(value) { origMSTEnabled.set.call(this, value); var ev = new Event('enabled'); ev.enabled = value; this.dispatchEvent(ev); } }); } } window.RTCPeerConnection = shimRTCPeerConnection(browserDetails.version); }, shimReplaceTrack: function() { // ORTC has replaceTrack -- https://github.com/w3c/ortc/issues/614 if (window.RTCRtpSender &amp;&amp; !('replaceTrack' in RTCRtpSender.prototype)) { RTCRtpSender.prototype.replaceTrack = RTCRtpSender.prototype.setTrack; } } }; },{\"../utils\":11,\"./getusermedia\":6,\"./rtcpeerconnection_shim\":7}],6:[function(require,module,exports){ /* * Copyright (c) 2016 The WebRTC project authors. All Rights Reserved. * * Use of this source code is governed by a BSD-style license * that can be found in the LICENSE file in the root of the source * tree. */ /* eslint-env node */ 'use strict'; // Expose public methods. module.exports = function() { var shimError_ = function(e) { return { name: {PermissionDeniedError: 'NotAllowedError'}[e.name] || e.name, message: e.message, constraint: e.constraint, toString: function() { return this.name; } }; }; // getUserMedia error shim. var origGetUserMedia = navigator.mediaDevices.getUserMedia. bind(navigator.mediaDevices); navigator.mediaDevices.getUserMedia = function(c) { return origGetUserMedia(c).catch(function(e) { return Promise.reject(shimError_(e)); }); }; }; },{}],7:[function(require,module,exports){ /* * Copyright (c) 2017 The WebRTC project authors. All Rights Reserved. * * Use of this source code is governed by a BSD-style license * that can be found in the LICENSE file in the root of the source * tree. */ /* eslint-env node */ 'use strict'; var SDPUtils = require('sdp'); // sort tracks such that they follow an a-v-a-v... // pattern. function sortTracks(tracks) { var audioTracks = tracks.filter(function(track) { return track.kind === 'audio'; }); var videoTracks = tracks.filter(function(track) { return track.kind === 'video'; }); tracks = []; while (audioTracks.length || videoTracks.length) { if (audioTracks.length) { tracks.push(audioTracks.shift()); } if (videoTracks.length) { tracks.push(videoTracks.shift()); } } return tracks; } // Edge does not like // 1) stun: // 2) turn: that does not have all of turn:host:port?transport=udp // 3) turn: with ipv6 addresses // 4) turn: occurring muliple times function filterIceServers(iceServers, edgeVersion) { var hasTurn = false; iceServers = JSON.parse(JSON.stringify(iceServers)); return iceServers.filter(function(server) { if (server &amp;&amp; (server.urls || server.url)) { var urls = server.urls || server.url; if (server.url &amp;&amp; !server.urls) { console.warn('RTCIceServer.url is deprecated! Use urls instead.'); } var isString = typeof urls === 'string'; if (isString) { urls = [urls]; } urls = urls.filter(function(url) { var validTurn = url.indexOf('turn:') === 0 &amp;&amp; url.indexOf('transport=udp') !== -1 &amp;&amp; url.indexOf('turn:[') === -1 &amp;&amp; !hasTurn; if (validTurn) { hasTurn = true; return true; } return url.indexOf('stun:') === 0 &amp;&amp; edgeVersion &gt;= 14393; }); delete server.url; server.urls = isString ? urls[0] : urls; return !!urls.length; } return false; }); } // Determines the intersection of local and remote capabilities. function getCommonCapabilities(localCapabilities, remoteCapabilities) { var commonCapabilities = { codecs: [], headerExtensions: [], fecMechanisms: [] }; var findCodecByPayloadType = function(pt, codecs) { pt = parseInt(pt, 10); for (var i = 0; i &lt; codecs.length; i++) { if (codecs[i].payloadType === pt || codecs[i].preferredPayloadType === pt) { return codecs[i]; } } }; var rtxCapabilityMatches = function(lRtx, rRtx, lCodecs, rCodecs) { var lCodec = findCodecByPayloadType(lRtx.parameters.apt, lCodecs); var rCodec = findCodecByPayloadType(rRtx.parameters.apt, rCodecs); return lCodec &amp;&amp; rCodec &amp;&amp; lCodec.name.toLowerCase() === rCodec.name.toLowerCase(); }; localCapabilities.codecs.forEach(function(lCodec) { for (var i = 0; i &lt; remoteCapabilities.codecs.length; i++) { var rCodec = remoteCapabilities.codecs[i]; if (lCodec.name.toLowerCase() === rCodec.name.toLowerCase() &amp;&amp; lCodec.clockRate === rCodec.clockRate) { if (lCodec.name.toLowerCase() === 'rtx' &amp;&amp; lCodec.parameters &amp;&amp; rCodec.parameters.apt) { // for RTX we need to find the local rtx that has a apt // which points to the same local codec as the remote one. if (!rtxCapabilityMatches(lCodec, rCodec, localCapabilities.codecs, remoteCapabilities.codecs)) { continue; } } rCodec = JSON.parse(JSON.stringify(rCodec)); // deepcopy // number of channels is the highest common number of channels rCodec.numChannels = Math.min(lCodec.numChannels, rCodec.numChannels); // push rCodec so we reply with offerer payload type commonCapabilities.codecs.push(rCodec); // determine common feedback mechanisms rCodec.rtcpFeedback = rCodec.rtcpFeedback.filter(function(fb) { for (var j = 0; j &lt; lCodec.rtcpFeedback.length; j++) { if (lCodec.rtcpFeedback[j].type === fb.type &amp;&amp; lCodec.rtcpFeedback[j].parameter === fb.parameter) { return true; } } return false; }); // FIXME: also need to determine .parameters // see https://github.com/openpeer/ortc/issues/569 break; } } }); localCapabilities.headerExtensions.forEach(function(lHeaderExtension) { for (var i = 0; i &lt; remoteCapabilities.headerExtensions.length; i++) { var rHeaderExtension = remoteCapabilities.headerExtensions[i]; if (lHeaderExtension.uri === rHeaderExtension.uri) { commonCapabilities.headerExtensions.push(rHeaderExtension); break; } } }); // FIXME: fecMechanisms return commonCapabilities; } // is action=setLocalDescription with type allowed in signalingState function isActionAllowedInSignalingState(action, type, signalingState) { return { offer: { setLocalDescription: ['stable', 'have-local-offer'], setRemoteDescription: ['stable', 'have-remote-offer'] }, answer: { setLocalDescription: ['have-remote-offer', 'have-local-pranswer'], setRemoteDescription: ['have-local-offer', 'have-remote-pranswer'] } }[type][action].indexOf(signalingState) !== -1; } module.exports = function(edgeVersion) { var RTCPeerConnection = function(config) { var self = this; var _eventTarget = document.createDocumentFragment(); ['addEventListener', 'removeEventListener', 'dispatchEvent'] .forEach(function(method) { self[method] = _eventTarget[method].bind(_eventTarget); }); this.needNegotiation = false; this.onicecandidate = null; this.onaddstream = null; this.ontrack = null; this.onremovestream = null; this.onsignalingstatechange = null; this.oniceconnectionstatechange = null; this.onicegatheringstatechange = null; this.onnegotiationneeded = null; this.ondatachannel = null; this.canTrickleIceCandidates = null; this.localStreams = []; this.remoteStreams = []; this.getLocalStreams = function() { return self.localStreams; }; this.getRemoteStreams = function() { return self.remoteStreams; }; this.localDescription = new RTCSessionDescription({ type: '', sdp: '' }); this.remoteDescription = new RTCSessionDescription({ type: '', sdp: '' }); this.signalingState = 'stable'; this.iceConnectionState = 'new'; this.iceGatheringState = 'new'; this.iceOptions = { gatherPolicy: 'all', iceServers: [] }; if (config &amp;&amp; config.iceTransportPolicy) { switch (config.iceTransportPolicy) { case 'all': case 'relay': this.iceOptions.gatherPolicy = config.iceTransportPolicy; break; default: // don't set iceTransportPolicy. break; } } this.usingBundle = config &amp;&amp; config.bundlePolicy === 'max-bundle'; if (config &amp;&amp; config.iceServers) { this.iceOptions.iceServers = filterIceServers(config.iceServers, edgeVersion); } this._config = config || {}; // per-track iceGathers, iceTransports, dtlsTransports, rtpSenders, ... // everything that is needed to describe a SDP m-line. this.transceivers = []; // since the iceGatherer is currently created in createOffer but we // must not emit candidates until after setLocalDescription we buffer // them in this array. this._localIceCandidatesBuffer = []; }; RTCPeerConnection.prototype._emitGatheringStateChange = function() { var event = new Event('icegatheringstatechange'); this.dispatchEvent(event); if (this.onicegatheringstatechange !== null) { this.onicegatheringstatechange(event); } }; RTCPeerConnection.prototype._emitBufferedCandidates = function() { var self = this; var sections = SDPUtils.splitSections(self.localDescription.sdp); // FIXME: need to apply ice candidates in a way which is async but // in-order this._localIceCandidatesBuffer.forEach(function(event) { var end = !event.candidate || Object.keys(event.candidate).length === 0; if (end) { for (var j = 1; j &lt; sections.length; j++) { if (sections[j].indexOf('\\r\\na=end-of-candidates\\r\\n') === -1) { sections[j] += 'a=end-of-candidates\\r\\n'; } } } else { sections[event.candidate.sdpMLineIndex + 1] += 'a=' + event.candidate.candidate + '\\r\\n'; } self.localDescription.sdp = sections.join(''); self.dispatchEvent(event); if (self.onicecandidate !== null) { self.onicecandidate(event); } if (!event.candidate &amp;&amp; self.iceGatheringState !== 'complete') { var complete = self.transceivers.every(function(transceiver) { return transceiver.iceGatherer &amp;&amp; transceiver.iceGatherer.state === 'completed'; }); if (complete &amp;&amp; self.iceGatheringStateChange !== 'complete') { self.iceGatheringState = 'complete'; self._emitGatheringStateChange(); } } }); this._localIceCandidatesBuffer = []; }; RTCPeerConnection.prototype.getConfiguration = function() { return this._config; }; // internal helper to create a transceiver object. // (whih is not yet the same as the WebRTC 1.0 transceiver) RTCPeerConnection.prototype._createTransceiver = function(kind) { var hasBundleTransport = this.transceivers.length &gt; 0; var transceiver = { track: null, iceGatherer: null, iceTransport: null, dtlsTransport: null, localCapabilities: null, remoteCapabilities: null, rtpSender: null, rtpReceiver: null, kind: kind, mid: null, sendEncodingParameters: null, recvEncodingParameters: null, stream: null, wantReceive: true }; if (this.usingBundle &amp;&amp; hasBundleTransport) { transceiver.iceTransport = this.transceivers[0].iceTransport; transceiver.dtlsTransport = this.transceivers[0].dtlsTransport; } else { var transports = this._createIceAndDtlsTransports(); transceiver.iceTransport = transports.iceTransport; transceiver.dtlsTransport = transports.dtlsTransport; } this.transceivers.push(transceiver); return transceiver; }; RTCPeerConnection.prototype.addTrack = function(track, stream) { var transceiver; for (var i = 0; i &lt; this.transceivers.length; i++) { if (!this.transceivers[i].track &amp;&amp; this.transceivers[i].kind === track.kind) { transceiver = this.transceivers[i]; } } if (!transceiver) { transceiver = this._createTransceiver(track.kind); } transceiver.track = track; transceiver.stream = stream; transceiver.rtpSender = new RTCRtpSender(track, transceiver.dtlsTransport); this._maybeFireNegotiationNeeded(); return transceiver.rtpSender; }; RTCPeerConnection.prototype.addStream = function(stream) { var self = this; if (edgeVersion &gt;= 15025) { this.localStreams.push(stream); stream.getTracks().forEach(function(track) { self.addTrack(track, stream); }); } else { // Clone is necessary for local demos mostly, attaching directly // to two different senders does not work (build 10547). // Fixed in 15025 (or earlier) var clonedStream = stream.clone(); stream.getTracks().forEach(function(track, idx) { var clonedTrack = clonedStream.getTracks()[idx]; track.addEventListener('enabled', function(event) { clonedTrack.enabled = event.enabled; }); }); clonedStream.getTracks().forEach(function(track) { self.addTrack(track, clonedStream); }); this.localStreams.push(clonedStream); } this._maybeFireNegotiationNeeded(); }; RTCPeerConnection.prototype.removeStream = function(stream) { var idx = this.localStreams.indexOf(stream); if (idx &gt; -1) { this.localStreams.splice(idx, 1); this._maybeFireNegotiationNeeded(); } }; RTCPeerConnection.prototype.getSenders = function() { return this.transceivers.filter(function(transceiver) { return !!transceiver.rtpSender; }) .map(function(transceiver) { return transceiver.rtpSender; }); }; RTCPeerConnection.prototype.getReceivers = function() { return this.transceivers.filter(function(transceiver) { return !!transceiver.rtpReceiver; }) .map(function(transceiver) { return transceiver.rtpReceiver; }); }; // Create ICE gatherer and hook it up. RTCPeerConnection.prototype._createIceGatherer = function(mid, sdpMLineIndex) { var self = this; var iceGatherer = new RTCIceGatherer(self.iceOptions); iceGatherer.onlocalcandidate = function(evt) { var event = new Event('icecandidate'); event.candidate = {sdpMid: mid, sdpMLineIndex: sdpMLineIndex}; var cand = evt.candidate; var end = !cand || Object.keys(cand).length === 0; // Edge emits an empty object for RTCIceCandidateComplete‥ if (end) { // polyfill since RTCIceGatherer.state is not implemented in // Edge 10547 yet. if (iceGatherer.state === undefined) { iceGatherer.state = 'completed'; } } else { // RTCIceCandidate doesn't have a component, needs to be added cand.component = 1; event.candidate.candidate = SDPUtils.writeCandidate(cand); } // update local description. var sections = SDPUtils.splitSections(self.localDescription.sdp); if (!end) { sections[event.candidate.sdpMLineIndex + 1] += 'a=' + event.candidate.candidate + '\\r\\n'; } else { sections[event.candidate.sdpMLineIndex + 1] += 'a=end-of-candidates\\r\\n'; } self.localDescription.sdp = sections.join(''); var transceivers = self._pendingOffer ? self._pendingOffer : self.transceivers; var complete = transceivers.every(function(transceiver) { return transceiver.iceGatherer &amp;&amp; transceiver.iceGatherer.state === 'completed'; }); // Emit candidate if localDescription is set. // Also emits null candidate when all gatherers are complete. switch (self.iceGatheringState) { case 'new': if (!end) { self._localIceCandidatesBuffer.push(event); } if (end &amp;&amp; complete) { self._localIceCandidatesBuffer.push( new Event('icecandidate')); } break; case 'gathering': self._emitBufferedCandidates(); if (!end) { self.dispatchEvent(event); if (self.onicecandidate !== null) { self.onicecandidate(event); } } if (complete) { self.dispatchEvent(new Event('icecandidate')); if (self.onicecandidate !== null) { self.onicecandidate(new Event('icecandidate')); } self.iceGatheringState = 'complete'; self._emitGatheringStateChange(); } break; case 'complete': // should not happen... currently! break; default: // no-op. break; } }; return iceGatherer; }; // Create ICE transport and DTLS transport. RTCPeerConnection.prototype._createIceAndDtlsTransports = function() { var self = this; var iceTransport = new RTCIceTransport(null); iceTransport.onicestatechange = function() { self._updateConnectionState(); }; var dtlsTransport = new RTCDtlsTransport(iceTransport); dtlsTransport.ondtlsstatechange = function() { self._updateConnectionState(); }; dtlsTransport.onerror = function() { // onerror does not set state to failed by itself. Object.defineProperty(dtlsTransport, 'state', {value: 'failed', writable: true}); self._updateConnectionState(); }; return { iceTransport: iceTransport, dtlsTransport: dtlsTransport }; }; // Destroy ICE gatherer, ICE transport and DTLS transport. // Without triggering the callbacks. RTCPeerConnection.prototype._disposeIceAndDtlsTransports = function( sdpMLineIndex) { var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer; if (iceGatherer) { delete iceGatherer.onlocalcandidate; delete this.transceivers[sdpMLineIndex].iceGatherer; } var iceTransport = this.transceivers[sdpMLineIndex].iceTransport; if (iceTransport) { delete iceTransport.onicestatechange; delete this.transceivers[sdpMLineIndex].iceTransport; } var dtlsTransport = this.transceivers[sdpMLineIndex].dtlsTransport; if (dtlsTransport) { delete dtlsTransport.ondtlssttatechange; delete dtlsTransport.onerror; delete this.transceivers[sdpMLineIndex].dtlsTransport; } }; // Start the RTP Sender and Receiver for a transceiver. RTCPeerConnection.prototype._transceive = function(transceiver, send, recv) { var params = getCommonCapabilities(transceiver.localCapabilities, transceiver.remoteCapabilities); if (send &amp;&amp; transceiver.rtpSender) { params.encodings = transceiver.sendEncodingParameters; params.rtcp = { cname: SDPUtils.localCName, compound: transceiver.rtcpParameters.compound }; if (transceiver.recvEncodingParameters.length) { params.rtcp.ssrc = transceiver.recvEncodingParameters[0].ssrc; } transceiver.rtpSender.send(params); } if (recv &amp;&amp; transceiver.rtpReceiver) { // remove RTX field in Edge 14942 if (transceiver.kind === 'video' &amp;&amp; transceiver.recvEncodingParameters &amp;&amp; edgeVersion &lt; 15019) { transceiver.recvEncodingParameters.forEach(function(p) { delete p.rtx; }); } params.encodings = transceiver.recvEncodingParameters; params.rtcp = { cname: transceiver.rtcpParameters.cname, compound: transceiver.rtcpParameters.compound }; if (transceiver.sendEncodingParameters.length) { params.rtcp.ssrc = transceiver.sendEncodingParameters[0].ssrc; } transceiver.rtpReceiver.receive(params); } }; RTCPeerConnection.prototype.setLocalDescription = function(description) { var self = this; if (!isActionAllowedInSignalingState('setLocalDescription', description.type, this.signalingState)) { var e = new Error('Can not set local ' + description.type + ' in state ' + this.signalingState); e.name = 'InvalidStateError'; if (arguments.length &gt; 2 &amp;&amp; typeof arguments[2] === 'function') { window.setTimeout(arguments[2], 0, e); } return Promise.reject(e); } var sections; var sessionpart; if (description.type === 'offer') { // FIXME: What was the purpose of this empty if statement? // if (!this._pendingOffer) { // } else { if (this._pendingOffer) { // VERY limited support for SDP munging. Limited to: // * changing the order of codecs sections = SDPUtils.splitSections(description.sdp); sessionpart = sections.shift(); sections.forEach(function(mediaSection, sdpMLineIndex) { var caps = SDPUtils.parseRtpParameters(mediaSection); self._pendingOffer[sdpMLineIndex].localCapabilities = caps; }); this.transceivers = this._pendingOffer; delete this._pendingOffer; } } else if (description.type === 'answer') { sections = SDPUtils.splitSections(self.remoteDescription.sdp); sessionpart = sections.shift(); var isIceLite = SDPUtils.matchPrefix(sessionpart, 'a=ice-lite').length &gt; 0; sections.forEach(function(mediaSection, sdpMLineIndex) { var transceiver = self.transceivers[sdpMLineIndex]; var iceGatherer = transceiver.iceGatherer; var iceTransport = transceiver.iceTransport; var dtlsTransport = transceiver.dtlsTransport; var localCapabilities = transceiver.localCapabilities; var remoteCapabilities = transceiver.remoteCapabilities; var rejected = SDPUtils.isRejected(mediaSection); if (!rejected &amp;&amp; !transceiver.isDatachannel) { var remoteIceParameters = SDPUtils.getIceParameters( mediaSection, sessionpart); var remoteDtlsParameters = SDPUtils.getDtlsParameters( mediaSection, sessionpart); if (isIceLite) { remoteDtlsParameters.role = 'server'; } if (!self.usingBundle || sdpMLineIndex === 0) { iceTransport.start(iceGatherer, remoteIceParameters, isIceLite ? 'controlling' : 'controlled'); dtlsTransport.start(remoteDtlsParameters); } // Calculate intersection of capabilities. var params = getCommonCapabilities(localCapabilities, remoteCapabilities); // Start the RTCRtpSender. The RTCRtpReceiver for this // transceiver has already been started in setRemoteDescription. self._transceive(transceiver, params.codecs.length &gt; 0, false); } }); } this.localDescription = { type: description.type, sdp: description.sdp }; switch (description.type) { case 'offer': this._updateSignalingState('have-local-offer'); break; case 'answer': this._updateSignalingState('stable'); break; default: throw new TypeError('unsupported type \"' + description.type + '\"'); } // If a success callback was provided, emit ICE candidates after it // has been executed. Otherwise, emit callback after the Promise is // resolved. var hasCallback = arguments.length &gt; 1 &amp;&amp; typeof arguments[1] === 'function'; if (hasCallback) { var cb = arguments[1]; window.setTimeout(function() { cb(); if (self.iceGatheringState === 'new') { self.iceGatheringState = 'gathering'; self._emitGatheringStateChange(); } self._emitBufferedCandidates(); }, 0); } var p = Promise.resolve(); p.then(function() { if (!hasCallback) { if (self.iceGatheringState === 'new') { self.iceGatheringState = 'gathering'; self._emitGatheringStateChange(); } // Usually candidates will be emitted earlier. window.setTimeout(self._emitBufferedCandidates.bind(self), 500); } }); return p; }; RTCPeerConnection.prototype.setRemoteDescription = function(description) { var self = this; if (!isActionAllowedInSignalingState('setRemoteDescription', description.type, this.signalingState)) { var e = new Error('Can not set remote ' + description.type + ' in state ' + this.signalingState); e.name = 'InvalidStateError'; if (arguments.length &gt; 2 &amp;&amp; typeof arguments[2] === 'function') { window.setTimeout(arguments[2], 0, e); } return Promise.reject(e); } var streams = {}; var receiverList = []; var sections = SDPUtils.splitSections(description.sdp); var sessionpart = sections.shift(); var isIceLite = SDPUtils.matchPrefix(sessionpart, 'a=ice-lite').length &gt; 0; var usingBundle = SDPUtils.matchPrefix(sessionpart, 'a=group:BUNDLE ').length &gt; 0; this.usingBundle = usingBundle; var iceOptions = SDPUtils.matchPrefix(sessionpart, 'a=ice-options:')[0]; if (iceOptions) { this.canTrickleIceCandidates = iceOptions.substr(14).split(' ') .indexOf('trickle') &gt;= 0; } else { this.canTrickleIceCandidates = false; } sections.forEach(function(mediaSection, sdpMLineIndex) { var lines = SDPUtils.splitLines(mediaSection); var kind = SDPUtils.getKind(mediaSection); var rejected = SDPUtils.isRejected(mediaSection); var protocol = lines[0].substr(2).split(' ')[2]; var direction = SDPUtils.getDirection(mediaSection, sessionpart); var remoteMsid = SDPUtils.parseMsid(mediaSection); var mid = SDPUtils.getMid(mediaSection) || SDPUtils.generateIdentifier(); // Reject datachannels which are not implemented yet. if (kind === 'application' &amp;&amp; protocol === 'DTLS/SCTP') { self.transceivers[sdpMLineIndex] = { mid: mid, isDatachannel: true }; return; } var transceiver; var iceGatherer; var iceTransport; var dtlsTransport; var rtpReceiver; var sendEncodingParameters; var recvEncodingParameters; var localCapabilities; var track; // FIXME: ensure the mediaSection has rtcp-mux set. var remoteCapabilities = SDPUtils.parseRtpParameters(mediaSection); var remoteIceParameters; var remoteDtlsParameters; if (!rejected) { remoteIceParameters = SDPUtils.getIceParameters(mediaSection, sessionpart); remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection, sessionpart); remoteDtlsParameters.role = 'client'; } recvEncodingParameters = SDPUtils.parseRtpEncodingParameters(mediaSection); var rtcpParameters = SDPUtils.parseRtcpParameters(mediaSection); var isComplete = SDPUtils.matchPrefix(mediaSection, 'a=end-of-candidates', sessionpart).length &gt; 0; var cands = SDPUtils.matchPrefix(mediaSection, 'a=candidate:') .map(function(cand) { return SDPUtils.parseCandidate(cand); }) .filter(function(cand) { return cand.component === '1' || cand.component === 1; }); if (description.type === 'offer' &amp;&amp; !rejected) { transceiver = self.transceivers[sdpMLineIndex] || self._createTransceiver(kind); transceiver.mid = mid; if (!transceiver.iceGatherer) { transceiver.iceGatherer = usingBundle &amp;&amp; sdpMLineIndex &gt; 0 ? self.transceivers[0].iceGatherer : self._createIceGatherer(mid, sdpMLineIndex); } if (isComplete &amp;&amp; (!usingBundle || sdpMLineIndex === 0)) { transceiver.iceTransport.setRemoteCandidates(cands); } localCapabilities = RTCRtpReceiver.getCapabilities(kind); // filter RTX until additional stuff needed for RTX is implemented // in adapter.js if (edgeVersion &lt; 15019) { localCapabilities.codecs = localCapabilities.codecs.filter( function(codec) { return codec.name !== 'rtx'; }); } sendEncodingParameters = [{ ssrc: (2 * sdpMLineIndex + 2) * 1001 }]; if (direction === 'sendrecv' || direction === 'sendonly') { rtpReceiver = new RTCRtpReceiver(transceiver.dtlsTransport, kind); track = rtpReceiver.track; // FIXME: does not work with Plan B. if (remoteMsid) { if (!streams[remoteMsid.stream]) { streams[remoteMsid.stream] = new MediaStream(); Object.defineProperty(streams[remoteMsid.stream], 'id', { get: function() { return remoteMsid.stream; } }); } Object.defineProperty(track, 'id', { get: function() { return remoteMsid.track; } }); streams[remoteMsid.stream].addTrack(track); receiverList.push([track, rtpReceiver, streams[remoteMsid.stream]]); } else { if (!streams.default) { streams.default = new MediaStream(); } streams.default.addTrack(track); receiverList.push([track, rtpReceiver, streams.default]); } } transceiver.localCapabilities = localCapabilities; transceiver.remoteCapabilities = remoteCapabilities; transceiver.rtpReceiver = rtpReceiver; transceiver.rtcpParameters = rtcpParameters; transceiver.sendEncodingParameters = sendEncodingParameters; transceiver.recvEncodingParameters = recvEncodingParameters; // Start the RTCRtpReceiver now. The RTPSender is started in // setLocalDescription. self._transceive(self.transceivers[sdpMLineIndex], false, direction === 'sendrecv' || direction === 'sendonly'); } else if (description.type === 'answer' &amp;&amp; !rejected) { if (usingBundle &amp;&amp; sdpMLineIndex &gt; 0) { self._disposeIceAndDtlsTransports(sdpMLineIndex); self.transceivers[sdpMLineIndex].iceGatherer = self.transceivers[0].iceGatherer; self.transceivers[sdpMLineIndex].iceTransport = self.transceivers[0].iceTransport; self.transceivers[sdpMLineIndex].dtlsTransport = self.transceivers[0].dtlsTransport; if (self.transceivers[sdpMLineIndex].rtpSender) { self.transceivers[sdpMLineIndex].rtpSender.setTransport( self.transceivers[0].dtlsTransport); } if (self.transceivers[sdpMLineIndex].rtpReceiver) { self.transceivers[sdpMLineIndex].rtpReceiver.setTransport( self.transceivers[0].dtlsTransport); } } transceiver = self.transceivers[sdpMLineIndex]; iceGatherer = transceiver.iceGatherer; iceTransport = transceiver.iceTransport; dtlsTransport = transceiver.dtlsTransport; rtpReceiver = transceiver.rtpReceiver; sendEncodingParameters = transceiver.sendEncodingParameters; localCapabilities = transceiver.localCapabilities; self.transceivers[sdpMLineIndex].recvEncodingParameters = recvEncodingParameters; self.transceivers[sdpMLineIndex].remoteCapabilities = remoteCapabilities; self.transceivers[sdpMLineIndex].rtcpParameters = rtcpParameters; if ((isIceLite || isComplete) &amp;&amp; cands.length) { iceTransport.setRemoteCandidates(cands); } if (!usingBundle || sdpMLineIndex === 0) { iceTransport.start(iceGatherer, remoteIceParameters, 'controlling'); dtlsTransport.start(remoteDtlsParameters); } self._transceive(transceiver, direction === 'sendrecv' || direction === 'recvonly', direction === 'sendrecv' || direction === 'sendonly'); if (rtpReceiver &amp;&amp; (direction === 'sendrecv' || direction === 'sendonly')) { track = rtpReceiver.track; if (remoteMsid) { if (!streams[remoteMsid.stream]) { streams[remoteMsid.stream] = new MediaStream(); } streams[remoteMsid.stream].addTrack(track); receiverList.push([track, rtpReceiver, streams[remoteMsid.stream]]); } else { if (!streams.default) { streams.default = new MediaStream(); } streams.default.addTrack(track); receiverList.push([track, rtpReceiver, streams.default]); } } else { // FIXME: actually the receiver should be created later. delete transceiver.rtpReceiver; } } }); this.remoteDescription = { type: description.type, sdp: description.sdp }; switch (description.type) { case 'offer': this._updateSignalingState('have-remote-offer'); break; case 'answer': this._updateSignalingState('stable'); break; default: throw new TypeError('unsupported type \"' + description.type + '\"'); } Object.keys(streams).forEach(function(sid) { var stream = streams[sid]; if (stream.getTracks().length) { self.remoteStreams.push(stream); var event = new Event('addstream'); event.stream = stream; self.dispatchEvent(event); if (self.onaddstream !== null) { window.setTimeout(function() { self.onaddstream(event); }, 0); } receiverList.forEach(function(item) { var track = item[0]; var receiver = item[1]; if (stream.id !== item[2].id) { return; } var trackEvent = new Event('track'); trackEvent.track = track; trackEvent.receiver = receiver; trackEvent.streams = [stream]; self.dispatchEvent(trackEvent); if (self.ontrack !== null) { window.setTimeout(function() { self.ontrack(trackEvent); }, 0); } }); } }); // check whether addIceCandidate({}) was called within four seconds after // setRemoteDescription. window.setTimeout(function() { if (!(self &amp;&amp; self.transceivers)) { return; } self.transceivers.forEach(function(transceiver) { if (transceiver.iceTransport &amp;&amp; transceiver.iceTransport.state === 'new' &amp;&amp; transceiver.iceTransport.getRemoteCandidates().length &gt; 0) { console.warn('Timeout for addRemoteCandidate. Consider sending ' + 'an end-of-candidates notification'); transceiver.iceTransport.addRemoteCandidate({}); } }); }, 4000); if (arguments.length &gt; 1 &amp;&amp; typeof arguments[1] === 'function') { window.setTimeout(arguments[1], 0); } return Promise.resolve(); }; RTCPeerConnection.prototype.close = function() { this.transceivers.forEach(function(transceiver) { /* not yet if (transceiver.iceGatherer) { transceiver.iceGatherer.close(); } */ if (transceiver.iceTransport) { transceiver.iceTransport.stop(); } if (transceiver.dtlsTransport) { transceiver.dtlsTransport.stop(); } if (transceiver.rtpSender) { transceiver.rtpSender.stop(); } if (transceiver.rtpReceiver) { transceiver.rtpReceiver.stop(); } }); // FIXME: clean up tracks, local streams, remote streams, etc this._updateSignalingState('closed'); }; // Update the signaling state. RTCPeerConnection.prototype._updateSignalingState = function(newState) { this.signalingState = newState; var event = new Event('signalingstatechange'); this.dispatchEvent(event); if (this.onsignalingstatechange !== null) { this.onsignalingstatechange(event); } }; // Determine whether to fire the negotiationneeded event. RTCPeerConnection.prototype._maybeFireNegotiationNeeded = function() { var self = this; if (this.signalingState !== 'stable' || this.needNegotiation === true) { return; } this.needNegotiation = true; window.setTimeout(function() { if (self.needNegotiation === false) { return; } self.needNegotiation = false; var event = new Event('negotiationneeded'); self.dispatchEvent(event); if (self.onnegotiationneeded !== null) { self.onnegotiationneeded(event); } }, 0); }; // Update the connection state. RTCPeerConnection.prototype._updateConnectionState = function() { var self = this; var newState; var states = { 'new': 0, closed: 0, connecting: 0, checking: 0, connected: 0, completed: 0, failed: 0 }; this.transceivers.forEach(function(transceiver) { states[transceiver.iceTransport.state]++; states[transceiver.dtlsTransport.state]++; }); // ICETransport.completed and connected are the same for this purpose. states.connected += states.completed; newState = 'new'; if (states.failed &gt; 0) { newState = 'failed'; } else if (states.connecting &gt; 0 || states.checking &gt; 0) { newState = 'connecting'; } else if (states.disconnected &gt; 0) { newState = 'disconnected'; } else if (states.new &gt; 0) { newState = 'new'; } else if (states.connected &gt; 0 || states.completed &gt; 0) { newState = 'connected'; } if (newState !== self.iceConnectionState) { self.iceConnectionState = newState; var event = new Event('iceconnectionstatechange'); this.dispatchEvent(event); if (this.oniceconnectionstatechange !== null) { this.oniceconnectionstatechange(event); } } }; RTCPeerConnection.prototype.createOffer = function() { var self = this; if (this._pendingOffer) { throw new Error('createOffer called while there is a pending offer.'); } var offerOptions; if (arguments.length === 1 &amp;&amp; typeof arguments[0] !== 'function') { offerOptions = arguments[0]; } else if (arguments.length === 3) { offerOptions = arguments[2]; } var numAudioTracks = this.transceivers.filter(function(t) { return t.kind === 'audio'; }).length; var numVideoTracks = this.transceivers.filter(function(t) { return t.kind === 'video'; }).length; // Determine number of audio and video tracks we need to send/recv. if (offerOptions) { // Reject Chrome legacy constraints. if (offerOptions.mandatory || offerOptions.optional) { throw new TypeError( 'Legacy mandatory/optional constraints not supported.'); } if (offerOptions.offerToReceiveAudio !== undefined) { if (offerOptions.offerToReceiveAudio === true) { numAudioTracks = 1; } else if (offerOptions.offerToReceiveAudio === false) { numAudioTracks = 0; } else { numAudioTracks = offerOptions.offerToReceiveAudio; } } if (offerOptions.offerToReceiveVideo !== undefined) { if (offerOptions.offerToReceiveVideo === true) { numVideoTracks = 1; } else if (offerOptions.offerToReceiveVideo === false) { numVideoTracks = 0; } else { numVideoTracks = offerOptions.offerToReceiveVideo; } } } this.transceivers.forEach(function(transceiver) { if (transceiver.kind === 'audio') { numAudioTracks--; if (numAudioTracks &lt; 0) { transceiver.wantReceive = false; } } else if (transceiver.kind === 'video') { numVideoTracks--; if (numVideoTracks &lt; 0) { transceiver.wantReceive = false; } } }); // Create M-lines for recvonly streams. while (numAudioTracks &gt; 0 || numVideoTracks &gt; 0) { if (numAudioTracks &gt; 0) { this._createTransceiver('audio'); numAudioTracks--; } if (numVideoTracks &gt; 0) { this._createTransceiver('video'); numVideoTracks--; } } // reorder tracks var transceivers = sortTracks(this.transceivers); var sdp = SDPUtils.writeSessionBoilerplate(); transceivers.forEach(function(transceiver, sdpMLineIndex) { // For each track, create an ice gatherer, ice transport, // dtls transport, potentially rtpsender and rtpreceiver. var track = transceiver.track; var kind = transceiver.kind; var mid = SDPUtils.generateIdentifier(); transceiver.mid = mid; if (!transceiver.iceGatherer) { transceiver.iceGatherer = self.usingBundle &amp;&amp; sdpMLineIndex &gt; 0 ? transceivers[0].iceGatherer : self._createIceGatherer(mid, sdpMLineIndex); } var localCapabilities = RTCRtpSender.getCapabilities(kind); // filter RTX until additional stuff needed for RTX is implemented // in adapter.js if (edgeVersion &lt; 15019) { localCapabilities.codecs = localCapabilities.codecs.filter( function(codec) { return codec.name !== 'rtx'; }); } localCapabilities.codecs.forEach(function(codec) { // work around https://bugs.chromium.org/p/webrtc/issues/detail?id=6552 // by adding level-asymmetry-allowed=1 if (codec.name === 'H264' &amp;&amp; codec.parameters['level-asymmetry-allowed'] === undefined) { codec.parameters['level-asymmetry-allowed'] = '1'; } }); // generate an ssrc now, to be used later in rtpSender.send var sendEncodingParameters = [{ ssrc: (2 * sdpMLineIndex + 1) * 1001 }]; if (track) { // add RTX if (edgeVersion &gt;= 15019 &amp;&amp; kind === 'video') { sendEncodingParameters[0].rtx = { ssrc: (2 * sdpMLineIndex + 1) * 1001 + 1 }; } } if (transceiver.wantReceive) { transceiver.rtpReceiver = new RTCRtpReceiver(transceiver.dtlsTransport, kind); } transceiver.localCapabilities = localCapabilities; transceiver.sendEncodingParameters = sendEncodingParameters; }); // always offer BUNDLE and dispose on return if not supported. if (this._config.bundlePolicy !== 'max-compat') { sdp += 'a=group:BUNDLE ' + transceivers.map(function(t) { return t.mid; }).join(' ') + '\\r\\n'; } sdp += 'a=ice-options:trickle\\r\\n'; transceivers.forEach(function(transceiver, sdpMLineIndex) { sdp += SDPUtils.writeMediaSection(transceiver, transceiver.localCapabilities, 'offer', transceiver.stream); sdp += 'a=rtcp-rsize\\r\\n'; }); this._pendingOffer = transceivers; var desc = new RTCSessionDescription({ type: 'offer', sdp: sdp }); if (arguments.length &amp;&amp; typeof arguments[0] === 'function') { window.setTimeout(arguments[0], 0, desc); } return Promise.resolve(desc); }; RTCPeerConnection.prototype.createAnswer = function() { var sdp = SDPUtils.writeSessionBoilerplate(); if (this.usingBundle) { sdp += 'a=group:BUNDLE ' + this.transceivers.map(function(t) { return t.mid; }).join(' ') + '\\r\\n'; } this.transceivers.forEach(function(transceiver, sdpMLineIndex) { if (transceiver.isDatachannel) { sdp += 'm=application 0 DTLS/SCTP 5000\\r\\n' + 'c=IN IP4 0.0.0.0\\r\\n' + 'a=mid:' + transceiver.mid + '\\r\\n'; return; } // FIXME: look at direction. if (transceiver.stream) { var localTrack; if (transceiver.kind === 'audio') { localTrack = transceiver.stream.getAudioTracks()[0]; } else if (transceiver.kind === 'video') { localTrack = transceiver.stream.getVideoTracks()[0]; } if (localTrack) { // add RTX if (edgeVersion &gt;= 15019 &amp;&amp; transceiver.kind === 'video') { transceiver.sendEncodingParameters[0].rtx = { ssrc: (2 * sdpMLineIndex + 2) * 1001 + 1 }; } } } // Calculate intersection of capabilities. var commonCapabilities = getCommonCapabilities( transceiver.localCapabilities, transceiver.remoteCapabilities); var hasRtx = commonCapabilities.codecs.filter(function(c) { return c.name.toLowerCase() === 'rtx'; }).length; if (!hasRtx &amp;&amp; transceiver.sendEncodingParameters[0].rtx) { delete transceiver.sendEncodingParameters[0].rtx; } sdp += SDPUtils.writeMediaSection(transceiver, commonCapabilities, 'answer', transceiver.stream); if (transceiver.rtcpParameters &amp;&amp; transceiver.rtcpParameters.reducedSize) { sdp += 'a=rtcp-rsize\\r\\n'; } }); var desc = new RTCSessionDescription({ type: 'answer', sdp: sdp }); if (arguments.length &amp;&amp; typeof arguments[0] === 'function') { window.setTimeout(arguments[0], 0, desc); } return Promise.resolve(desc); }; RTCPeerConnection.prototype.addIceCandidate = function(candidate) { if (!candidate) { for (var j = 0; j &lt; this.transceivers.length; j++) { this.transceivers[j].iceTransport.addRemoteCandidate({}); if (this.usingBundle) { return Promise.resolve(); } } } else { var mLineIndex = candidate.sdpMLineIndex; if (candidate.sdpMid) { for (var i = 0; i &lt; this.transceivers.length; i++) { if (this.transceivers[i].mid === candidate.sdpMid) { mLineIndex = i; break; } } } var transceiver = this.transceivers[mLineIndex]; if (transceiver) { var cand = Object.keys(candidate.candidate).length &gt; 0 ? SDPUtils.parseCandidate(candidate.candidate) : {}; // Ignore Chrome's invalid candidates since Edge does not like them. if (cand.protocol === 'tcp' &amp;&amp; (cand.port === 0 || cand.port === 9)) { return Promise.resolve(); } // Ignore RTCP candidates, we assume RTCP-MUX. if (cand.component &amp;&amp; !(cand.component === '1' || cand.component === 1)) { return Promise.resolve(); } transceiver.iceTransport.addRemoteCandidate(cand); // update the remoteDescription. var sections = SDPUtils.splitSections(this.remoteDescription.sdp); sections[mLineIndex + 1] += (cand.type ? candidate.candidate.trim() : 'a=end-of-candidates') + '\\r\\n'; this.remoteDescription.sdp = sections.join(''); } } if (arguments.length &gt; 1 &amp;&amp; typeof arguments[1] === 'function') { window.setTimeout(arguments[1], 0); } return Promise.resolve(); }; RTCPeerConnection.prototype.getStats = function() { var promises = []; this.transceivers.forEach(function(transceiver) { ['rtpSender', 'rtpReceiver', 'iceGatherer', 'iceTransport', 'dtlsTransport'].forEach(function(method) { if (transceiver[method]) { promises.push(transceiver[method].getStats()); } }); }); var cb = arguments.length &gt; 1 &amp;&amp; typeof arguments[1] === 'function' &amp;&amp; arguments[1]; var fixStatsType = function(stat) { return { inboundrtp: 'inbound-rtp', outboundrtp: 'outbound-rtp', candidatepair: 'candidate-pair', localcandidate: 'local-candidate', remotecandidate: 'remote-candidate' }[stat.type] || stat.type; }; return new Promise(function(resolve) { // shim getStats with maplike support var results = new Map(); Promise.all(promises).then(function(res) { res.forEach(function(result) { Object.keys(result).forEach(function(id) { result[id].type = fixStatsType(result[id]); results.set(id, result[id]); }); }); if (cb) { window.setTimeout(cb, 0, results); } resolve(results); }); }); }; return RTCPeerConnection; }; },{\"sdp\":1}],8:[function(require,module,exports){ /* * Copyright (c) 2016 The WebRTC project authors. All Rights Reserved. * * Use of this source code is governed by a BSD-style license * that can be found in the LICENSE file in the root of the source * tree. */ /* eslint-env node */ 'use strict'; var browserDetails = require('../utils').browserDetails; var firefoxShim = { shimOnTrack: function() { if (typeof window === 'object' &amp;&amp; window.RTCPeerConnection &amp;&amp; !('ontrack' in window.RTCPeerConnection.prototype)) { Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', { get: function() { return this._ontrack; }, set: function(f) { if (this._ontrack) { this.removeEventListener('track', this._ontrack); this.removeEventListener('addstream', this._ontrackpoly); } this.addEventListener('track', this._ontrack = f); this.addEventListener('addstream', this._ontrackpoly = function(e) { e.stream.getTracks().forEach(function(track) { var event = new Event('track'); event.track = track; event.receiver = {track: track}; event.streams = [e.stream]; this.dispatchEvent(event); }.bind(this)); }.bind(this)); } }); } }, shimSourceObject: function() { // Firefox has supported mozSrcObject since FF22, unprefixed in 42. if (typeof window === 'object') { if (window.HTMLMediaElement &amp;&amp; !('srcObject' in window.HTMLMediaElement.prototype)) { // Shim the srcObject property, once, when HTMLMediaElement is found. Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', { get: function() { return this.mozSrcObject; }, set: function(stream) { this.mozSrcObject = stream; } }); } } }, shimPeerConnection: function() { if (typeof window !== 'object' || !(window.RTCPeerConnection || window.mozRTCPeerConnection)) { return; // probably media.peerconnection.enabled=false in about:config } // The RTCPeerConnection object. if (!window.RTCPeerConnection) { window.RTCPeerConnection = function(pcConfig, pcConstraints) { if (browserDetails.version &lt; 38) { // .urls is not supported in FF &lt; 38. // create RTCIceServers with a single url. if (pcConfig &amp;&amp; pcConfig.iceServers) { var newIceServers = []; for (var i = 0; i &lt; pcConfig.iceServers.length; i++) { var server = pcConfig.iceServers[i]; if (server.hasOwnProperty('urls')) { for (var j = 0; j &lt; server.urls.length; j++) { var newServer = { url: server.urls[j] }; if (server.urls[j].indexOf('turn') === 0) { newServer.username = server.username; newServer.credential = server.credential; } newIceServers.push(newServer); } } else { newIceServers.push(pcConfig.iceServers[i]); } } pcConfig.iceServers = newIceServers; } } return new mozRTCPeerConnection(pcConfig, pcConstraints); }; window.RTCPeerConnection.prototype = mozRTCPeerConnection.prototype; // wrap static methods. Currently just generateCertificate. if (mozRTCPeerConnection.generateCertificate) { Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', { get: function() { return mozRTCPeerConnection.generateCertificate; } }); } window.RTCSessionDescription = mozRTCSessionDescription; window.RTCIceCandidate = mozRTCIceCandidate; } // shim away need for obsolete RTCIceCandidate/RTCSessionDescription. ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'] .forEach(function(method) { var nativeMethod = RTCPeerConnection.prototype[method]; RTCPeerConnection.prototype[method] = function() { arguments[0] = new ((method === 'addIceCandidate') ? RTCIceCandidate : RTCSessionDescription)(arguments[0]); return nativeMethod.apply(this, arguments); }; }); // support for addIceCandidate(null or undefined) var nativeAddIceCandidate = RTCPeerConnection.prototype.addIceCandidate; RTCPeerConnection.prototype.addIceCandidate = function() { if (!arguments[0]) { if (arguments[1]) { arguments[1].apply(null); } return Promise.resolve(); } return nativeAddIceCandidate.apply(this, arguments); }; // shim getStats with maplike support var makeMapStats = function(stats) { var map = new Map(); Object.keys(stats).forEach(function(key) { map.set(key, stats[key]); map[key] = stats[key]; }); return map; }; var modernStatsTypes = { inboundrtp: 'inbound-rtp', outboundrtp: 'outbound-rtp', candidatepair: 'candidate-pair', localcandidate: 'local-candidate', remotecandidate: 'remote-candidate' }; var nativeGetStats = RTCPeerConnection.prototype.getStats; RTCPeerConnection.prototype.getStats = function(selector, onSucc, onErr) { return nativeGetStats.apply(this, [selector || null]) .then(function(stats) { if (browserDetails.version &lt; 48) { stats = makeMapStats(stats); } if (browserDetails.version &lt; 53 &amp;&amp; !onSucc) { // Shim only promise getStats with spec-hyphens in type names // Leave callback version alone; misc old uses of forEach before Map try { stats.forEach(function(stat) { stat.type = modernStatsTypes[stat.type] || stat.type; }); } catch (e) { if (e.name !== 'TypeError') { throw e; } // Avoid TypeError: \"type\" is read-only, in old versions. 34-43ish stats.forEach(function(stat, i) { stats.set(i, Object.assign({}, stat, { type: modernStatsTypes[stat.type] || stat.type })); }); } } return stats; }) .then(onSucc, onErr); }; } }; // Expose public methods. module.exports = { shimOnTrack: firefoxShim.shimOnTrack, shimSourceObject: firefoxShim.shimSourceObject, shimPeerConnection: firefoxShim.shimPeerConnection, shimGetUserMedia: require('./getusermedia') }; },{\"../utils\":11,\"./getusermedia\":9}],9:[function(require,module,exports){ /* * Copyright (c) 2016 The WebRTC project authors. All Rights Reserved. * * Use of this source code is governed by a BSD-style license * that can be found in the LICENSE file in the root of the source * tree. */ /* eslint-env node */ 'use strict'; var logging = require('../utils').log; var browserDetails = require('../utils').browserDetails; // Expose public methods. module.exports = function() { var shimError_ = function(e) { return { name: { InternalError: 'NotReadableError', NotSupportedError: 'TypeError', PermissionDeniedError: 'NotAllowedError', SecurityError: 'NotAllowedError' }[e.name] || e.name, message: { 'The operation is insecure.': 'The request is not allowed by the ' + 'user agent or the platform in the current context.' }[e.message] || e.message, constraint: e.constraint, toString: function() { return this.name + (this.message &amp;&amp; ': ') + this.message; } }; }; // getUserMedia constraints shim. var getUserMedia_ = function(constraints, onSuccess, onError) { var constraintsToFF37_ = function(c) { if (typeof c !== 'object' || c.require) { return c; } var require = []; Object.keys(c).forEach(function(key) { if (key === 'require' || key === 'advanced' || key === 'mediaSource') { return; } var r = c[key] = (typeof c[key] === 'object') ? c[key] : {ideal: c[key]}; if (r.min !== undefined || r.max !== undefined || r.exact !== undefined) { require.push(key); } if (r.exact !== undefined) { if (typeof r.exact === 'number') { r. min = r.max = r.exact; } else { c[key] = r.exact; } delete r.exact; } if (r.ideal !== undefined) { c.advanced = c.advanced || []; var oc = {}; if (typeof r.ideal === 'number') { oc[key] = {min: r.ideal, max: r.ideal}; } else { oc[key] = r.ideal; } c.advanced.push(oc); delete r.ideal; if (!Object.keys(r).length) { delete c[key]; } } }); if (require.length) { c.require = require; } return c; }; constraints = JSON.parse(JSON.stringify(constraints)); if (browserDetails.version &lt; 38) { logging('spec: ' + JSON.stringify(constraints)); if (constraints.audio) { constraints.audio = constraintsToFF37_(constraints.audio); } if (constraints.video) { constraints.video = constraintsToFF37_(constraints.video); } logging('ff37: ' + JSON.stringify(constraints)); } return navigator.mozGetUserMedia(constraints, onSuccess, function(e) { onError(shimError_(e)); }); }; // Returns the result of getUserMedia as a Promise. var getUserMediaPromise_ = function(constraints) { return new Promise(function(resolve, reject) { getUserMedia_(constraints, resolve, reject); }); }; // Shim for mediaDevices on older versions. if (!navigator.mediaDevices) { navigator.mediaDevices = {getUserMedia: getUserMediaPromise_, addEventListener: function() { }, removeEventListener: function() { } }; } navigator.mediaDevices.enumerateDevices = navigator.mediaDevices.enumerateDevices || function() { return new Promise(function(resolve) { var infos = [ {kind: 'audioinput', deviceId: 'default', label: '', groupId: ''}, {kind: 'videoinput', deviceId: 'default', label: '', groupId: ''} ]; resolve(infos); }); }; if (browserDetails.version &lt; 41) { // Work around http://bugzil.la/1169665 var orgEnumerateDevices = navigator.mediaDevices.enumerateDevices.bind(navigator.mediaDevices); navigator.mediaDevices.enumerateDevices = function() { return orgEnumerateDevices().then(undefined, function(e) { if (e.name === 'NotFoundError') { return []; } throw e; }); }; } if (browserDetails.version &lt; 49) { var origGetUserMedia = navigator.mediaDevices.getUserMedia. bind(navigator.mediaDevices); navigator.mediaDevices.getUserMedia = function(c) { return origGetUserMedia(c).then(function(stream) { // Work around https://bugzil.la/802326 if (c.audio &amp;&amp; !stream.getAudioTracks().length || c.video &amp;&amp; !stream.getVideoTracks().length) { stream.getTracks().forEach(function(track) { track.stop(); }); throw new DOMException('The object can not be found here.', 'NotFoundError'); } return stream; }, function(e) { return Promise.reject(shimError_(e)); }); }; } navigator.getUserMedia = function(constraints, onSuccess, onError) { if (browserDetails.version &lt; 44) { return getUserMedia_(constraints, onSuccess, onError); } // Replace Firefox 44+'s deprecation warning with unprefixed version. console.warn('navigator.getUserMedia has been replaced by ' + 'navigator.mediaDevices.getUserMedia'); navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError); }; }; },{\"../utils\":11}],10:[function(require,module,exports){ /* * Copyright (c) 2016 The WebRTC project authors. All Rights Reserved. * * Use of this source code is governed by a BSD-style license * that can be found in the LICENSE file in the root of the source * tree. */ 'use strict'; var safariShim = { // TODO: DrAlex, should be here, double check against LayoutTests // TODO: once the back-end for the mac port is done, add. // TODO: check for webkitGTK+ // shimPeerConnection: function() { }, shimAddStream: function() { if (typeof window === 'object' &amp;&amp; window.RTCPeerConnection &amp;&amp; !('addStream' in window.RTCPeerConnection.prototype)) { RTCPeerConnection.prototype.addStream = function(stream) { var self = this; stream.getTracks().forEach(function(track) { self.addTrack(track, stream); }); }; } }, shimOnAddStream: function() { if (typeof window === 'object' &amp;&amp; window.RTCPeerConnection &amp;&amp; !('onaddstream' in window.RTCPeerConnection.prototype)) { Object.defineProperty(window.RTCPeerConnection.prototype, 'onaddstream', { get: function() { return this._onaddstream; }, set: function(f) { if (this._onaddstream) { this.removeEventListener('addstream', this._onaddstream); this.removeEventListener('track', this._onaddstreampoly); } this.addEventListener('addstream', this._onaddstream = f); this.addEventListener('track', this._onaddstreampoly = function(e) { var stream = e.streams[0]; if (!this._streams) { this._streams = []; } if (this._streams.indexOf(stream) &gt;= 0) { return; } this._streams.push(stream); var event = new Event('addstream'); event.stream = e.streams[0]; this.dispatchEvent(event); }.bind(this)); } }); } }, shimCallbacksAPI: function() { if (typeof window !== 'object' || !window.RTCPeerConnection) { return; } var prototype = RTCPeerConnection.prototype; var createOffer = prototype.createOffer; var createAnswer = prototype.createAnswer; var setLocalDescription = prototype.setLocalDescription; var setRemoteDescription = prototype.setRemoteDescription; var addIceCandidate = prototype.addIceCandidate; prototype.createOffer = function(successCallback, failureCallback) { var options = (arguments.length &gt;= 2) ? arguments[2] : arguments[0]; var promise = createOffer.apply(this, [options]); if (!failureCallback) { return promise; } promise.then(successCallback, failureCallback); return Promise.resolve(); }; prototype.createAnswer = function(successCallback, failureCallback) { var options = (arguments.length &gt;= 2) ? arguments[2] : arguments[0]; var promise = createAnswer.apply(this, [options]); if (!failureCallback) { return promise; } promise.then(successCallback, failureCallback); return Promise.resolve(); }; var withCallback = function(description, successCallback, failureCallback) { var promise = setLocalDescription.apply(this, [description]); if (!failureCallback) { return promise; } promise.then(successCallback, failureCallback); return Promise.resolve(); }; prototype.setLocalDescription = withCallback; withCallback = function(description, successCallback, failureCallback) { var promise = setRemoteDescription.apply(this, [description]); if (!failureCallback) { return promise; } promise.then(successCallback, failureCallback); return Promise.resolve(); }; prototype.setRemoteDescription = withCallback; withCallback = function(candidate, successCallback, failureCallback) { var promise = addIceCandidate.apply(this, [candidate]); if (!failureCallback) { return promise; } promise.then(successCallback, failureCallback); return Promise.resolve(); }; prototype.addIceCandidate = withCallback; }, shimGetUserMedia: function() { if (!navigator.getUserMedia) { if (navigator.webkitGetUserMedia) { navigator.getUserMedia = navigator.webkitGetUserMedia.bind(navigator); } else if (navigator.mediaDevices &amp;&amp; navigator.mediaDevices.getUserMedia) { navigator.getUserMedia = function(constraints, cb, errcb) { navigator.mediaDevices.getUserMedia(constraints) .then(cb, errcb); }.bind(navigator); } } } }; // Expose public methods. module.exports = { shimCallbacksAPI: safariShim.shimCallbacksAPI, shimAddStream: safariShim.shimAddStream, shimOnAddStream: safariShim.shimOnAddStream, shimGetUserMedia: safariShim.shimGetUserMedia // TODO // shimPeerConnection: safariShim.shimPeerConnection }; },{}],11:[function(require,module,exports){ /* * Copyright (c) 2016 The WebRTC project authors. All Rights Reserved. * * Use of this source code is governed by a BSD-style license * that can be found in the LICENSE file in the root of the source * tree. */ /* eslint-env node */ 'use strict'; var logDisabled_ = true; // Utility methods. var utils = { disableLog: function(bool) { if (typeof bool !== 'boolean') { return new Error('Argument type: ' + typeof bool + '. Please use a boolean.'); } logDisabled_ = bool; return (bool) ? 'adapter.js logging disabled' : 'adapter.js logging enabled'; }, log: function() { if (typeof window === 'object') { if (logDisabled_) { return; } if (typeof console !== 'undefined' &amp;&amp; typeof console.log === 'function') { console.log.apply(console, arguments); } } }, /** * Extract browser version out of the provided user agent string. * * @param {!string} uastring userAgent string. * @param {!string} expr Regular expression used as match criteria. * @param {!number} pos position in the version string to be returned. * @return {!number} browser version. */ extractVersion: function(uastring, expr, pos) { var match = uastring.match(expr); return match &amp;&amp; match.length &gt;= pos &amp;&amp; parseInt(match[pos], 10); }, /** * Browser detector. * * @return {object} result containing browser and version * properties. */ detectBrowser: function() { // Returned result object. var result = {}; result.browser = null; result.version = null; // Fail early if it's not a browser if (typeof window === 'undefined' || !window.navigator) { result.browser = 'Not a browser.'; return result; } // Firefox. if (navigator.mozGetUserMedia) { result.browser = 'firefox'; result.version = this.extractVersion(navigator.userAgent, /Firefox\\/(\\d+)\\./, 1); } else if (navigator.webkitGetUserMedia) { // Chrome, Chromium, Webview, Opera, all use the chrome shim for now if (window.webkitRTCPeerConnection) { result.browser = 'chrome'; result.version = this.extractVersion(navigator.userAgent, /Chrom(e|ium)\\/(\\d+)\\./, 2); } else { // Safari (in an unpublished version) or unknown webkit-based. if (navigator.userAgent.match(/Version\\/(\\d+).(\\d+)/)) { result.browser = 'safari'; result.version = this.extractVersion(navigator.userAgent, /AppleWebKit\\/(\\d+)\\./, 1); } else { // unknown webkit-based browser. result.browser = 'Unsupported webkit-based browser ' + 'with GUM support but no WebRTC support.'; return result; } } } else if (navigator.mediaDevices &amp;&amp; navigator.userAgent.match(/Edge\\/(\\d+).(\\d+)$/)) { // Edge. result.browser = 'edge'; result.version = this.extractVersion(navigator.userAgent, /Edge\\/(\\d+).(\\d+)$/, 2); } else if (navigator.mediaDevices &amp;&amp; navigator.userAgent.match(/AppleWebKit\\/(\\d+)\\./)) { // Safari, with webkitGetUserMedia removed. result.browser = 'safari'; result.version = this.extractVersion(navigator.userAgent, /AppleWebKit\\/(\\d+)\\./, 1); } else { // Default fallthrough: not supported. result.browser = 'Not a supported browser.'; return result; } return result; }, // shimCreateObjectURL must be called before shimSourceObject to avoid loop. shimCreateObjectURL: function() { if (!(typeof window === 'object' &amp;&amp; window.HTMLMediaElement &amp;&amp; 'srcObject' in window.HTMLMediaElement.prototype)) { // Only shim CreateObjectURL using srcObject if srcObject exists. return undefined; } var nativeCreateObjectURL = URL.createObjectURL.bind(URL); var nativeRevokeObjectURL = URL.revokeObjectURL.bind(URL); var streams = new Map(), newId = 0; URL.createObjectURL = function(stream) { if ('getTracks' in stream) { var url = 'polyblob:' + (++newId); streams.set(url, stream); console.log('URL.createObjectURL(stream) is deprecated! ' + 'Use elem.srcObject = stream instead!'); return url; } return nativeCreateObjectURL(stream); }; URL.revokeObjectURL = function(url) { nativeRevokeObjectURL(url); streams.delete(url); }; var dsc = Object.getOwnPropertyDescriptor(window.HTMLMediaElement.prototype, 'src'); Object.defineProperty(window.HTMLMediaElement.prototype, 'src', { get: function() { return dsc.get.apply(this); }, set: function(url) { this.srcObject = streams.get(url) || null; return dsc.set.apply(this, [url]); } }); var nativeSetAttribute = HTMLMediaElement.prototype.setAttribute; HTMLMediaElement.prototype.setAttribute = function() { if (arguments.length === 2 &amp;&amp; ('' + arguments[0]).toLowerCase() === 'src') { this.srcObject = streams.get(arguments[1]) || null; } return nativeSetAttribute.apply(this, arguments); }; } }; // Export. module.exports = { log: utils.log, disableLog: utils.disableLog, browserDetails: utils.detectBrowser(), extractVersion: utils.extractVersion, shimCreateObjectURL: utils.shimCreateObjectURL, detectBrowser: utils.detectBrowser.bind(utils) }; },{}]},{},[2]); × Search results Close "},"cordova-plugin-battery-status_www_battery.js.html":{"id":"cordova-plugin-battery-status_www_battery.js.html","title":"Source: cordova-plugin-battery-status/www/battery.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: cordova-plugin-battery-status/www/battery.js /* * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. * */ var cordova = require('cordova'); var exec = require('cordova/exec'); var STATUS_CRITICAL = 5; var STATUS_LOW = 20; /** * This class contains information about the current battery status. * @constructor */ var Battery = function () { this._level = null; this._isPlugged = null; // Create new event handlers on the window (returns a channel instance) this.channels = { batterystatus: cordova.addWindowEventHandler('batterystatus'), batterylow: cordova.addWindowEventHandler('batterylow'), batterycritical: cordova.addWindowEventHandler('batterycritical') }; for (var key in this.channels) { this.channels[key].onHasSubscribersChange = Battery.onHasSubscribersChange; } }; function handlers () { return battery.channels.batterystatus.numHandlers + battery.channels.batterylow.numHandlers + battery.channels.batterycritical.numHandlers; } /** * Event handlers for when callbacks get registered for the battery. * Keep track of how many handlers we have so we can start and stop the native battery listener * appropriately (and hopefully save on battery life!). */ Battery.onHasSubscribersChange = function () { // If we just registered the first handler, make sure native listener is started. if (this.numHandlers === 1 &amp;&amp; handlers() === 1) { exec(battery._status, battery._error, 'Battery', 'start', []); } else if (handlers() === 0) { exec(null, null, 'Battery', 'stop', []); } }; /** * Callback for battery status * * @param {Object} info keys: level, isPlugged */ Battery.prototype._status = function (info) { if (info) { if (battery._level !== info.level || battery._isPlugged !== info.isPlugged) { if (info.level === null &amp;&amp; battery._level !== null) { return; // special case where callback is called because we stopped listening to the native side. } // Something changed. Fire batterystatus event cordova.fireWindowEvent('batterystatus', info); if (!info.isPlugged) { // do not fire low/critical if we are charging. issue: CB-4520 // note the following are NOT exact checks, as we want to catch a transition from // above the threshold to below. issue: CB-4519 if (battery._level &gt; STATUS_CRITICAL &amp;&amp; info.level &lt;= STATUS_CRITICAL) { // Fire critical battery event cordova.fireWindowEvent('batterycritical', info); } else if (battery._level &gt; STATUS_LOW &amp;&amp; info.level &lt;= STATUS_LOW) { // Fire low battery event cordova.fireWindowEvent('batterylow', info); } } battery._level = info.level; battery._isPlugged = info.isPlugged; } } }; /** * Error callback for battery start */ Battery.prototype._error = function (e) { console.log('Error initializing Battery: ' + e); }; var battery = new Battery(); // jshint ignore:line module.exports = battery; × Search results Close "},"cordova-plugin-camera_www_ios_CameraPopoverHandle.js.html":{"id":"cordova-plugin-camera_www_ios_CameraPopoverHandle.js.html","title":"Source: cordova-plugin-camera/www/ios/CameraPopoverHandle.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: cordova-plugin-camera/www/ios/CameraPopoverHandle.js /* * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. * */ var exec = require('cordova/exec'); /** * A handle to an image picker popover. * * __Supported Platforms__ * * - iOS * * @example * navigator.camera.getPicture(onSuccess, onFail, * { * destinationType: Camera.DestinationType.FILE_URI, * sourceType: Camera.PictureSourceType.PHOTOLIBRARY, * popoverOptions: new CameraPopoverOptions(300, 300, 100, 100, Camera.PopoverArrowDirection.ARROW_ANY, 300, 600) * }); * * // Reposition the popover if the orientation changes. * window.onorientationchange = function() { * var cameraPopoverHandle = new CameraPopoverHandle(); * var cameraPopoverOptions = new CameraPopoverOptions(0, 0, 100, 100, Camera.PopoverArrowDirection.ARROW_ANY, 400, 500); * cameraPopoverHandle.setPosition(cameraPopoverOptions); * } * @module CameraPopoverHandle */ var CameraPopoverHandle = function () { /** * Can be used to reposition the image selection dialog, * for example, when the device orientation changes. * @memberof CameraPopoverHandle * @instance * @method setPosition * @param {module:CameraPopoverOptions} popoverOptions */ this.setPosition = function (popoverOptions) { var args = [ popoverOptions ]; exec(null, null, 'Camera', 'repositionPopover', args); }; }; module.exports = CameraPopoverHandle; × Search results Close "},"cordova-plugin-media-capture_www_CaptureAudioOptions.js.html":{"id":"cordova-plugin-media-capture_www_CaptureAudioOptions.js.html","title":"Source: cordova-plugin-media-capture/www/CaptureAudioOptions.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: cordova-plugin-media-capture/www/CaptureAudioOptions.js /* * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. * */ /** * Encapsulates all audio capture operation configuration options. */ var CaptureAudioOptions = function () { // Upper limit of sound clips user can record. Value must be equal or greater than 1. this.limit = 1; // Maximum duration of a single sound clip in seconds. this.duration = 0; }; module.exports = CaptureAudioOptions; × Search results Close "},"cordova-plugin-media-capture_www_CaptureError.js.html":{"id":"cordova-plugin-media-capture_www_CaptureError.js.html","title":"Source: cordova-plugin-media-capture/www/CaptureError.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: cordova-plugin-media-capture/www/CaptureError.js /* * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. * */ /** * The CaptureError interface encapsulates all errors in the Capture API. */ var CaptureError = function (c) { this.code = c || null; }; // Camera or microphone failed to capture image or sound. CaptureError.CAPTURE_INTERNAL_ERR = 0; // Camera application or audio capture application is currently serving other capture request. CaptureError.CAPTURE_APPLICATION_BUSY = 1; // Invalid use of the API (e.g. limit parameter has value less than one). CaptureError.CAPTURE_INVALID_ARGUMENT = 2; // User exited camera application or audio capture application before capturing anything. CaptureError.CAPTURE_NO_MEDIA_FILES = 3; // User denied permissions required to perform the capture request. CaptureError.CAPTURE_PERMISSION_DENIED = 4; // The requested capture operation is not supported. CaptureError.CAPTURE_NOT_SUPPORTED = 20; module.exports = CaptureError; × Search results Close "},"cordova-plugin-media-capture_www_CaptureImageOptions.js.html":{"id":"cordova-plugin-media-capture_www_CaptureImageOptions.js.html","title":"Source: cordova-plugin-media-capture/www/CaptureImageOptions.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: cordova-plugin-media-capture/www/CaptureImageOptions.js /* * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. * */ /** * Encapsulates all image capture operation configuration options. */ var CaptureImageOptions = function () { // Upper limit of images user can take. Value must be equal or greater than 1. this.limit = 1; }; module.exports = CaptureImageOptions; × Search results Close "},"cordova-plugin-media-capture_www_CaptureVideoOptions.js.html":{"id":"cordova-plugin-media-capture_www_CaptureVideoOptions.js.html","title":"Source: cordova-plugin-media-capture/www/CaptureVideoOptions.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: cordova-plugin-media-capture/www/CaptureVideoOptions.js /* * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. * */ /** * Encapsulates all video capture operation configuration options. */ var CaptureVideoOptions = function () { // Upper limit of videos user can record. Value must be equal or greater than 1. this.limit = 1; // Maximum duration of a single video clip in seconds. this.duration = 0; // Video quality parameter, 0 means low quality, suitable for MMS messages, and value 1 means high quality. this.quality = 1; }; module.exports = CaptureVideoOptions; × Search results Close "},"cordova-clipboard_www_clipboard.js.html":{"id":"cordova-clipboard_www_clipboard.js.html","title":"Source: cordova-clipboard/www/clipboard.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: cordova-clipboard/www/clipboard.js var cordova = require('cordova'); /** * Clipboard plugin for Cordova * * @constructor */ function Clipboard () {} /** * Sets the clipboard content * * @param {String} text The content to copy to the clipboard * @param {Function} onSuccess The function to call in case of success (takes the copied text as argument) * @param {Function} onFail The function to call in case of error */ Clipboard.prototype.copy = function (text, onSuccess, onFail) { if (typeof text === \"undefined\" || text === null) text = \"\"; cordova.exec(onSuccess, onFail, \"Clipboard\", \"copy\", [text]); }; /** * Gets the clipboard content * * @param {Function} onSuccess The function to call in case of success * @param {Function} onFail The function to call in case of error */ Clipboard.prototype.paste = function (onSuccess, onFail) { cordova.exec(onSuccess, onFail, \"Clipboard\", \"paste\", []); }; /** * Clear the clipboard content * * @param {Function} onSuccess The function to call in case of success * @param {Function} onFail The function to call in case of error */ Clipboard.prototype.clear = function (onSuccess, onFail) { cordova.exec(onSuccess, onFail, \"Clipboard\", \"clear\", []); }; // Register the plugin var clipboard = new Clipboard(); module.exports = clipboard; × Search results Close "},"cordova-plugin-media-capture_www_ConfigurationData.js.html":{"id":"cordova-plugin-media-capture_www_ConfigurationData.js.html","title":"Source: cordova-plugin-media-capture/www/ConfigurationData.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: cordova-plugin-media-capture/www/ConfigurationData.js /* * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. * */ /** * Encapsulates a set of parameters that the capture device supports. */ function ConfigurationData () { // The ASCII-encoded string in lower case representing the media type. this.type = null; // The height attribute represents height of the image or video in pixels. // In the case of a sound clip this attribute has value 0. this.height = 0; // The width attribute represents width of the image or video in pixels. // In the case of a sound clip this attribute has value 0 this.width = 0; } module.exports = ConfigurationData; × Search results Close "},"cordova-plugin-geolocation_www_Coordinates.js.html":{"id":"cordova-plugin-geolocation_www_Coordinates.js.html","title":"Source: cordova-plugin-geolocation/www/Coordinates.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: cordova-plugin-geolocation/www/Coordinates.js /* * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. * */ /** * This class contains position information. * @param {Object} lat * @param {Object} lng * @param {Object} alt * @param {Object} acc * @param {Object} head * @param {Object} vel * @param {Object} altacc * @constructor */ var Coordinates = function (lat, lng, alt, acc, head, vel, altacc) { /** * The latitude of the position. */ this.latitude = lat; /** * The longitude of the position, */ this.longitude = lng; /** * The accuracy of the position. */ this.accuracy = acc; /** * The altitude of the position. */ this.altitude = (alt !== undefined ? alt : null); /** * The direction the device is moving at the position. */ this.heading = (head !== undefined ? head : null); /** * The velocity with which the device is moving at the position. */ this.speed = (vel !== undefined ? vel : null); if (this.speed === 0 || this.speed === null) { this.heading = NaN; } /** * The altitude accuracy of the position. */ this.altitudeAccuracy = (altacc !== undefined) ? altacc : null; }; module.exports = Coordinates; × Search results Close "},"elastos-trinity-plugins-ionicwebview_src_www_ios_ios-wkwebview-exec.js.html":{"id":"elastos-trinity-plugins-ionicwebview_src_www_ios_ios-wkwebview-exec.js.html","title":"Source: elastos-trinity-plugins-ionicwebview/src/www/ios/ios-wkwebview-exec.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: elastos-trinity-plugins-ionicwebview/src/www/ios/ios-wkwebview-exec.js /* * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. * */ /** * Creates the exec bridge used to notify the native code of * commands. */ var cordova = require('cordova'); var utils = require('cordova/utils'); var base64 = require('cordova/base64'); function massageArgsJsToNative (args) { if (!args || utils.typeName(args) !== 'Array') { return args; } var ret = []; args.forEach(function (arg, i) { if (utils.typeName(arg) === 'ArrayBuffer') { ret.push({ 'CDVType': 'ArrayBuffer', 'data': base64.fromArrayBuffer(arg) }); } else { ret.push(arg); } }); return ret; } function massageMessageNativeToJs (message) { if (message.CDVType === 'ArrayBuffer') { var stringToArrayBuffer = function (str) { var ret = new Uint8Array(str.length); for (var i = 0; i &lt; str.length; i++) { ret[i] = str.charCodeAt(i); } return ret.buffer; }; var base64ToArrayBuffer = function (b64) { return stringToArrayBuffer(atob(b64)); // eslint-disable-line no-undef }; message = base64ToArrayBuffer(message.data); } return message; } function convertMessageToArgsNativeToJs (message) { var args = []; if (!message || !message.hasOwnProperty('CDVType')) { args.push(message); } else if (message.CDVType === 'MultiPart') { message.messages.forEach(function (e) { args.push(massageMessageNativeToJs(e)); }); } else { args.push(massageMessageNativeToJs(message)); } return args; } var iOSExec = function () { // detect change in bridge, if there is a change, we forward to new bridge // if (window.webkit &amp;&amp; window.webkit.messageHandlers &amp;&amp; window.webkit.messageHandlers.cordova &amp;&amp; window.webkit.messageHandlers.cordova.postMessage) { // bridgeMode = jsToNativeModes.WK_WEBVIEW_BINDING; // } var successCallback, failCallback, service, action, actionArgs; var callbackId = null; if (typeof arguments[0] !== 'string') { // FORMAT ONE successCallback = arguments[0]; failCallback = arguments[1]; service = arguments[2]; action = arguments[3]; actionArgs = arguments[4]; // Since we need to maintain backwards compatibility, we have to pass // an invalid callbackId even if no callback was provided since plugins // will be expecting it. The Cordova.exec() implementation allocates // an invalid callbackId and passes it even if no callbacks were given. callbackId = 'INVALID'; } else { throw new Error('The old format of this exec call has been removed (deprecated since 2.1). Change to: ' + // eslint-disable-line 'cordova.exec(null, null, \\'Service\\', \\'action\\', [ arg1, arg2 ]);'); } // If actionArgs is not provided, default to an empty array actionArgs = actionArgs || []; // Register the callbacks and add the callbackId to the positional // arguments if given. if (successCallback || failCallback) { callbackId = service + cordova.callbackId++; cordova.callbacks[callbackId] = {success: successCallback, fail: failCallback}; } actionArgs = massageArgsJsToNative(actionArgs); // CB-10133 DataClone DOM Exception 25 guard (fast function remover) var command = [callbackId, service, action, JSON.parse(JSON.stringify(actionArgs))]; window.webkit.messageHandlers.cordova.postMessage(command); }; iOSExec.nativeCallback = function (callbackId, status, message, keepCallback, debug) { var success = status === 0 || status === 1; var args = convertMessageToArgsNativeToJs(message); Promise.resolve().then(function () { cordova.callbackFromNative(callbackId, success, status, args, keepCallback); // eslint-disable-line }); }; // for backwards compatibility iOSExec.nativeEvalAndFetch = function (func) { try { func(); } catch (e) { console.log(e); } }; // Proxy the exec for bridge changes. See CB-10106 function cordovaExec () { var cexec = require('cordova/exec'); var cexec_valid = (typeof cexec.nativeFetchMessages === 'function') &amp;&amp; (typeof cexec.nativeEvalAndFetch === 'function') &amp;&amp; (typeof cexec.nativeCallback === 'function'); return (cexec_valid &amp;&amp; execProxy !== cexec) ? cexec : iOSExec; } function execProxy () { cordovaExec().apply(null, arguments); } execProxy.nativeFetchMessages = function () { return cordovaExec().nativeFetchMessages.apply(null, arguments); }; execProxy.nativeEvalAndFetch = function () { return cordovaExec().nativeEvalAndFetch.apply(null, arguments); }; execProxy.nativeCallback = function () { return cordovaExec().nativeCallback.apply(null, arguments); }; module.exports = execProxy; if (window.webkit &amp;&amp; window.webkit.messageHandlers &amp;&amp; window.webkit.messageHandlers.cordova &amp;&amp; window.webkit.messageHandlers.cordova.postMessage) { // unregister the old bridge cordova.define.remove('cordova/exec'); // redefine bridge to our new bridge cordova.define('cordova/exec', function (require, exports, module) { module.exports = execProxy; }); } × Search results Close "},"cordova-plugin-camera_tests_tests.js.html":{"id":"cordova-plugin-camera_tests_tests.js.html","title":"Source: cordova-plugin-camera/tests/tests.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: cordova-plugin-camera/tests/tests.js /* * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. * */ /* globals Camera, resolveLocalFileSystemURL, FileEntry, CameraPopoverOptions, FileTransfer, FileUploadOptions, LocalFileSystem, MSApp */ /* eslint-env jasmine */ exports.defineAutoTests = function () { describe('Camera (navigator.camera)', function () { it('should exist', function () { expect(navigator.camera).toBeDefined(); }); it('should contain a getPicture function', function () { expect(navigator.camera.getPicture).toBeDefined(); expect(typeof navigator.camera.getPicture === 'function').toBe(true); }); }); describe('Camera Constants (window.Camera + navigator.camera)', function () { it('camera.spec.1 window.Camera should exist', function () { expect(window.Camera).toBeDefined(); }); it('camera.spec.2 should contain three DestinationType constants', function () { expect(Camera.DestinationType.DATA_URL).toBe(0); expect(Camera.DestinationType.FILE_URI).toBe(1); expect(Camera.DestinationType.NATIVE_URI).toBe(2); expect(navigator.camera.DestinationType.DATA_URL).toBe(0); expect(navigator.camera.DestinationType.FILE_URI).toBe(1); expect(navigator.camera.DestinationType.NATIVE_URI).toBe(2); }); it('camera.spec.3 should contain two EncodingType constants', function () { expect(Camera.EncodingType.JPEG).toBe(0); expect(Camera.EncodingType.PNG).toBe(1); expect(navigator.camera.EncodingType.JPEG).toBe(0); expect(navigator.camera.EncodingType.PNG).toBe(1); }); it('camera.spec.4 should contain three MediaType constants', function () { expect(Camera.MediaType.PICTURE).toBe(0); expect(Camera.MediaType.VIDEO).toBe(1); expect(Camera.MediaType.ALLMEDIA).toBe(2); expect(navigator.camera.MediaType.PICTURE).toBe(0); expect(navigator.camera.MediaType.VIDEO).toBe(1); expect(navigator.camera.MediaType.ALLMEDIA).toBe(2); }); it('camera.spec.5 should contain three PictureSourceType constants', function () { expect(Camera.PictureSourceType.PHOTOLIBRARY).toBe(0); expect(Camera.PictureSourceType.CAMERA).toBe(1); expect(Camera.PictureSourceType.SAVEDPHOTOALBUM).toBe(2); expect(navigator.camera.PictureSourceType.PHOTOLIBRARY).toBe(0); expect(navigator.camera.PictureSourceType.CAMERA).toBe(1); expect(navigator.camera.PictureSourceType.SAVEDPHOTOALBUM).toBe(2); }); }); }; /******************************************************************************/ /******************************************************************************/ /******************************************************************************/ exports.defineManualTests = function (contentEl, createActionButton) { var pictureUrl = null; var fileObj = null; var fileEntry = null; var pageStartTime = +new Date(); // default camera options var camQualityDefault = ['50', 50]; var camDestinationTypeDefault = ['FILE_URI', 1]; var camPictureSourceTypeDefault = ['CAMERA', 1]; var camAllowEditDefault = ['allowEdit', false]; var camEncodingTypeDefault = ['JPEG', 0]; var camMediaTypeDefault = ['mediaType', 0]; var camCorrectOrientationDefault = ['correctOrientation', false]; var camSaveToPhotoAlbumDefault = ['saveToPhotoAlbum', true]; function log (value) { console.log(value); document.getElementById('camera_status').textContent += (new Date() - pageStartTime) / 1000 + ': ' + value + '\\n'; } function clearStatus () { document.getElementById('camera_status').innerHTML = ''; document.getElementById('camera_image').src = 'about:blank'; var canvas = document.getElementById('canvas'); canvas.width = canvas.height = 1; pictureUrl = null; fileObj = null; fileEntry = null; } function setPicture (url, callback) { try { window.atob(url); // if we got here it is a base64 string (DATA_URL) url = 'data:image/jpeg;base64,' + url; } catch (e) { // not DATA_URL } log('URL: \"' + url.slice(0, 90) + '\"'); pictureUrl = url; var img = document.getElementById('camera_image'); var startTime = new Date(); img.src = url; img.onload = function () { log('Img size: ' + img.naturalWidth + 'x' + img.naturalHeight); log('Image tag load time: ' + (new Date() - startTime)); if (callback) { callback(); } }; } function onGetPictureError (e) { log('Error getting picture: ' + (e.code || e)); } function getPictureWin (data) { setPicture(data); // TODO: Fix resolveLocalFileSystemURI to work with native-uri. if (pictureUrl.indexOf('file:') === 0 || pictureUrl.indexOf('content:') === 0 || pictureUrl.indexOf('ms-appdata:') === 0 || pictureUrl.indexOf('assets-library:') === 0) { resolveLocalFileSystemURL(data, function (e) { fileEntry = e; logCallback('resolveLocalFileSystemURL()', true)(e.toURL()); readFile(); }, logCallback('resolveLocalFileSystemURL()', false)); } else if (pictureUrl.indexOf('data:image/jpeg;base64') === 0) { // do nothing } else { var path = pictureUrl.replace(/^file:\\/\\/(localhost)?/, '').replace(/%20/g, ' '); fileEntry = new FileEntry('image_name.png', path); } } function getPicture () { clearStatus(); var options = extractOptions(); log('Getting picture with options: ' + JSON.stringify(options)); var popoverHandle = navigator.camera.getPicture(getPictureWin, onGetPictureError, options); // Reposition the popover if the orientation changes. window.onorientationchange = function () { var newPopoverOptions = new CameraPopoverOptions(0, 0, 100, 100, 0, 300, 400); popoverHandle.setPosition(newPopoverOptions); }; } function uploadImage () { var ft = new FileTransfer(); var options = new FileUploadOptions(); options.fileKey = 'photo'; options.fileName = 'test.jpg'; options.mimeType = 'image/jpeg'; ft.onprogress = function (progressEvent) { console.log('progress: ' + progressEvent.loaded + ' of ' + progressEvent.total); }; var server = 'http://sheltered-retreat-43956.herokuapp.com'; ft.upload(pictureUrl, server + '/upload', win, fail, options); function win (information_back) { log('upload complete'); } function fail (message) { log('upload failed: ' + JSON.stringify(message)); } } function logCallback (apiName, success) { return function () { log('Call to ' + apiName + (success ? ' success: ' : ' failed: ') + JSON.stringify([].slice.call(arguments))); }; } /** * Select image from library using a NATIVE_URI destination type * This calls FileEntry.getMetadata, FileEntry.setMetadata, FileEntry.getParent, FileEntry.file, and FileReader.readAsDataURL. */ function readFile () { function onFileReadAsDataURL (evt) { var img = document.getElementById('camera_image'); img.style.visibility = 'visible'; img.style.display = 'block'; img.src = evt.target.result; log('FileReader.readAsDataURL success'); } function onFileReceived (file) { log('Got file: ' + JSON.stringify(file)); fileObj = file; /* eslint-disable no-undef */ var reader = new FileReader(); /* eslint-enable no-undef */ reader.onload = function () { log('FileReader.readAsDataURL() - length = ' + reader.result.length); }; reader.onerror = logCallback('FileReader.readAsDataURL', false); reader.onloadend = onFileReadAsDataURL; reader.readAsDataURL(file); } // Test out onFileReceived when the file object was set via a native &lt;input&gt; elements. if (fileObj) { onFileReceived(fileObj); } else { fileEntry.file(onFileReceived, logCallback('FileEntry.file', false)); } } function getFileInfo () { // Test FileEntry API here. fileEntry.getMetadata(logCallback('FileEntry.getMetadata', true), logCallback('FileEntry.getMetadata', false)); fileEntry.setMetadata(logCallback('FileEntry.setMetadata', true), logCallback('FileEntry.setMetadata', false), { 'com.apple.MobileBackup': 1 }); fileEntry.getParent(logCallback('FileEntry.getParent', true), logCallback('FileEntry.getParent', false)); fileEntry.getParent(logCallback('FileEntry.getParent', true), logCallback('FileEntry.getParent', false)); } /** * Copy image from library using a NATIVE_URI destination type * This calls FileEntry.copyTo and FileEntry.moveTo. */ function copyImage () { var onFileSystemReceived = function (fileSystem) { var destDirEntry = fileSystem.root; var origName = fileEntry.name; // Test FileEntry API here. fileEntry.copyTo(destDirEntry, 'copied_file.png', logCallback('FileEntry.copyTo', true), logCallback('FileEntry.copyTo', false)); fileEntry.moveTo(destDirEntry, 'moved_file.png', logCallback('FileEntry.moveTo', true), logCallback('FileEntry.moveTo', false)); // cleanup // rename moved file back to original name so other tests can reference image resolveLocalFileSystemURL(destDirEntry.nativeURL + 'moved_file.png', function (fileEntry) { fileEntry.moveTo(destDirEntry, origName, logCallback('FileEntry.moveTo', true), logCallback('FileEntry.moveTo', false)); console.log('Cleanup: successfully renamed file back to original name'); }, function () { console.log('Cleanup: failed to rename file back to original name'); }); // remove copied file resolveLocalFileSystemURL(destDirEntry.nativeURL + 'copied_file.png', function (fileEntry) { fileEntry.remove(logCallback('FileEntry.remove', true), logCallback('FileEntry.remove', false)); console.log('Cleanup: successfully removed copied file'); }, function () { console.log('Cleanup: failed to remove copied file'); }); }; window.requestFileSystem(LocalFileSystem.TEMPORARY, 0, onFileSystemReceived, null); } /** * Write image to library using a NATIVE_URI destination type * This calls FileEntry.createWriter, FileWriter.write, and FileWriter.truncate. */ function writeImage () { var onFileWriterReceived = function (fileWriter) { fileWriter.onwrite = logCallback('FileWriter.write', true); fileWriter.onerror = logCallback('FileWriter.write', false); fileWriter.write('some text!'); }; var onFileTruncateWriterReceived = function (fileWriter) { fileWriter.onwrite = logCallback('FileWriter.truncate', true); fileWriter.onerror = logCallback('FileWriter.truncate', false); fileWriter.truncate(10); }; fileEntry.createWriter(onFileWriterReceived, logCallback('FileEntry.createWriter', false)); fileEntry.createWriter(onFileTruncateWriterReceived, null); } function displayImageUsingCanvas () { var canvas = document.getElementById('canvas'); var img = document.getElementById('camera_image'); var w = img.width; var h = img.height; h = 100 / w * h; w = 100; canvas.width = w; canvas.height = h; var context = canvas.getContext('2d'); context.drawImage(img, 0, 0, w, h); } /** * Remove image from library using a NATIVE_URI destination type * This calls FileEntry.remove. */ function removeImage () { fileEntry.remove(logCallback('FileEntry.remove', true), logCallback('FileEntry.remove', false)); } function testInputTag (inputEl) { clearStatus(); // iOS 6 likes to dead-lock in the onchange context if you // do any alerts or try to remote-debug. window.setTimeout(function () { testNativeFile2(inputEl); }, 0); } function testNativeFile2 (inputEl) { /* eslint-disable no-undef */ if (!inputEl.value) { alert('No file selected.'); return; } fileObj = inputEl.files[0]; if (!fileObj) { alert('Got value but no file.'); return; } /* eslint-enable no-undef */ var URLApi = window.URL || window.webkitURL; if (URLApi) { var blobURL = URLApi.createObjectURL(fileObj); if (blobURL) { setPicture(blobURL, function () { URLApi.revokeObjectURL(blobURL); }); } else { log('URL.createObjectURL returned null'); } } else { log('URL.createObjectURL() not supported.'); } } function extractOptions () { var els = document.querySelectorAll('#image-options select'); var ret = {}; /* eslint-disable no-cond-assign */ for (var i = 0, el; el = els[i]; ++i) { var value = el.value; if (value === '') continue; value = +value; if (el.isBool) { ret[el.getAttribute('name')] = !!value; } else { ret[el.getAttribute('name')] = value; } } /* eslint-enable no-cond-assign */ return ret; } function createOptionsEl (name, values, selectionDefault) { var openDiv = '&lt;div style=\"display: inline-block\"&gt;' + name + ': '; var select = '&lt;select name=' + name + ' id=\"' + name + '\"&gt;'; var defaultOption = ''; if (selectionDefault === undefined) { defaultOption = '&lt;option value=\"\"&gt;default&lt;/option&gt;'; } var options = ''; if (typeof values === 'boolean') { values = { 'true': 1, 'false': 0 }; } for (var k in values) { var isSelected = ''; if (selectionDefault) { if (selectionDefault[0] === k) { isSelected = 'selected'; } } options += '&lt;option value=\"' + values[k] + '\" ' + isSelected + '&gt;' + k + '&lt;/option&gt;'; } var closeDiv = '&lt;/select&gt;&lt;/div&gt;'; return openDiv + select + defaultOption + options + closeDiv; } /******************************************************************************/ var info_div = '&lt;h1&gt;Camera&lt;/h1&gt;' + '&lt;div id=\"info\"&gt;' + '&lt;b&gt;Status:&lt;/b&gt; &lt;div id=\"camera_status\"&gt;&lt;/div&gt;' + 'img: &lt;img width=\"100\" id=\"camera_image\"&gt;' + 'canvas: &lt;canvas id=\"canvas\" width=\"1\" height=\"1\"&gt;&lt;/canvas&gt;' + '&lt;/div&gt;'; var options_div = '&lt;h2&gt;Cordova Camera API Options&lt;/h2&gt;' + '&lt;div id=\"image-options\"&gt;' + createOptionsEl('sourceType', Camera.PictureSourceType, camPictureSourceTypeDefault) + createOptionsEl('destinationType', Camera.DestinationType, camDestinationTypeDefault) + createOptionsEl('encodingType', Camera.EncodingType, camEncodingTypeDefault) + createOptionsEl('mediaType', Camera.MediaType, camMediaTypeDefault) + createOptionsEl('quality', { '0': 0, '50': 50, '80': 80, '100': 100 }, camQualityDefault) + createOptionsEl('targetWidth', { '50': 50, '200': 200, '800': 800, '2048': 2048 }) + createOptionsEl('targetHeight', { '50': 50, '200': 200, '800': 800, '2048': 2048 }) + createOptionsEl('allowEdit', true, camAllowEditDefault) + createOptionsEl('correctOrientation', true, camCorrectOrientationDefault) + createOptionsEl('saveToPhotoAlbum', true, camSaveToPhotoAlbumDefault) + createOptionsEl('cameraDirection', Camera.Direction) + '&lt;/div&gt;'; var getpicture_div = '&lt;div id=\"getpicture\"&gt;&lt;/div&gt;'; var test_procedure = '&lt;h4&gt;Recommended Test Procedure&lt;/h4&gt;' + 'Options not specified should be the default value' + '&lt;br&gt;Status box should update with image and info whenever an image is taken or selected from library' + '&lt;/p&gt;&lt;div style=\"background:#B0C4DE;border:1px solid #FFA07A;margin:15px 6px 0px;min-width:295px;max-width:97%;padding:4px 0px 2px 10px;min-height:160px;max-height:200px;overflow:auto\"&gt;' + '&lt;ol&gt; &lt;li&gt;All default options. Should be able to edit once picture is taken and will be saved to library.&lt;/li&gt;' + '&lt;/p&gt;&lt;li&gt;sourceType=PHOTOLIBRARY&lt;br&gt;Should be able to see picture that was just taken in previous test and edit when selected&lt;/li&gt;' + '&lt;/p&gt;&lt;li&gt;sourceType=Camera&lt;br&gt;allowEdit=false&lt;br&gt;saveToPhotoAlbum=false&lt;br&gt;Should not be able to edit when taken and will not save to library&lt;/li&gt;' + '&lt;/p&gt;&lt;li&gt;encodingType=PNG&lt;br&gt;allowEdit=true&lt;br&gt;saveToPhotoAlbum=true&lt;br&gt;cameraDirection=FRONT&lt;br&gt;Should bring up front camera. Verify in status box info URL that image is encoded as PNG.&lt;/li&gt;' + '&lt;/p&gt;&lt;li&gt;sourceType=SAVEDPHOTOALBUM&lt;br&gt;mediaType=VIDEO&lt;br&gt;Should only be able to select a video&lt;/li&gt;' + '&lt;/p&gt;&lt;li&gt;sourceType=SAVEDPHOTOALBUM&lt;br&gt;mediaType=PICTURE&lt;br&gt;allowEdit=false&lt;br&gt;Should only be able to select a picture and not edit&lt;/li&gt;' + '&lt;/p&gt;&lt;li&gt;sourceType=PHOTOLIBRARY&lt;br&gt;mediaType=ALLMEDIA&lt;br&gt;allowEdit=true&lt;br&gt;Should be able to select pics and videos and edit picture if selected&lt;/li&gt;' + '&lt;/p&gt;&lt;li&gt;sourceType=CAMERA&lt;br&gt;targetWidth &amp; targetHeight=50&lt;br&gt;allowEdit=false&lt;br&gt;Do Get File Metadata test below and take note of size&lt;br&gt;Repeat test but with width and height=800. Size should be significantly larger.&lt;/li&gt;' + '&lt;/p&gt;&lt;li&gt;quality=0&lt;br&gt;targetWidth &amp; targetHeight=default&lt;br&gt;allowEdit=false&lt;br&gt;Do Get File Metadata test below and take note of size&lt;br&gt;Repeat test but with quality=80. Size should be significantly larger.&lt;/li&gt;' + '&lt;/ol&gt;&lt;/div&gt;'; var inputs_div = '&lt;h2&gt;Native File Inputs&lt;/h2&gt;' + 'For the following tests, status box should update with file selected' + '&lt;/p&gt;&lt;div&gt;input type=file &lt;input type=\"file\" class=\"testInputTag\"&gt;&lt;/div&gt;' + '&lt;div&gt;capture=camera &lt;input type=\"file\" accept=\"image/*;capture=camera\" class=\"testInputTag\"&gt;&lt;/div&gt;' + '&lt;div&gt;capture=camcorder &lt;input type=\"file\" accept=\"video/*;capture=camcorder\" class=\"testInputTag\"&gt;&lt;/div&gt;' + '&lt;div&gt;capture=microphone &lt;input type=\"file\" accept=\"audio/*;capture=microphone\" class=\"testInputTag\"&gt;&lt;/div&gt;'; var actions_div = '&lt;h2&gt;Actions&lt;/h2&gt;' + 'For the following tests, ensure that an image is set in status box' + '&lt;/p&gt;&lt;div id=\"metadata\"&gt;&lt;/div&gt;' + 'Expected result: Get metadata about file selected.&lt;br&gt;Status box will show, along with the metadata, \"Call to FileEntry.getMetadata success, Call to FileEntry.setMetadata success, Call to FileEntry.getParent success\"' + '&lt;/p&gt;&lt;div id=\"reader\"&gt;&lt;/div&gt;' + 'Expected result: Read contents of file.&lt;br&gt;Status box will show \"Got file: {some metadata}, FileReader.readAsDataURL() - length = someNumber\"' + '&lt;/p&gt;&lt;div id=\"copy\"&gt;&lt;/div&gt;' + 'Expected result: Copy image to new location and move file to different location.&lt;br&gt;Status box will show \"Call to FileEntry.copyTo success:{some metadata}, Call to FileEntry.moveTo success:{some metadata}\"' + '&lt;/p&gt;&lt;div id=\"write\"&gt;&lt;/div&gt;' + 'Expected result: Write image to library.&lt;br&gt;Status box will show \"Call to FileWriter.write success:{some metadata}, Call to FileWriter.truncate success:{some metadata}\"' + '&lt;/p&gt;&lt;div id=\"upload\"&gt;&lt;/div&gt;' + 'Expected result: Upload image to server.&lt;br&gt;Status box may print out progress. Once finished will show \"upload complete\"' + '&lt;/p&gt;&lt;div id=\"draw_canvas\"&gt;&lt;/div&gt;' + 'Expected result: Display image using canvas.&lt;br&gt;Image will be displayed in status box under \"canvas:\"' + '&lt;/p&gt;&lt;div id=\"remove\"&gt;&lt;/div&gt;' + 'Expected result: Remove image from library.&lt;br&gt;Status box will show \"FileEntry.remove success:[\"OK\"]'; // We need to wrap this code due to Windows security restrictions // see http://msdn.microsoft.com/en-us/library/windows/apps/hh465380.aspx#differences for details if (window.MSApp &amp;&amp; window.MSApp.execUnsafeLocalFunction) { MSApp.execUnsafeLocalFunction(function () { contentEl.innerHTML = info_div + options_div + getpicture_div + test_procedure + inputs_div + actions_div; }); } else { contentEl.innerHTML = info_div + options_div + getpicture_div + test_procedure + inputs_div + actions_div; } var elements = document.getElementsByClassName('testInputTag'); var listener = function (e) { testInputTag(e.target); }; for (var i = 0; i &lt; elements.length; ++i) { var item = elements[i]; item.addEventListener('change', listener, false); } createActionButton('Get picture', function () { getPicture(); }, 'getpicture'); createActionButton('Clear Status', function () { clearStatus(); }, 'getpicture'); createActionButton('Get File Metadata', function () { getFileInfo(); }, 'metadata'); createActionButton('Read with FileReader', function () { readFile(); }, 'reader'); createActionButton('Copy Image', function () { copyImage(); }, 'copy'); createActionButton('Write Image', function () { writeImage(); }, 'write'); createActionButton('Upload Image', function () { uploadImage(); }, 'upload'); createActionButton('Draw Using Canvas', function () { displayImageUsingCanvas(); }, 'draw_canvas'); createActionButton('Remove Image', function () { removeImage(); }, 'remove'); }; × Search results Close "},"cordova-plugin-device-motion_tests_tests.js.html":{"id":"cordova-plugin-device-motion_tests_tests.js.html","title":"Source: cordova-plugin-device-motion/tests/tests.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: cordova-plugin-device-motion/tests/tests.js /* * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. * */ /* jshint jasmine: true */ /* global Windows */ exports.defineAutoTests = function () { var isWindows = (cordova.platformId === \"windows\") || (cordova.platformId === \"windows8\"), // Checking existence of accelerometer for windows platform // Assumed that accelerometer always exists on other platforms. Extend // condition to support accelerometer check on other platforms isAccelExist = isWindows ? Windows.Devices.Sensors.Accelerometer.getDefault() !== null : true; describe('Accelerometer (navigator.accelerometer)', function () { var fail = function(done) { expect(true).toBe(false); done(); }; // This timeout is here to lessen the load on native accelerometer // intensive use of which can lead to occasional test failures afterEach(function(done) { setTimeout(function() { done(); }, 100); }); it(\"accelerometer.spec.1 should exist\", function () { expect(navigator.accelerometer).toBeDefined(); }); describe(\"getCurrentAcceleration\", function() { it(\"accelerometer.spec.2 should exist\", function() { expect(typeof navigator.accelerometer.getCurrentAcceleration).toBeDefined(); expect(typeof navigator.accelerometer.getCurrentAcceleration == 'function').toBe(true); }); it(\"accelerometer.spec.3 success callback should be called with an Acceleration object\", function(done) { // skip the test if Accelerometer doesn't exist on this device if (!isAccelExist) { pending(); } var win = function(a) { expect(a).toBeDefined(); expect(a.x).toBeDefined(); expect(typeof a.x == 'number').toBe(true); expect(a.y).toBeDefined(); expect(typeof a.y == 'number').toBe(true); expect(a.z).toBeDefined(); expect(typeof a.z == 'number').toBe(true); expect(a.timestamp).toBeDefined(); expect(typeof a.timestamp).toBe('number'); done(); }; var onError = function(err){ console.log(err); console.log(\"Skipping gyroscope tests, marking all as pending.\"); isAccelExist = false; expect(true).toBe(true); done(); }; navigator.accelerometer.getCurrentAcceleration(win, onError); }); it(\"accelerometer.spec.4 success callback Acceleration object should have (reasonable) values for x, y and z expressed in m/s^2\", function(done) { // skip the test if Accelerometer doesn't exist on this device if (!isAccelExist) { pending(); } var reasonableThreshold = 15; var win = function(a) { expect(a.x).toBeLessThan(reasonableThreshold); expect(a.x).toBeGreaterThan(reasonableThreshold * -1); expect(a.y).toBeLessThan(reasonableThreshold); expect(a.y).toBeGreaterThan(reasonableThreshold * -1); expect(a.z).toBeLessThan(reasonableThreshold); expect(a.z).toBeGreaterThan(reasonableThreshold * -1); done(); }; navigator.accelerometer.getCurrentAcceleration(win, fail.bind(null,done)); }); it(\"accelerometer.spec.5 success callback Acceleration object should return a recent timestamp\", function(done) { // skip the test if Accelerometer doesn't exist on this device if (!isAccelExist) { pending(); } var veryRecently = (new Date()).getTime(); // Need to check that dates returned are not vastly greater than a recent time stamp. // In case the timestamps returned are ridiculously high var reasonableTimeLimit = veryRecently + 5000; // 5 seconds from now var win = function(a) { expect(a.timestamp).toBeGreaterThan(veryRecently - 200); // this is flakey, relaxing a bit expect(a.timestamp).toBeLessThan(reasonableTimeLimit); done(); }; navigator.accelerometer.getCurrentAcceleration(win, fail.bind(null,done)); }); }); describe(\"watchAcceleration\", function() { var id; afterEach(function(done) { if (id) { navigator.accelerometer.clearWatch(id); } // clearWatch implementation is async but doesn't accept a cllback // so let's give it some time before starting next spec setTimeout(done, 100); }); it(\"accelerometer.spec.6 should exist\", function() { expect(navigator.accelerometer.watchAcceleration).toBeDefined(); expect(typeof navigator.accelerometer.watchAcceleration == 'function').toBe(true); }); it(\"accelerometer.spec.7 success callback should be called with an Acceleration object\", function(done) { // skip the test if Accelerometer doesn't exist on this device if (!isAccelExist) { pending(); } var win = function(a) { expect(a).toBeDefined(); expect(a.x).toBeDefined(); expect(typeof a.x == 'number').toBe(true); expect(a.y).toBeDefined(); expect(typeof a.y == 'number').toBe(true); expect(a.z).toBeDefined(); expect(typeof a.z == 'number').toBe(true); expect(a.timestamp).toBeDefined(); expect(typeof a.timestamp).toBe('number'); done(); }; id = navigator.accelerometer.watchAcceleration(win, fail.bind(null,done), {frequency:100}); }); it(\"accelerometer.spec.8 success callback Acceleration object should have (reasonable) values for x, y and z expressed in m/s^2\", function(done) { // skip the test if Accelerometer doesn't exist on this device if (!isAccelExist) { pending(); } var reasonableThreshold = 15; var win = function(a) { expect(a.x).toBeLessThan(reasonableThreshold); expect(a.x).toBeGreaterThan(reasonableThreshold * -1); expect(a.y).toBeLessThan(reasonableThreshold); expect(a.y).toBeGreaterThan(reasonableThreshold * -1); expect(a.z).toBeLessThan(reasonableThreshold); expect(a.z).toBeGreaterThan(reasonableThreshold * -1); done(); }; id = navigator.accelerometer.watchAcceleration(win, fail.bind(null,done), {frequency:100}); }); it(\"accelerometer.spec.9 success callback Acceleration object should return a recent timestamp\", function(done) { // skip the test if Accelerometer doesn't exist on this device if (!isAccelExist) { pending(); } var veryRecently = (new Date()).getTime(); // Need to check that dates returned are not vastly greater than a recent time stamp. // In case the timestamps returned are ridiculously high var reasonableTimeLimit = veryRecently + 5000; // 5 seconds from now var win = function(a) { expect(a.timestamp).toBeGreaterThan(veryRecently - 200); // this is flakey, relaxing a bit expect(a.timestamp).toBeLessThan(reasonableTimeLimit); done(); }; id = navigator.accelerometer.watchAcceleration(win, fail.bind(null,done), {frequency:100}); }); it(\"accelerometer.spec.12 success callback should be preserved and called several times\", function (done) { // skip the test if Accelerometer doesn't exist on this device if (!isAccelExist) { pending(); } var callbacksCallCount = 0, callbacksCallTestCount = 3; var win = function (a) { if (callbacksCallCount++ &lt; callbacksCallTestCount) return; expect(typeof a).toBe('object'); done(); }; id = navigator.accelerometer.watchAcceleration(win, fail.bind(null, done), { frequency: 100 }); }); }); describe(\"clearWatch\", function() { it(\"accelerometer.spec.10 should exist\", function() { expect(navigator.accelerometer.clearWatch).toBeDefined(); expect(typeof navigator.accelerometer.clearWatch == 'function').toBe(true); }); it(\"accelerometer.spec.11 should clear an existing watch\", function(done) { // skip the test if Accelerometer doesn't exist on this device if (!isAccelExist) { pending(); } var id; // expect win to get called exactly once var win = function(a) { // clear watch on first call navigator.accelerometer.clearWatch(id); // if win isn't called again in 201 ms we assume success var tid = setTimeout(function() { expect(true).toBe(true); done(); }, 101); // if win is called again, clear the timeout and fail the test win = function() { clearTimeout(tid); fail(done); }; }; // wrap the success call in a closure since the value of win changes between calls id = navigator.accelerometer.watchAcceleration(function() { win(); }, fail.bind(null, done), {frequency:100}); }); }); }); }; /******************************************************************************/ /******************************************************************************/ /******************************************************************************/ exports.defineManualTests = function (contentEl, createActionButton) { function roundNumber(num) { var dec = 3; var result = Math.round(num * Math.pow(10, dec)) / Math.pow(10, dec); return result; } var watchAccelId = null; /** * Set accelerometer status */ function setAccelStatus(status) { document.getElementById('accel_status').innerHTML = status; } /** * Stop watching the acceleration */ function stopAccel() { console.log(\"stopAccel()\"); setAccelStatus(\"Stopped\"); if (watchAccelId) { navigator.accelerometer.clearWatch(watchAccelId); watchAccelId = null; } } /** * Start watching acceleration */ var watchAccel = function () { console.log(\"watchAccel()\"); // Success callback var success = function (a) { document.getElementById('x').innerHTML = roundNumber(a.x); document.getElementById('y').innerHTML = roundNumber(a.y); document.getElementById('z').innerHTML = roundNumber(a.z); document.getElementById('t').innerHTML = a.timestamp; }; // Fail callback var fail = function (e) { console.log(\"watchAccel fail callback with error code \" + e); stopAccel(); setAccelStatus(e); }; // Update acceleration every 1 sec var opt = {}; opt.frequency = 1000; watchAccelId = navigator.accelerometer.watchAcceleration(success, fail, opt); setAccelStatus(\"Running\"); }; /** * Get current acceleration */ var getAccel = function () { console.log(\"getAccel()\"); // Stop accel if running stopAccel(); // Success callback var success = function (a) { document.getElementById('x').innerHTML = roundNumber(a.x); document.getElementById('y').innerHTML = roundNumber(a.y); document.getElementById('z').innerHTML = roundNumber(a.z); document.getElementById('t').innerHTML = a.timestamp; console.log(\"getAccel success callback\"); }; // Fail callback var fail = function (e) { console.log(\"getAccel fail callback with error code \" + e); setAccelStatus(e); }; // Make call var opt = {}; navigator.accelerometer.getCurrentAcceleration(success, fail, opt); }; /******************************************************************************/ var accelerometer_tests = '&lt;div id=\"getAcceleration\"&gt;&lt;/div&gt;' + 'Expected result: Will update the status box with X, Y, and Z values when pressed. Status will read \"Stopped\"' + '&lt;p/&gt; &lt;div id=\"watchAcceleration\"&gt;&lt;/div&gt;' + 'Expected result: When pressed, will start a watch on the accelerometer and update X,Y,Z values when movement is sensed. Status will read \"Running\"' + '&lt;p/&gt; &lt;div id=\"clearAcceleration\"&gt;&lt;/div&gt;' + 'Expected result: Will clear the accelerometer watch, so X,Y,Z values will no longer be updated. Status will read \"Stopped\"'; contentEl.innerHTML = '&lt;div id=\"info\"&gt;' + 'Status: &lt;span id=\"accel_status\"&gt;Stopped&lt;/span&gt;' + '&lt;table width=\"100%\"&gt;' + '&lt;tr&gt;&lt;td width=\"30%\"&gt;X:&lt;/td&gt;&lt;td id=\"x\"&gt; &lt;/td&gt;&lt;/tr&gt;' + '&lt;tr&gt;&lt;td width=\"30%\"&gt;Y:&lt;/td&gt;&lt;td id=\"y\"&gt; &lt;/td&gt;&lt;/tr&gt;' + '&lt;tr&gt;&lt;td width=\"30%\"&gt;Z:&lt;/td&gt;&lt;td id=\"z\"&gt; &lt;/td&gt;&lt;/tr&gt;' + '&lt;tr&gt;&lt;td width=\"30%\"&gt;Timestamp:&lt;/td&gt;&lt;td id=\"t\"&gt; &lt;/td&gt;&lt;/tr&gt;' + '&lt;/table&gt;&lt;/div&gt;' + accelerometer_tests; createActionButton('Get Acceleration', function () { getAccel(); }, 'getAcceleration'); createActionButton('Start Watch', function () { watchAccel(); }, 'watchAcceleration'); createActionButton('Clear Watch', function () { stopAccel(); }, 'clearAcceleration'); }; × Search results Close "},"cordova-plugin-geolocation_tests_tests.js.html":{"id":"cordova-plugin-geolocation_tests_tests.js.html","title":"Source: cordova-plugin-geolocation/tests/tests.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: cordova-plugin-geolocation/tests/tests.js /* * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. * */ /* eslint-env jasmine */ /* global WinJS, device */ exports.defineAutoTests = function () { var fail = function (done, context, message) { // prevents done() to be called several times if (context) { if (context.done) return; context.done = true; } if (message) { expect(false).toBe(true, message); } else { expect(false).toBe(true); } // watchPosition could call its callback sync (before returning the value) // so we invoke done async to make sure we know watcher id to .clear in afterEach setTimeout(function () { done(); }); }; var succeed = function (done, context) { // prevents done() to be called several times if (context) { if (context.done) return; context.done = true; } expect(true).toBe(true); // watchPosition could call its callback sync (before returning the value) // so we invoke done async to make sure we know watcher id to .clear in afterEach setTimeout(function () { done(); }); }; // On Windows, some tests prompt user for permission to use geolocation and interrupt autotests run var isWindowsStore = (cordova.platformId === 'windows8') || (cordova.platformId === 'windows' &amp;&amp; !WinJS.Utilities.isPhone); // eslint-disable-line no-undef var majorDeviceVersion = null; var versionRegex = /(\\d)\\..+/.exec(device.version); if (versionRegex !== null) { majorDeviceVersion = Number(versionRegex[1]); } // Starting from Android 6.0 there are confirmation dialog which prevents us from running auto tests in silent mode (user interaction needed) // Also, Android emulator doesn't provide geo fix without manual interactions or mocks var skipAndroid = cordova.platformId === 'android' &amp;&amp; (device.isVirtual || majorDeviceVersion &gt;= 6); // eslint-disable-line no-undef var isIOSSim = false; // if iOS simulator does not have a location set, it will fail. describe('Geolocation (navigator.geolocation)', function () { it('geolocation.spec.1 should exist', function () { expect(navigator.geolocation).toBeDefined(); }); it('geolocation.spec.2 should contain a getCurrentPosition function', function () { expect(typeof navigator.geolocation.getCurrentPosition).toBeDefined(); expect(typeof navigator.geolocation.getCurrentPosition === 'function').toBe(true); }); it('geolocation.spec.3 should contain a watchPosition function', function () { expect(typeof navigator.geolocation.watchPosition).toBeDefined(); expect(typeof navigator.geolocation.watchPosition === 'function').toBe(true); }); it('geolocation.spec.4 should contain a clearWatch function', function () { expect(typeof navigator.geolocation.clearWatch).toBeDefined(); expect(typeof navigator.geolocation.clearWatch === 'function').toBe(true); }); }); describe('getCurrentPosition method', function () { describe('error callback', function () { it('geolocation.spec.5 should be called if we set timeout to 0 and maximumAge to a very small number', function (done) { if (isWindowsStore || skipAndroid) { pending(); } navigator.geolocation.getCurrentPosition( fail.bind(null, done), succeed.bind(null, done), { maximumAge: 0, timeout: 0 }); }); it('geolocation.spec.9 on failure should return PositionError object with error code constants', function (done) { if (isWindowsStore || skipAndroid) { pending(); } navigator.geolocation.getCurrentPosition( fail.bind(this, done), function (gpsError) { // W3C specs: http://dev.w3.org/geo/api/spec-source.html#position_error_interface expect(gpsError.PERMISSION_DENIED).toBe(1); expect(gpsError.POSITION_UNAVAILABLE).toBe(2); expect(gpsError.TIMEOUT).toBe(3); done(); }, { maximumAge: 0, timeout: 0 }); }); }); describe('success callback', function () { it('geolocation.spec.6 should be called with a Position object', function (done) { if (isWindowsStore || skipAndroid) { pending(); } navigator.geolocation.getCurrentPosition(function (p) { expect(p.coords).toBeDefined(); expect(p.timestamp).toBeDefined(); done(); }, function (err) { if (err.message &amp;&amp; err.message.indexOf('kCLErrorDomain') &gt; -1) { console.log('Error: Location not set in simulator, tests will fail.'); expect(true).toBe(true); isIOSSim = true; done(); } else { fail(done); } }, { maximumAge: (5 * 60 * 1000) // 5 minutes maximum age of cached position }); }, 25000); // first geolocation call can take several seconds on some devices }); }); describe('watchPosition method', function () { beforeEach(function (done) { // This timeout is set to lessen the load on platform's geolocation services // which were causing occasional test failures setTimeout(function () { done(); }, 100); }); describe('error callback', function () { var errorWatch = null; afterEach(function () { navigator.geolocation.clearWatch(errorWatch); }); it('geolocation.spec.7 should be called if we set timeout to 0 and maximumAge to a very small number', function (done) { if (isWindowsStore || skipAndroid) { pending(); } var context = this; errorWatch = navigator.geolocation.watchPosition( fail.bind(null, done, context, 'Unexpected win'), succeed.bind(null, done, context), { maximumAge: 0, timeout: 0 }); }); it('geolocation.spec.10 on failure should return PositionError object with error code constants', function (done) { if (isWindowsStore || skipAndroid) { pending(); } var context = this; errorWatch = navigator.geolocation.watchPosition( fail.bind(this, done, context, 'Unexpected win'), function (gpsError) { if (context.done) return; context.done = true; // W3C specs: http://dev.w3.org/geo/api/spec-source.html#position_error_interface expect(gpsError.PERMISSION_DENIED).toBe(1); expect(gpsError.POSITION_UNAVAILABLE).toBe(2); expect(gpsError.TIMEOUT).toBe(3); done(); }, { maximumAge: 0, timeout: 0 }); }); }); describe('success callback', function () { var successWatch = null; afterEach(function () { navigator.geolocation.clearWatch(successWatch); }); it('geolocation.spec.8 should be called with a Position object', function (done) { if (isWindowsStore || skipAndroid || isIOSSim) { pending(); } var context = this; successWatch = navigator.geolocation.watchPosition( function (p) { // prevents done() to be called several times if (context.done) return; context.done = true; expect(p.coords).toBeDefined(); expect(p.timestamp).toBeDefined(); // callback could be called sync so we invoke done async to make sure we know watcher id to .clear in afterEach setTimeout(function () { done(); }); }, fail.bind(null, done, context, 'Unexpected fail callback'), { maximumAge: (5 * 60 * 1000) // 5 minutes maximum age of cached position }); expect(successWatch).toBeDefined(); }); }); }); }; /******************************************************************************/ /******************************************************************************/ /******************************************************************************/ exports.defineManualTests = function (contentEl, createActionButton) { var watchLocationId = null; /** * Set location status */ function setLocationStatus (status) { document.getElementById('location_status').innerHTML = status; } function setLocationDetails (p) { var date = (new Date(p.timestamp)); document.getElementById('latitude').innerHTML = p.coords.latitude; document.getElementById('longitude').innerHTML = p.coords.longitude; document.getElementById('altitude').innerHTML = p.coords.altitude; document.getElementById('accuracy').innerHTML = p.coords.accuracy; document.getElementById('heading').innerHTML = p.coords.heading; document.getElementById('speed').innerHTML = p.coords.speed; document.getElementById('altitude_accuracy').innerHTML = p.coords.altitudeAccuracy; document.getElementById('timestamp').innerHTML = date.toDateString() + ' ' + date.toTimeString(); } /** * Stop watching the location */ function stopLocation () { var geo = navigator.geolocation; if (!geo) { alert('navigator.geolocation object is missing.'); // eslint-disable-line no-undef return; } setLocationStatus('Stopped'); if (watchLocationId) { geo.clearWatch(watchLocationId); watchLocationId = null; } } /** * Start watching location */ var watchLocation = function () { var geo = navigator.geolocation; if (!geo) { alert('navigator.geolocation object is missing.'); // eslint-disable-line no-undef return; } // Success callback var success = function (p) { setLocationDetails(p); }; // Fail callback var fail = function (e) { console.log('watchLocation fail callback with error code ' + e); stopLocation(geo); }; // Get location watchLocationId = geo.watchPosition(success, fail, { enableHighAccuracy: true }); setLocationStatus('Running'); }; /** * Get current location */ var getLocation = function (opts) { var geo = navigator.geolocation; if (!geo) { alert('navigator.geolocation object is missing.'); // eslint-disable-line no-undef return; } // Stop location if running stopLocation(geo); // Success callback var success = function (p) { setLocationDetails(p); setLocationStatus('Done'); }; // Fail callback var fail = function (e) { console.log('getLocation fail callback with error code ' + e.code); setLocationStatus('Error: ' + e.code); }; setLocationStatus('Retrieving location...'); // Get location geo.getCurrentPosition(success, fail, opts || { enableHighAccuracy: true }); //, {timeout: 10000}); }; /******************************************************************************/ var location_div = '&lt;div id=\"info\"&gt;' + '&lt;b&gt;Status:&lt;/b&gt; &lt;span id=\"location_status\"&gt;Stopped&lt;/span&gt;' + '&lt;table width=\"100%\"&gt;'; var latitude = '&lt;tr&gt;' + '&lt;td&gt;&lt;b&gt;Latitude:&lt;/b&gt;&lt;/td&gt;' + '&lt;td id=\"latitude\"&gt;&amp;nbsp;&lt;/td&gt;' + '&lt;td&gt;(decimal degrees) geographic coordinate [&lt;a href=\"http://dev.w3.org/geo/api/spec-source.html#lat\"&gt;#ref]&lt;/a&gt;&lt;/td&gt;' + '&lt;/tr&gt;'; var longitude = '&lt;tr&gt;' + '&lt;td&gt;&lt;b&gt;Longitude:&lt;/b&gt;&lt;/td&gt;' + '&lt;td id=\"longitude\"&gt;&amp;nbsp;&lt;/td&gt;' + '&lt;td&gt;(decimal degrees) geographic coordinate [&lt;a href=\"http://dev.w3.org/geo/api/spec-source.html#lat\"&gt;#ref]&lt;/a&gt;&lt;/td&gt;' + '&lt;/tr&gt;'; var altitude = '&lt;tr&gt;' + '&lt;td&gt;&lt;b&gt;Altitude:&lt;/b&gt;&lt;/td&gt;' + '&lt;td id=\"altitude\"&gt;&amp;nbsp;&lt;/td&gt;' + '&lt;td&gt;null if not supported;&lt;br&gt;' + '(meters) height above the [&lt;a href=\"http://dev.w3.org/geo/api/spec-source.html#ref-wgs\"&gt;WGS84&lt;/a&gt;] ellipsoid. [&lt;a href=\"http://dev.w3.org/geo/api/spec-source.html#altitude\"&gt;#ref]&lt;/a&gt;&lt;/td&gt;' + '&lt;/tr&gt;'; var accuracy = '&lt;tr&gt;' + '&lt;td&gt;&lt;b&gt;Accuracy:&lt;/b&gt;&lt;/td&gt;' + '&lt;td id=\"accuracy\"&gt;&amp;nbsp;&lt;/td&gt;' + '&lt;td&gt;(meters; non-negative; 95% confidence level) the accuracy level of the latitude and longitude coordinates. [&lt;a href=\"http://dev.w3.org/geo/api/spec-source.html#accuracy\"&gt;#ref]&lt;/a&gt;&lt;/td&gt;' + '&lt;/tr&gt;'; var heading = '&lt;tr&gt;' + '&lt;td&gt;&lt;b&gt;Heading:&lt;/b&gt;&lt;/td&gt;' + '&lt;td id=\"heading\"&gt;&amp;nbsp;&lt;/td&gt;' + '&lt;td&gt;null if not supported;&lt;br&gt;' + 'NaN if speed == 0;&lt;br&gt;' + '(degrees; 0° ≤ heading &lt; 360°) direction of travel of the hosting device- counting clockwise relative to the true north. [&lt;a href=\"http://dev.w3.org/geo/api/spec-source.html#heading\"&gt;#ref]&lt;/a&gt;&lt;/td&gt;' + '&lt;/tr&gt;'; var speed = '&lt;tr&gt;' + '&lt;td&gt;&lt;b&gt;Speed:&lt;/b&gt;&lt;/td&gt;' + '&lt;td id=\"speed\"&gt;&amp;nbsp;&lt;/td&gt;' + '&lt;td&gt;null if not supported;&lt;br&gt;' + '(meters per second; non-negative) magnitude of the horizontal component of the hosting device current velocity. [&lt;a href=\"http://dev.w3.org/geo/api/spec-source.html#speed\"&gt;#ref]&lt;/a&gt;&lt;/td&gt;' + '&lt;/tr&gt;'; var altitude_accuracy = '&lt;tr&gt;' + '&lt;td&gt;&lt;b&gt;Altitude Accuracy:&lt;/b&gt;&lt;/td&gt;' + '&lt;td id=\"altitude_accuracy\"&gt;&amp;nbsp;&lt;/td&gt;' + '&lt;td&gt;null if not supported;&lt;br&gt;(meters; non-negative; 95% confidence level) the accuracy level of the altitude. [&lt;a href=\"http://dev.w3.org/geo/api/spec-source.html#altitude-accuracy\"&gt;#ref]&lt;/a&gt;&lt;/td&gt;' + '&lt;/tr&gt;'; var time = '&lt;tr&gt;' + '&lt;td&gt;&lt;b&gt;Time:&lt;/b&gt;&lt;/td&gt;' + '&lt;td id=\"timestamp\"&gt;&amp;nbsp;&lt;/td&gt;' + '&lt;td&gt;(DOMTimeStamp) when the position was acquired [&lt;a href=\"http://dev.w3.org/geo/api/spec-source.html#timestamp\"&gt;#ref]&lt;/a&gt;&lt;/td&gt;' + '&lt;/tr&gt;' + '&lt;/table&gt;' + '&lt;/div&gt;'; var actions = '&lt;div id=\"cordova-getLocation\"&gt;&lt;/div&gt;' + 'Expected result: Will update all applicable values in status box for current location. Status will read Retrieving Location (may not see this if location is retrieved immediately) then Done.' + '&lt;p/&gt; &lt;div id=\"cordova-watchLocation\"&gt;&lt;/div&gt;' + 'Expected result: Will update all applicable values in status box for current location and update as location changes. Status will read Running.' + '&lt;p/&gt; &lt;div id=\"cordova-stopLocation\"&gt;&lt;/div&gt;' + 'Expected result: Will stop watching the location so values will not be updated. Status will read Stopped.' + '&lt;p/&gt; &lt;div id=\"cordova-getOld\"&gt;&lt;/div&gt;' + 'Expected result: Will update location values with a cached position that is up to 30 seconds old. Verify with time value. Status will read Done.'; var values_info = '&lt;h3&gt;Details about each value are listed below in the status box&lt;/h3&gt;'; var note = '&lt;h3&gt;Allow use of current location, if prompted&lt;/h3&gt;'; contentEl.innerHTML = values_info + location_div + latitude + longitude + altitude + accuracy + heading + speed + altitude_accuracy + time + note + actions; createActionButton('Get Location', function () { getLocation(); }, 'cordova-getLocation'); createActionButton('Start Watching Location', function () { watchLocation(); }, 'cordova-watchLocation'); createActionButton('Stop Watching Location', function () { stopLocation(); }, 'cordova-stopLocation'); createActionButton('Get Location Up to 30 Sec Old', function () { getLocation({ maximumAge: 30000 }); }, 'cordova-getOld'); }; × Search results Close "},"cordova-plugin-device_www_device.js.html":{"id":"cordova-plugin-device_www_device.js.html","title":"Source: cordova-plugin-device/www/device.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: cordova-plugin-device/www/device.js /* * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. * */ var argscheck = require('cordova/argscheck'); var channel = require('cordova/channel'); var utils = require('cordova/utils'); var exec = require('cordova/exec'); var cordova = require('cordova'); channel.createSticky('onCordovaInfoReady'); // Tell cordova channel to wait on the CordovaInfoReady event channel.waitForInitialization('onCordovaInfoReady'); /** * This represents the mobile device, and provides properties for inspecting the model, version, UUID of the * phone, etc. * @constructor * @property {boolean} cordova - Get the version of Cordova running on the device. * @property {string} model - The device.model returns the name of the device's model or product. * @property {string} platform - Get the device's operating system name. * @property {string} uuid - Get the device's Universally Unique Identifier. * @property {string} version - Get the operating system version. * @property {string} manufacturer - Get the device's manufacturer. * @property {boolean} isVirtual - whether the device is running on a simulator. * @property {string} serial - Get the device hardware serial number. */ function Device () { this.available = false; this.platform = null; this.version = null; this.uuid = null; this.cordova = null; this.model = null; this.manufacturer = null; this.isVirtual = null; this.serial = null; var me = this; channel.onCordovaReady.subscribe(function () { me.getInfo(function (info) { // ignoring info.cordova returning from native, we should use value from cordova.version defined in cordova.js // TODO: CB-5105 native implementations should not return info.cordova var buildLabel = cordova.version; me.available = true; me.platform = info.platform; me.version = info.version; me.uuid = info.uuid; me.cordova = buildLabel; me.model = info.model; me.isVirtual = info.isVirtual; me.manufacturer = info.manufacturer || 'unknown'; me.serial = info.serial || 'unknown'; channel.onCordovaInfoReady.fire(); }, function (e) { me.available = false; utils.alert('[ERROR] Error initializing Cordova: ' + e); }); }); } /** * Get device info * * @param {Function} successCallback The function to call when the heading data is available * @param {Function} errorCallback The function to call when there is an error getting the heading data. (OPTIONAL) */ Device.prototype.getInfo = function (successCallback, errorCallback) { argscheck.checkArgs('fF', 'Device.getInfo', arguments); exec(successCallback, errorCallback, 'Device', 'getDeviceInfo', []); }; module.exports = new Device(); × Search results Close "},"cordova-plugin-file_www_DirectoryEntry.js.html":{"id":"cordova-plugin-file_www_DirectoryEntry.js.html","title":"Source: cordova-plugin-file/www/DirectoryEntry.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: cordova-plugin-file/www/DirectoryEntry.js /* * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. * */ var argscheck = require('cordova/argscheck'); var utils = require('cordova/utils'); var exec = require('cordova/exec'); var Entry = require('./Entry'); var FileError = require('./FileError'); var DirectoryReader = require('./DirectoryReader'); /** * An interface representing a directory on the file system. * * {boolean} isFile always false (readonly) * {boolean} isDirectory always true (readonly) * {DOMString} name of the directory, excluding the path leading to it (readonly) * {DOMString} fullPath the absolute full path to the directory (readonly) * {FileSystem} filesystem on which the directory resides (readonly) */ var DirectoryEntry = function (name, fullPath, fileSystem, nativeURL) { // add trailing slash if it is missing if ((fullPath) &amp;&amp; !/\\/$/.test(fullPath)) { fullPath += '/'; } // add trailing slash if it is missing if (nativeURL &amp;&amp; !/\\/$/.test(nativeURL)) { nativeURL += '/'; } DirectoryEntry.__super__.constructor.call(this, false, true, name, fullPath, fileSystem, nativeURL); }; utils.extend(DirectoryEntry, Entry); /** * Creates a new DirectoryReader to read entries from this directory */ DirectoryEntry.prototype.createReader = function () { return new DirectoryReader(this.toInternalURL()); }; /** * Creates or looks up a directory * * @param {DOMString} path either a relative or absolute path from this directory in which to look up or create a directory * @param {Flags} options to create or exclusively create the directory * @param {Function} successCallback is called with the new entry * @param {Function} errorCallback is called with a FileError */ DirectoryEntry.prototype.getDirectory = function (path, options, successCallback, errorCallback) { argscheck.checkArgs('sOFF', 'DirectoryEntry.getDirectory', arguments); var fs = this.filesystem; var win = successCallback &amp;&amp; function (result) { var entry = new DirectoryEntry(result.name, result.fullPath, fs, result.nativeURL); successCallback(entry); }; var fail = errorCallback &amp;&amp; function (code) { errorCallback(new FileError(code)); }; exec(win, fail, 'File', 'getDirectory', [this.toInternalURL(), path, options]); }; /** * Deletes a directory and all of it's contents * * @param {Function} successCallback is called with no parameters * @param {Function} errorCallback is called with a FileError */ DirectoryEntry.prototype.removeRecursively = function (successCallback, errorCallback) { argscheck.checkArgs('FF', 'DirectoryEntry.removeRecursively', arguments); var fail = errorCallback &amp;&amp; function (code) { errorCallback(new FileError(code)); }; exec(successCallback, fail, 'File', 'removeRecursively', [this.toInternalURL()]); }; /** * Creates or looks up a file * * @param {DOMString} path either a relative or absolute path from this directory in which to look up or create a file * @param {Flags} options to create or exclusively create the file * @param {Function} successCallback is called with the new entry * @param {Function} errorCallback is called with a FileError */ DirectoryEntry.prototype.getFile = function (path, options, successCallback, errorCallback) { argscheck.checkArgs('sOFF', 'DirectoryEntry.getFile', arguments); var fs = this.filesystem; var win = successCallback &amp;&amp; function (result) { var FileEntry = require('./FileEntry'); var entry = new FileEntry(result.name, result.fullPath, fs, result.nativeURL); successCallback(entry); }; var fail = errorCallback &amp;&amp; function (code) { errorCallback(new FileError(code)); }; exec(win, fail, 'File', 'getFile', [this.toInternalURL(), path, options]); }; module.exports = DirectoryEntry; × Search results Close "},"cordova-plugin-file_www_DirectoryReader.js.html":{"id":"cordova-plugin-file_www_DirectoryReader.js.html","title":"Source: cordova-plugin-file/www/DirectoryReader.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: cordova-plugin-file/www/DirectoryReader.js /* * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. * */ var exec = require('cordova/exec'); var FileError = require('./FileError'); /** * An interface that lists the files and directories in a directory. */ function DirectoryReader (localURL) { this.localURL = localURL || null; this.hasReadEntries = false; } /** * Returns a list of entries from a directory. * * @param {Function} successCallback is called with a list of entries * @param {Function} errorCallback is called with a FileError */ DirectoryReader.prototype.readEntries = function (successCallback, errorCallback) { // If we've already read and passed on this directory's entries, return an empty list. if (this.hasReadEntries) { successCallback([]); return; } var reader = this; var win = typeof successCallback !== 'function' ? null : function (result) { var retVal = []; for (var i = 0; i &lt; result.length; i++) { var entry = null; if (result[i].isDirectory) { entry = new (require('./DirectoryEntry'))(); } else if (result[i].isFile) { entry = new (require('./FileEntry'))(); } entry.isDirectory = result[i].isDirectory; entry.isFile = result[i].isFile; entry.name = result[i].name; entry.fullPath = result[i].fullPath; entry.filesystem = new (require('./FileSystem'))(result[i].filesystemName); entry.nativeURL = result[i].nativeURL; retVal.push(entry); } reader.hasReadEntries = true; successCallback(retVal); }; var fail = typeof errorCallback !== 'function' ? null : function (code) { errorCallback(new FileError(code)); }; exec(win, fail, 'File', 'readEntries', [this.localURL]); }; module.exports = DirectoryReader; × Search results Close "},"cordova-plugin-file_www_Entry.js.html":{"id":"cordova-plugin-file_www_Entry.js.html","title":"Source: cordova-plugin-file/www/Entry.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: cordova-plugin-file/www/Entry.js /* * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. * */ var argscheck = require('cordova/argscheck'); var exec = require('cordova/exec'); var FileError = require('./FileError'); var Metadata = require('./Metadata'); /** * Represents a file or directory on the local file system. * * @param isFile * {boolean} true if Entry is a file (readonly) * @param isDirectory * {boolean} true if Entry is a directory (readonly) * @param name * {DOMString} name of the file or directory, excluding the path * leading to it (readonly) * @param fullPath * {DOMString} the absolute full path to the file or directory * (readonly) * @param fileSystem * {FileSystem} the filesystem on which this entry resides * (readonly) * @param nativeURL * {DOMString} an alternate URL which can be used by native * webview controls, for example media players. * (optional, readonly) */ function Entry (isFile, isDirectory, name, fullPath, fileSystem, nativeURL) { this.isFile = !!isFile; this.isDirectory = !!isDirectory; this.name = name || ''; this.fullPath = fullPath || ''; this.filesystem = fileSystem || null; this.nativeURL = nativeURL || null; } /** * Look up the metadata of the entry. * * @param successCallback * {Function} is called with a Metadata object * @param errorCallback * {Function} is called with a FileError */ Entry.prototype.getMetadata = function (successCallback, errorCallback) { argscheck.checkArgs('FF', 'Entry.getMetadata', arguments); var success = successCallback &amp;&amp; function (entryMetadata) { var metadata = new Metadata({ size: entryMetadata.size, modificationTime: entryMetadata.lastModifiedDate }); successCallback(metadata); }; var fail = errorCallback &amp;&amp; function (code) { errorCallback(new FileError(code)); }; exec(success, fail, 'File', 'getFileMetadata', [this.toInternalURL()]); }; /** * Set the metadata of the entry. * * @param successCallback * {Function} is called with a Metadata object * @param errorCallback * {Function} is called with a FileError * @param metadataObject * {Object} keys and values to set */ Entry.prototype.setMetadata = function (successCallback, errorCallback, metadataObject) { argscheck.checkArgs('FFO', 'Entry.setMetadata', arguments); exec(successCallback, errorCallback, 'File', 'setMetadata', [this.toInternalURL(), metadataObject]); }; /** * Move a file or directory to a new location. * * @param parent * {DirectoryEntry} the directory to which to move this entry * @param newName * {DOMString} new name of the entry, defaults to the current name * @param successCallback * {Function} called with the new DirectoryEntry object * @param errorCallback * {Function} called with a FileError */ Entry.prototype.moveTo = function (parent, newName, successCallback, errorCallback) { argscheck.checkArgs('oSFF', 'Entry.moveTo', arguments); var fail = errorCallback &amp;&amp; function (code) { errorCallback(new FileError(code)); }; var srcURL = this.toInternalURL(); // entry name var name = newName || this.name; var success = function (entry) { if (entry) { if (successCallback) { // create appropriate Entry object var newFSName = entry.filesystemName || (entry.filesystem &amp;&amp; entry.filesystem.name); var fs = newFSName ? new FileSystem(newFSName, { name: '', fullPath: '/' }) : new FileSystem(parent.filesystem.name, { name: '', fullPath: '/' }); // eslint-disable-line no-undef var result = (entry.isDirectory) ? new (require('./DirectoryEntry'))(entry.name, entry.fullPath, fs, entry.nativeURL) : new (require('cordova-plugin-file.FileEntry'))(entry.name, entry.fullPath, fs, entry.nativeURL); successCallback(result); } } else { // no Entry object returned if (fail) { fail(FileError.NOT_FOUND_ERR); } } }; // copy exec(success, fail, 'File', 'moveTo', [srcURL, parent.toInternalURL(), name]); }; /** * Copy a directory to a different location. * * @param parent * {DirectoryEntry} the directory to which to copy the entry * @param newName * {DOMString} new name of the entry, defaults to the current name * @param successCallback * {Function} called with the new Entry object * @param errorCallback * {Function} called with a FileError */ Entry.prototype.copyTo = function (parent, newName, successCallback, errorCallback) { argscheck.checkArgs('oSFF', 'Entry.copyTo', arguments); var fail = errorCallback &amp;&amp; function (code) { errorCallback(new FileError(code)); }; var srcURL = this.toInternalURL(); // entry name var name = newName || this.name; // success callback var success = function (entry) { if (entry) { if (successCallback) { // create appropriate Entry object var newFSName = entry.filesystemName || (entry.filesystem &amp;&amp; entry.filesystem.name); var fs = newFSName ? new FileSystem(newFSName, { name: '', fullPath: '/' }) : new FileSystem(parent.filesystem.name, { name: '', fullPath: '/' }); // eslint-disable-line no-undef var result = (entry.isDirectory) ? new (require('./DirectoryEntry'))(entry.name, entry.fullPath, fs, entry.nativeURL) : new (require('cordova-plugin-file.FileEntry'))(entry.name, entry.fullPath, fs, entry.nativeURL); successCallback(result); } } else { // no Entry object returned if (fail) { fail(FileError.NOT_FOUND_ERR); } } }; // copy exec(success, fail, 'File', 'copyTo', [srcURL, parent.toInternalURL(), name]); }; /** * Return a URL that can be passed across the bridge to identify this entry. */ Entry.prototype.toInternalURL = function () { if (this.filesystem &amp;&amp; this.filesystem.__format__) { return this.filesystem.__format__(this.fullPath, this.nativeURL); } }; /** * Return a URL that can be used to identify this entry. * Use a URL that can be used to as the src attribute of a &lt;video&gt; or * &lt;audio&gt; tag. If that is not possible, construct a cdvfile:// URL. */ Entry.prototype.toURL = function () { if (this.nativeURL) { return this.nativeURL; } // fullPath attribute may contain the full URL in the case that // toInternalURL fails. return this.toInternalURL() || 'file://localhost' + this.fullPath; }; /** * Backwards-compatibility: In v1.0.0 - 1.0.2, .toURL would only return a * cdvfile:// URL, and this method was necessary to obtain URLs usable by the * webview. * See CB-6051, CB-6106, CB-6117, CB-6152, CB-6199, CB-6201, CB-6243, CB-6249, * and CB-6300. */ Entry.prototype.toNativeURL = function () { console.log(\"DEPRECATED: Update your code to use 'toURL'\"); return this.toURL(); }; /** * Returns a URI that can be used to identify this entry. * * @param {DOMString} mimeType for a FileEntry, the mime type to be used to interpret the file, when loaded through this URI. * @return uri */ Entry.prototype.toURI = function (mimeType) { console.log(\"DEPRECATED: Update your code to use 'toURL'\"); return this.toURL(); }; /** * Remove a file or directory. It is an error to attempt to delete a * directory that is not empty. It is an error to attempt to delete a * root directory of a file system. * * @param successCallback {Function} called with no parameters * @param errorCallback {Function} called with a FileError */ Entry.prototype.remove = function (successCallback, errorCallback) { argscheck.checkArgs('FF', 'Entry.remove', arguments); var fail = errorCallback &amp;&amp; function (code) { errorCallback(new FileError(code)); }; exec(successCallback, fail, 'File', 'remove', [this.toInternalURL()]); }; /** * Look up the parent DirectoryEntry of this entry. * * @param successCallback {Function} called with the parent DirectoryEntry object * @param errorCallback {Function} called with a FileError */ Entry.prototype.getParent = function (successCallback, errorCallback) { argscheck.checkArgs('FF', 'Entry.getParent', arguments); var fs = this.filesystem; var win = successCallback &amp;&amp; function (result) { var DirectoryEntry = require('./DirectoryEntry'); var entry = new DirectoryEntry(result.name, result.fullPath, fs, result.nativeURL); successCallback(entry); }; var fail = errorCallback &amp;&amp; function (code) { errorCallback(new FileError(code)); }; exec(win, fail, 'File', 'getParent', [this.toInternalURL()]); }; module.exports = Entry; × Search results Close "},"cordova-plugin-file_www_File.js.html":{"id":"cordova-plugin-file_www_File.js.html","title":"Source: cordova-plugin-file/www/File.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: cordova-plugin-file/www/File.js /* * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. * */ /** * Constructor. * name {DOMString} name of the file, without path information * fullPath {DOMString} the full path of the file, including the name * type {DOMString} mime type * lastModifiedDate {Date} last modified date * size {Number} size of the file in bytes */ var File = function (name, localURL, type, lastModifiedDate, size) { this.name = name || ''; this.localURL = localURL || null; this.type = type || null; this.lastModified = lastModifiedDate || null; // For backwards compatibility, store the timestamp in lastModifiedDate as well this.lastModifiedDate = lastModifiedDate || null; this.size = size || 0; // These store the absolute start and end for slicing the file. this.start = 0; this.end = this.size; }; /** * Returns a \"slice\" of the file. Since Cordova Files don't contain the actual * content, this really returns a File with adjusted start and end. * Slices of slices are supported. * start {Number} The index at which to start the slice (inclusive). * end {Number} The index at which to end the slice (exclusive). */ File.prototype.slice = function (start, end) { var size = this.end - this.start; var newStart = 0; var newEnd = size; if (arguments.length) { if (start &lt; 0) { newStart = Math.max(size + start, 0); } else { newStart = Math.min(size, start); } } if (arguments.length &gt;= 2) { if (end &lt; 0) { newEnd = Math.max(size + end, 0); } else { newEnd = Math.min(end, size); } } var newFile = new File(this.name, this.localURL, this.type, this.lastModified, this.size); newFile.start = this.start + newStart; newFile.end = this.start + newEnd; return newFile; }; module.exports = File; × Search results Close "},"cordova-plugin-file_www_FileEntry.js.html":{"id":"cordova-plugin-file_www_FileEntry.js.html","title":"Source: cordova-plugin-file/www/FileEntry.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: cordova-plugin-file/www/FileEntry.js /* * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. * */ var utils = require('cordova/utils'); var exec = require('cordova/exec'); var Entry = require('./Entry'); var FileWriter = require('./FileWriter'); var File = require('./File'); var FileError = require('./FileError'); /** * An interface representing a file on the file system. * * {boolean} isFile always true (readonly) * {boolean} isDirectory always false (readonly) * {DOMString} name of the file, excluding the path leading to it (readonly) * {DOMString} fullPath the absolute full path to the file (readonly) * {FileSystem} filesystem on which the file resides (readonly) */ var FileEntry = function (name, fullPath, fileSystem, nativeURL) { // remove trailing slash if it is present if (fullPath &amp;&amp; /\\/$/.test(fullPath)) { fullPath = fullPath.substring(0, fullPath.length - 1); } if (nativeURL &amp;&amp; /\\/$/.test(nativeURL)) { nativeURL = nativeURL.substring(0, nativeURL.length - 1); } FileEntry.__super__.constructor.apply(this, [true, false, name, fullPath, fileSystem, nativeURL]); }; utils.extend(FileEntry, Entry); /** * Creates a new FileWriter associated with the file that this FileEntry represents. * * @param {Function} successCallback is called with the new FileWriter * @param {Function} errorCallback is called with a FileError */ FileEntry.prototype.createWriter = function (successCallback, errorCallback) { this.file(function (filePointer) { var writer = new FileWriter(filePointer); if (writer.localURL === null || writer.localURL === '') { if (errorCallback) { errorCallback(new FileError(FileError.INVALID_STATE_ERR)); } } else { if (successCallback) { successCallback(writer); } } }, errorCallback); }; /** * Returns a File that represents the current state of the file that this FileEntry represents. * * @param {Function} successCallback is called with the new File object * @param {Function} errorCallback is called with a FileError */ FileEntry.prototype.file = function (successCallback, errorCallback) { var localURL = this.toInternalURL(); var win = successCallback &amp;&amp; function (f) { var file = new File(f.name, localURL, f.type, f.lastModifiedDate, f.size); successCallback(file); }; var fail = errorCallback &amp;&amp; function (code) { errorCallback(new FileError(code)); }; exec(win, fail, 'File', 'getFileMetadata', [localURL]); }; module.exports = FileEntry; × Search results Close "},"cordova-plugin-file_www_FileError.js.html":{"id":"cordova-plugin-file_www_FileError.js.html","title":"Source: cordova-plugin-file/www/FileError.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: cordova-plugin-file/www/FileError.js /* * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. * */ /** * FileError */ function FileError (error) { this.code = error || null; } // File error codes // Found in DOMException FileError.NOT_FOUND_ERR = 1; FileError.SECURITY_ERR = 2; FileError.ABORT_ERR = 3; // Added by File API specification FileError.NOT_READABLE_ERR = 4; FileError.ENCODING_ERR = 5; FileError.NO_MODIFICATION_ALLOWED_ERR = 6; FileError.INVALID_STATE_ERR = 7; FileError.SYNTAX_ERR = 8; FileError.INVALID_MODIFICATION_ERR = 9; FileError.QUOTA_EXCEEDED_ERR = 10; FileError.TYPE_MISMATCH_ERR = 11; FileError.PATH_EXISTS_ERR = 12; module.exports = FileError; × Search results Close "},"cordova-plugin-file_www_FileReader.js.html":{"id":"cordova-plugin-file_www_FileReader.js.html","title":"Source: cordova-plugin-file/www/FileReader.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: cordova-plugin-file/www/FileReader.js /* * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. * */ var exec = require('cordova/exec'); var modulemapper = require('cordova/modulemapper'); var utils = require('cordova/utils'); var FileError = require('./FileError'); var ProgressEvent = require('./ProgressEvent'); var origFileReader = modulemapper.getOriginalSymbol(window, 'FileReader'); /** * This class reads the mobile device file system. * * For Android: * The root directory is the root of the file system. * To read from the SD card, the file name is \"sdcard/my_file.txt\" * @constructor */ var FileReader = function () { this._readyState = 0; this._error = null; this._result = null; this._progress = null; this._localURL = ''; this._realReader = origFileReader ? new origFileReader() : {}; // eslint-disable-line new-cap }; /** * Defines the maximum size to read at a time via the native API. The default value is a compromise between * minimizing the overhead of many exec() calls while still reporting progress frequently enough for large files. * (Note attempts to allocate more than a few MB of contiguous memory on the native side are likely to cause * OOM exceptions, while the JS engine seems to have fewer problems managing large strings or ArrayBuffers.) */ FileReader.READ_CHUNK_SIZE = 256 * 1024; // States FileReader.EMPTY = 0; FileReader.LOADING = 1; FileReader.DONE = 2; utils.defineGetter(FileReader.prototype, 'readyState', function () { return this._localURL ? this._readyState : this._realReader.readyState; }); utils.defineGetter(FileReader.prototype, 'error', function () { return this._localURL ? this._error : this._realReader.error; }); utils.defineGetter(FileReader.prototype, 'result', function () { return this._localURL ? this._result : this._realReader.result; }); function defineEvent (eventName) { utils.defineGetterSetter(FileReader.prototype, eventName, function () { return this._realReader[eventName] || null; }, function (value) { this._realReader[eventName] = value; }); } defineEvent('onloadstart'); // When the read starts. defineEvent('onprogress'); // While reading (and decoding) file or fileBlob data, and reporting partial file data (progress.loaded/progress.total) defineEvent('onload'); // When the read has successfully completed. defineEvent('onerror'); // When the read has failed (see errors). defineEvent('onloadend'); // When the request has completed (either in success or failure). defineEvent('onabort'); // When the read has been aborted. For instance, by invoking the abort() method. function initRead (reader, file) { // Already loading something if (reader.readyState === FileReader.LOADING) { throw new FileError(FileError.INVALID_STATE_ERR); } reader._result = null; reader._error = null; reader._progress = 0; reader._readyState = FileReader.LOADING; if (typeof file.localURL === 'string') { reader._localURL = file.localURL; } else { reader._localURL = ''; return true; } if (reader.onloadstart) { reader.onloadstart(new ProgressEvent('loadstart', {target: reader})); } } /** * Callback used by the following read* functions to handle incremental or final success. * Must be bound to the FileReader's this along with all but the last parameter, * e.g. readSuccessCallback.bind(this, \"readAsText\", \"UTF-8\", offset, totalSize, accumulate) * @param readType The name of the read function to call. * @param encoding Text encoding, or null if this is not a text type read. * @param offset Starting offset of the read. * @param totalSize Total number of bytes or chars to read. * @param accumulate A function that takes the callback result and accumulates it in this._result. * @param r Callback result returned by the last read exec() call, or null to begin reading. */ function readSuccessCallback (readType, encoding, offset, totalSize, accumulate, r) { if (this._readyState === FileReader.DONE) { return; } var CHUNK_SIZE = FileReader.READ_CHUNK_SIZE; if (readType === 'readAsDataURL') { // Windows proxy does not support reading file slices as Data URLs // so read the whole file at once. CHUNK_SIZE = cordova.platformId === 'windows' ? totalSize : // eslint-disable-line no-undef // Calculate new chunk size for data URLs to be multiply of 3 // Otherwise concatenated base64 chunks won't be valid base64 data FileReader.READ_CHUNK_SIZE - (FileReader.READ_CHUNK_SIZE % 3) + 3; } if (typeof r !== 'undefined') { accumulate(r); this._progress = Math.min(this._progress + CHUNK_SIZE, totalSize); if (typeof this.onprogress === 'function') { this.onprogress(new ProgressEvent('progress', {loaded: this._progress, total: totalSize})); } } if (typeof r === 'undefined' || this._progress &lt; totalSize) { var execArgs = [ this._localURL, offset + this._progress, offset + this._progress + Math.min(totalSize - this._progress, CHUNK_SIZE)]; if (encoding) { execArgs.splice(1, 0, encoding); } exec( readSuccessCallback.bind(this, readType, encoding, offset, totalSize, accumulate), readFailureCallback.bind(this), 'File', readType, execArgs); } else { this._readyState = FileReader.DONE; if (typeof this.onload === 'function') { this.onload(new ProgressEvent('load', {target: this})); } if (typeof this.onloadend === 'function') { this.onloadend(new ProgressEvent('loadend', {target: this})); } } } /** * Callback used by the following read* functions to handle errors. * Must be bound to the FileReader's this, e.g. readFailureCallback.bind(this) */ function readFailureCallback (e) { if (this._readyState === FileReader.DONE) { return; } this._readyState = FileReader.DONE; this._result = null; this._error = new FileError(e); if (typeof this.onerror === 'function') { this.onerror(new ProgressEvent('error', {target: this})); } if (typeof this.onloadend === 'function') { this.onloadend(new ProgressEvent('loadend', {target: this})); } } /** * Abort reading file. */ FileReader.prototype.abort = function () { if (origFileReader &amp;&amp; !this._localURL) { return this._realReader.abort(); } this._result = null; if (this._readyState === FileReader.DONE || this._readyState === FileReader.EMPTY) { return; } this._readyState = FileReader.DONE; // If abort callback if (typeof this.onabort === 'function') { this.onabort(new ProgressEvent('abort', {target: this})); } // If load end callback if (typeof this.onloadend === 'function') { this.onloadend(new ProgressEvent('loadend', {target: this})); } }; /** * Read text file. * * @param file {File} File object containing file properties * @param encoding [Optional] (see http://www.iana.org/assignments/character-sets) */ FileReader.prototype.readAsText = function (file, encoding) { if (initRead(this, file)) { return this._realReader.readAsText(file, encoding); } // Default encoding is UTF-8 var enc = encoding || 'UTF-8'; var totalSize = file.end - file.start; readSuccessCallback.bind(this)('readAsText', enc, file.start, totalSize, function (r) { if (this._progress === 0) { this._result = ''; } this._result += r; }.bind(this)); }; /** * Read file and return data as a base64 encoded data url. * A data url is of the form: * data:[&lt;mediatype&gt;][;base64],&lt;data&gt; * * @param file {File} File object containing file properties */ FileReader.prototype.readAsDataURL = function (file) { if (initRead(this, file)) { return this._realReader.readAsDataURL(file); } var totalSize = file.end - file.start; readSuccessCallback.bind(this)('readAsDataURL', null, file.start, totalSize, function (r) { var commaIndex = r.indexOf(','); if (this._progress === 0) { this._result = r; } else { this._result += r.substring(commaIndex + 1); } }.bind(this)); }; /** * Read file and return data as a binary data. * * @param file {File} File object containing file properties */ FileReader.prototype.readAsBinaryString = function (file) { if (initRead(this, file)) { return this._realReader.readAsBinaryString(file); } var totalSize = file.end - file.start; readSuccessCallback.bind(this)('readAsBinaryString', null, file.start, totalSize, function (r) { if (this._progress === 0) { this._result = ''; } this._result += r; }.bind(this)); }; /** * Read file and return data as a binary data. * * @param file {File} File object containing file properties */ FileReader.prototype.readAsArrayBuffer = function (file) { if (initRead(this, file)) { return this._realReader.readAsArrayBuffer(file); } var totalSize = file.end - file.start; readSuccessCallback.bind(this)('readAsArrayBuffer', null, file.start, totalSize, function (r) { var resultArray = (this._progress === 0 ? new Uint8Array(totalSize) : new Uint8Array(this._result)); resultArray.set(new Uint8Array(r), this._progress); this._result = resultArray.buffer; }.bind(this)); }; module.exports = FileReader; × Search results Close "},"cordova-plugin-file_www_FileSystem.js.html":{"id":"cordova-plugin-file_www_FileSystem.js.html","title":"Source: cordova-plugin-file/www/FileSystem.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: cordova-plugin-file/www/FileSystem.js /* * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. * */ var DirectoryEntry = require('./DirectoryEntry'); /** * An interface representing a file system * * {DOMString} name the unique name of the file system (readonly) * {DirectoryEntry} root directory of the file system (readonly) * @constructor */ var FileSystem = function (name, root) { this.name = name; if (root) { this.root = new DirectoryEntry(root.name, root.fullPath, this, root.nativeURL); } else { this.root = new DirectoryEntry(this.name, '/', this); } }; FileSystem.prototype.__format__ = function (fullPath, nativeUrl) { return fullPath; }; FileSystem.prototype.toJSON = function () { return '&lt;FileSystem: ' + this.name + '&gt;'; }; // Use instead of encodeURI() when encoding just the path part of a URI rather than an entire URI. FileSystem.encodeURIPath = function (path) { // Because # is a valid filename character, it must be encoded to prevent part of the // path from being parsed as a URI fragment. return encodeURI(path).replace(/#/g, '%23'); }; module.exports = FileSystem; × Search results Close "},"cordova-plugin-file_www_FileUploadOptions.js.html":{"id":"cordova-plugin-file_www_FileUploadOptions.js.html","title":"Source: cordova-plugin-file/www/FileUploadOptions.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: cordova-plugin-file/www/FileUploadOptions.js /* * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. * */ /** * Options to customize the HTTP request used to upload files. * @constructor * @param fileKey {String} Name of file request parameter. * @param fileName {String} Filename to be used by the server. Defaults to image.jpg. * @param mimeType {String} Mimetype of the uploaded file. Defaults to image/jpeg. * @param params {Object} Object with key: value params to send to the server. * @param headers {Object} Keys are header names, values are header values. Multiple * headers of the same name are not supported. */ var FileUploadOptions = function (fileKey, fileName, mimeType, params, headers, httpMethod) { this.fileKey = fileKey || null; this.fileName = fileName || null; this.mimeType = mimeType || null; this.params = params || null; this.headers = headers || null; this.httpMethod = httpMethod || null; }; module.exports = FileUploadOptions; × Search results Close "},"cordova-plugin-file_www_FileUploadResult.js.html":{"id":"cordova-plugin-file_www_FileUploadResult.js.html","title":"Source: cordova-plugin-file/www/FileUploadResult.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: cordova-plugin-file/www/FileUploadResult.js /* * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. * */ /** * FileUploadResult * @constructor */ var FileUploadResult = function FileUploadResult (size, code, content) { this.bytesSent = size; this.responseCode = code; this.response = content; }; module.exports = FileUploadResult; × Search results Close "},"cordova-plugin-file_www_FileWriter.js.html":{"id":"cordova-plugin-file_www_FileWriter.js.html","title":"Source: cordova-plugin-file/www/FileWriter.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: cordova-plugin-file/www/FileWriter.js /* * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. * */ var exec = require('cordova/exec'); var FileError = require('./FileError'); var FileReader = require('./FileReader'); var ProgressEvent = require('./ProgressEvent'); /** * This class writes to the mobile device file system. * * For Android: * The root directory is the root of the file system. * To write to the SD card, the file name is \"sdcard/my_file.txt\" * * @constructor * @param file {File} File object containing file properties * @param append if true write to the end of the file, otherwise overwrite the file */ var FileWriter = function (file) { this.fileName = ''; this.length = 0; if (file) { this.localURL = file.localURL || file; this.length = file.size || 0; } // default is to write at the beginning of the file this.position = 0; this.readyState = 0; // EMPTY this.result = null; // Error this.error = null; // Event handlers this.onwritestart = null; // When writing starts this.onprogress = null; // While writing the file, and reporting partial file data this.onwrite = null; // When the write has successfully completed. this.onwriteend = null; // When the request has completed (either in success or failure). this.onabort = null; // When the write has been aborted. For instance, by invoking the abort() method. this.onerror = null; // When the write has failed (see errors). }; // States FileWriter.INIT = 0; FileWriter.WRITING = 1; FileWriter.DONE = 2; /** * Abort writing file. */ FileWriter.prototype.abort = function () { // check for invalid state if (this.readyState === FileWriter.DONE || this.readyState === FileWriter.INIT) { throw new FileError(FileError.INVALID_STATE_ERR); } // set error this.error = new FileError(FileError.ABORT_ERR); this.readyState = FileWriter.DONE; // If abort callback if (typeof this.onabort === 'function') { this.onabort(new ProgressEvent('abort', {'target': this})); } // If write end callback if (typeof this.onwriteend === 'function') { this.onwriteend(new ProgressEvent('writeend', {'target': this})); } }; /** * Writes data to the file * * @param data text or blob to be written * @param isPendingBlobReadResult {Boolean} true if the data is the pending blob read operation result */ FileWriter.prototype.write = function (data, isPendingBlobReadResult) { var that = this; var supportsBinary = (typeof window.Blob !== 'undefined' &amp;&amp; typeof window.ArrayBuffer !== 'undefined'); /* eslint-disable no-undef */ var isProxySupportBlobNatively = (cordova.platformId === 'windows8' || cordova.platformId === 'windows'); var isBinary; // Check to see if the incoming data is a blob if (data instanceof File || (!isProxySupportBlobNatively &amp;&amp; supportsBinary &amp;&amp; data instanceof Blob)) { var fileReader = new FileReader(); /* eslint-enable no-undef */ fileReader.onload = function () { // Call this method again, with the arraybuffer as argument FileWriter.prototype.write.call(that, this.result, true /* isPendingBlobReadResult */); }; fileReader.onerror = function () { // DONE state that.readyState = FileWriter.DONE; // Save error that.error = this.error; // If onerror callback if (typeof that.onerror === 'function') { that.onerror(new ProgressEvent('error', {'target': that})); } // If onwriteend callback if (typeof that.onwriteend === 'function') { that.onwriteend(new ProgressEvent('writeend', {'target': that})); } }; // WRITING state this.readyState = FileWriter.WRITING; if (supportsBinary) { fileReader.readAsArrayBuffer(data); } else { fileReader.readAsText(data); } return; } // Mark data type for safer transport over the binary bridge isBinary = supportsBinary &amp;&amp; (data instanceof ArrayBuffer); if (isBinary &amp;&amp; cordova.platformId === 'windowsphone') { // eslint-disable-line no-undef // create a plain array, using the keys from the Uint8Array view so that we can serialize it data = Array.apply(null, new Uint8Array(data)); } // Throw an exception if we are already writing a file if (this.readyState === FileWriter.WRITING &amp;&amp; !isPendingBlobReadResult) { throw new FileError(FileError.INVALID_STATE_ERR); } // WRITING state this.readyState = FileWriter.WRITING; var me = this; // If onwritestart callback if (typeof me.onwritestart === 'function') { me.onwritestart(new ProgressEvent('writestart', {'target': me})); } // Write file exec( // Success callback function (r) { // If DONE (cancelled), then don't do anything if (me.readyState === FileWriter.DONE) { return; } // position always increases by bytes written because file would be extended me.position += r; // The length of the file is now where we are done writing. me.length = me.position; // DONE state me.readyState = FileWriter.DONE; // If onwrite callback if (typeof me.onwrite === 'function') { me.onwrite(new ProgressEvent('write', {'target': me})); } // If onwriteend callback if (typeof me.onwriteend === 'function') { me.onwriteend(new ProgressEvent('writeend', {'target': me})); } }, // Error callback function (e) { // If DONE (cancelled), then don't do anything if (me.readyState === FileWriter.DONE) { return; } // DONE state me.readyState = FileWriter.DONE; // Save error me.error = new FileError(e); // If onerror callback if (typeof me.onerror === 'function') { me.onerror(new ProgressEvent('error', {'target': me})); } // If onwriteend callback if (typeof me.onwriteend === 'function') { me.onwriteend(new ProgressEvent('writeend', {'target': me})); } }, 'File', 'write', [this.localURL, data, this.position, isBinary]); }; /** * Moves the file pointer to the location specified. * * If the offset is a negative number the position of the file * pointer is rewound. If the offset is greater than the file * size the position is set to the end of the file. * * @param offset is the location to move the file pointer to. */ FileWriter.prototype.seek = function (offset) { // Throw an exception if we are already writing a file if (this.readyState === FileWriter.WRITING) { throw new FileError(FileError.INVALID_STATE_ERR); } if (!offset &amp;&amp; offset !== 0) { return; } // See back from end of file. if (offset &lt; 0) { this.position = Math.max(offset + this.length, 0); // Offset is bigger than file size so set position // to the end of the file. } else if (offset &gt; this.length) { this.position = this.length; // Offset is between 0 and file size so set the position // to start writing. } else { this.position = offset; } }; /** * Truncates the file to the size specified. * * @param size to chop the file at. */ FileWriter.prototype.truncate = function (size) { // Throw an exception if we are already writing a file if (this.readyState === FileWriter.WRITING) { throw new FileError(FileError.INVALID_STATE_ERR); } // WRITING state this.readyState = FileWriter.WRITING; var me = this; // If onwritestart callback if (typeof me.onwritestart === 'function') { me.onwritestart(new ProgressEvent('writestart', {'target': this})); } // Write file exec( // Success callback function (r) { // If DONE (cancelled), then don't do anything if (me.readyState === FileWriter.DONE) { return; } // DONE state me.readyState = FileWriter.DONE; // Update the length of the file me.length = r; me.position = Math.min(me.position, r); // If onwrite callback if (typeof me.onwrite === 'function') { me.onwrite(new ProgressEvent('write', {'target': me})); } // If onwriteend callback if (typeof me.onwriteend === 'function') { me.onwriteend(new ProgressEvent('writeend', {'target': me})); } }, // Error callback function (e) { // If DONE (cancelled), then don't do anything if (me.readyState === FileWriter.DONE) { return; } // DONE state me.readyState = FileWriter.DONE; // Save error me.error = new FileError(e); // If onerror callback if (typeof me.onerror === 'function') { me.onerror(new ProgressEvent('error', {'target': me})); } // If onwriteend callback if (typeof me.onwriteend === 'function') { me.onwriteend(new ProgressEvent('writeend', {'target': me})); } }, 'File', 'truncate', [this.localURL, size]); }; module.exports = FileWriter; × Search results Close "},"cordova-plugin-file_www_Flags.js.html":{"id":"cordova-plugin-file_www_Flags.js.html","title":"Source: cordova-plugin-file/www/Flags.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: cordova-plugin-file/www/Flags.js /* * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. * */ /** * Supplies arguments to methods that lookup or create files and directories. * * @param create * {boolean} file or directory if it doesn't exist * @param exclusive * {boolean} used with create; if true the command will fail if * target path exists */ function Flags (create, exclusive) { this.create = create || false; this.exclusive = exclusive || false; } module.exports = Flags; × Search results Close "},"elastos-trinity-plugins-media_www_Media.js.html":{"id":"elastos-trinity-plugins-media_www_Media.js.html","title":"Source: elastos-trinity-plugins-media/www/Media.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: elastos-trinity-plugins-media/www/Media.js /* * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. * */ var argscheck = require('cordova/argscheck'), utils = require('cordova/utils'), exec = require('cordova/exec'); var mediaObjects = {}; /** * This class provides access to the device media, interfaces to both sound and video * * @constructor * @param src The file name or url to play * @param successCallback The callback to be called when the file is done playing or recording. * successCallback() * @param errorCallback The callback to be called if there is an error. * errorCallback(int errorCode) - OPTIONAL * @param statusCallback The callback to be called when media status has changed. * statusCallback(int statusCode) - OPTIONAL */ var Media = function(src, successCallback, errorCallback, statusCallback) { argscheck.checkArgs('sFFF', 'Media', arguments); this.id = utils.createUUID(); mediaObjects[this.id] = this; this.src = src; this.successCallback = successCallback; this.errorCallback = errorCallback; this.statusCallback = statusCallback; this._duration = -1; this._position = -1; exec(null, this.errorCallback, \"Media\", \"create\", [this.id, this.src]); }; // Media messages Media.MEDIA_STATE = 1; Media.MEDIA_DURATION = 2; Media.MEDIA_POSITION = 3; Media.MEDIA_ERROR = 9; // Media states Media.MEDIA_NONE = 0; Media.MEDIA_STARTING = 1; Media.MEDIA_RUNNING = 2; Media.MEDIA_PAUSED = 3; Media.MEDIA_STOPPED = 4; Media.MEDIA_MSG = [\"None\", \"Starting\", \"Running\", \"Paused\", \"Stopped\"]; // \"static\" function to return existing objs. Media.get = function(id) { return mediaObjects[id]; }; /** * Start or resume playing audio file. */ Media.prototype.play = function(options) { exec(null, null, \"Media\", \"startPlayingAudio\", [this.id, this.src, options]); }; /** * Stop playing audio file. */ Media.prototype.stop = function() { var me = this; exec(function() { me._position = 0; }, this.errorCallback, \"Media\", \"stopPlayingAudio\", [this.id]); }; /** * Seek or jump to a new time in the track.. */ Media.prototype.seekTo = function(milliseconds) { var me = this; exec(function(p) { me._position = p; }, this.errorCallback, \"Media\", \"seekToAudio\", [this.id, milliseconds]); }; /** * Pause playing audio file. */ Media.prototype.pause = function() { exec(null, this.errorCallback, \"Media\", \"pausePlayingAudio\", [this.id]); }; /** * Get duration of an audio file. * The duration is only set for audio that is playing, paused or stopped. * * @return duration or -1 if not known. */ Media.prototype.getDuration = function() { return this._duration; }; /** * Get position of audio. */ Media.prototype.getCurrentPosition = function(success, fail) { var me = this; exec(function(p) { me._position = p; success(p); }, fail, \"Media\", \"getCurrentPositionAudio\", [this.id]); }; /** * Start recording audio file. */ Media.prototype.startRecord = function() { exec(null, this.errorCallback, \"Media\", \"startRecordingAudio\", [this.id, this.src]); }; /** * Stop recording audio file. */ Media.prototype.stopRecord = function() { exec(null, this.errorCallback, \"Media\", \"stopRecordingAudio\", [this.id]); }; /** * Pause recording audio file. */ Media.prototype.pauseRecord = function() { exec(null, this.errorCallback, \"Media\", \"pauseRecordingAudio\", [this.id]); }; /** * Resume recording audio file. */ Media.prototype.resumeRecord = function() { exec(null, this.errorCallback, \"Media\", \"resumeRecordingAudio\", [this.id]); }; /** * Release the resources. */ Media.prototype.release = function() { exec(null, this.errorCallback, \"Media\", \"release\", [this.id]); }; /** * Adjust the volume. */ Media.prototype.setVolume = function(volume) { exec(null, null, \"Media\", \"setVolume\", [this.id, volume]); }; /** * Adjust the playback rate. */ Media.prototype.setRate = function(rate) { if (cordova.platformId === 'ios'){ exec(null, null, \"Media\", \"setRate\", [this.id, rate]); } else { console.warn('media.setRate method is currently not supported for', cordova.platformId, 'platform.'); } }; /** * Get amplitude of audio. */ Media.prototype.getCurrentAmplitude = function(success, fail) { exec(function(p) { success(p); }, fail, \"Media\", \"getCurrentAmplitudeAudio\", [this.id]); }; /** * Audio has status update. * PRIVATE * * @param id The media object id (string) * @param msgType The 'type' of update this is * @param value Use of value is determined by the msgType */ Media.onStatus = function(id, msgType, value) { var media = mediaObjects[id]; if (media) { switch(msgType) { case Media.MEDIA_STATE : if (media.statusCallback) { media.statusCallback(value); } if (value == Media.MEDIA_STOPPED) { if (media.successCallback) { media.successCallback(); } } break; case Media.MEDIA_DURATION : media._duration = value; break; case Media.MEDIA_ERROR : if (media.errorCallback) { media.errorCallback(value); } break; case Media.MEDIA_POSITION : media._position = Number(value); break; default : if (console.error) { console.error(\"Unhandled Media.onStatus :: \" + msgType); } break; } } else if (console.error) { console.error(\"Received Media.onStatus callback for unknown media :: \" + id); } }; module.exports = Media; function onMessageFromNative(msg) { if (msg.action == 'status') { Media.onStatus(msg.status.id, msg.status.msgType, msg.status.value); } else { throw new Error('Unknown media action' + msg.action); } } if (cordova.platformId === 'android' || cordova.platformId === 'amazon-fireos' || cordova.platformId === 'windowsphone') { var channel = require('cordova/channel'); channel.createSticky('onMediaPluginReady'); channel.waitForInitialization('onMediaPluginReady'); channel.onCordovaReady.subscribe(function() { exec(onMessageFromNative, undefined, 'Media', 'messageChannel', []); channel.initializationComplete('onMediaPluginReady'); }); } × Search results Close "},"cordova-plugin-media-capture_www_MediaFile.js.html":{"id":"cordova-plugin-media-capture_www_MediaFile.js.html","title":"Source: cordova-plugin-media-capture/www/MediaFile.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: cordova-plugin-media-capture/www/MediaFile.js /* * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. * */ var utils = require('cordova/utils'); var exec = require('cordova/exec'); var File = require('cordova-plugin-file.File'); var CaptureError = require('./CaptureError'); /** * Represents a single file. * * name {DOMString} name of the file, without path information * fullPath {DOMString} the full path of the file, including the name * type {DOMString} mime type * lastModifiedDate {Date} last modified date * size {Number} size of the file in bytes */ var MediaFile = function (name, localURL, type, lastModifiedDate, size) { MediaFile.__super__.constructor.apply(this, arguments); }; utils.extend(MediaFile, File); /** * Request capture format data for a specific file and type * * @param {Function} successCB * @param {Function} errorCB */ MediaFile.prototype.getFormatData = function (successCallback, errorCallback) { if (typeof this.fullPath === 'undefined' || this.fullPath === null) { errorCallback(new CaptureError(CaptureError.CAPTURE_INVALID_ARGUMENT)); } else { exec(successCallback, errorCallback, 'Capture', 'getFormatData', [this.fullPath, this.type]); } }; module.exports = MediaFile; × Search results Close "},"cordova-plugin-media-capture_www_MediaFileData.js.html":{"id":"cordova-plugin-media-capture_www_MediaFileData.js.html","title":"Source: cordova-plugin-media-capture/www/MediaFileData.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: cordova-plugin-media-capture/www/MediaFileData.js /* * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. * */ /** * MediaFileData encapsulates format information of a media file. * * @param {DOMString} codecs * @param {long} bitrate * @param {long} height * @param {long} width * @param {float} duration */ var MediaFileData = function (codecs, bitrate, height, width, duration) { this.codecs = codecs || null; this.bitrate = bitrate || 0; this.height = height || 0; this.width = width || 0; this.duration = duration || 0; }; module.exports = MediaFileData; × Search results Close "},"cordova-plugin-file_www_Metadata.js.html":{"id":"cordova-plugin-file_www_Metadata.js.html","title":"Source: cordova-plugin-file/www/Metadata.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: cordova-plugin-file/www/Metadata.js /* * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. * */ /** * Information about the state of the file or directory * * {Date} modificationTime (readonly) */ var Metadata = function (metadata) { if (typeof metadata === 'object') { this.modificationTime = new Date(metadata.modificationTime); this.size = metadata.size || 0; } else if (typeof metadata === 'undefined') { this.modificationTime = null; this.size = 0; } else { /* Backwards compatiblity with platforms that only return a timestamp */ this.modificationTime = new Date(metadata); } }; module.exports = Metadata; × Search results Close "},"cordova-plugin-dialogs_www_android_notification.js.html":{"id":"cordova-plugin-dialogs_www_android_notification.js.html","title":"Source: cordova-plugin-dialogs/www/android/notification.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: cordova-plugin-dialogs/www/android/notification.js /* * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. * */ var exec = require('cordova/exec'); /** * Provides Android enhanced notification API. */ module.exports = { activityStart: function (title, message) { // If title and message not specified then mimic Android behavior of // using default strings. if (typeof title === 'undefined' &amp;&amp; typeof message === 'undefined') { title = 'Busy'; message = 'Please wait...'; } exec(null, null, 'Notification', 'activityStart', [ title, message ]); }, /** * Close an activity dialog */ activityStop: function () { exec(null, null, 'Notification', 'activityStop', []); }, /** * Display a progress dialog with progress bar that goes from 0 to 100. * * @param {String} * title Title of the progress dialog. * @param {String} * message Message to display in the dialog. */ progressStart: function (title, message) { exec(null, null, 'Notification', 'progressStart', [ title, message ]); }, /** * Close the progress dialog. */ progressStop: function () { exec(null, null, 'Notification', 'progressStop', []); }, /** * Set the progress dialog value. * * @param {Number} * value 0-100 */ progressValue: function (value) { exec(null, null, 'Notification', 'progressValue', [ value ]); } }; × Search results Close "},"cordova-plugin-device-motion_www_Acceleration.js.html":{"id":"cordova-plugin-device-motion_www_Acceleration.js.html","title":"Source: cordova-plugin-device-motion/www/Acceleration.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: cordova-plugin-device-motion/www/Acceleration.js /* * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. * */ /** * @exports Acceleration */ var Acceleration = function(x, y, z, timestamp) { this.x = x; this.y = y; this.z = z; this.timestamp = timestamp || (new Date()).getTime(); }; module.exports = Acceleration; × Search results Close "},"cordova-plugin-device-motion_www_accelerometer.js.html":{"id":"cordova-plugin-device-motion_www_accelerometer.js.html","title":"Source: cordova-plugin-device-motion/www/accelerometer.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: cordova-plugin-device-motion/www/accelerometer.js /* * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. * */ /* * This class provides access to device accelerometer data. */ /** * @exports Accelerometer */ var argscheck = require('cordova/argscheck'), utils = require(\"cordova/utils\"), exec = require(\"cordova/exec\"), Acceleration = require('./Acceleration'); // Is the accel sensor running? var running = false; // Keeps reference to watchAcceleration calls. var timers = {}; // Array of listeners; used to keep track of when we should call start and stop. var listeners = []; // Last returned acceleration object from native var accel = null; // Timer used when faking up devicemotion events var eventTimerId = null; // Tells native to start. function start() { exec(function (a) { var tempListeners = listeners.slice(0); accel = new Acceleration(a.x, a.y, a.z, a.timestamp); for (var i = 0, l = tempListeners.length; i &lt; l; i++) { tempListeners[i].win(accel); } }, function (e) { var tempListeners = listeners.slice(0); for (var i = 0, l = tempListeners.length; i &lt; l; i++) { tempListeners[i].fail(e); } }, \"Accelerometer\", \"start\", []); running = true; } // Tells native to stop. function stop() { exec(null, null, \"Accelerometer\", \"stop\", []); accel = null; running = false; } // Adds a callback pair to the listeners array function createCallbackPair(win, fail) { return { win: win, fail: fail }; } // Removes a win/fail listener pair from the listeners array function removeListeners(l) { var idx = listeners.indexOf(l); if (idx &gt; -1) { listeners.splice(idx, 1); if (listeners.length === 0) { stop(); } } } var accelerometer = { /** * Asynchronously acquires the current acceleration. * * @param {Function} successCallback The function to call when the acceleration data is available * @param {Function} errorCallback The function to call when there is an error getting the acceleration data. (OPTIONAL) * @param {AccelerationOptions} options The options for getting the accelerometer data such as timeout. (OPTIONAL) */ getCurrentAcceleration: function (successCallback, errorCallback, options) { argscheck.checkArgs('fFO', 'accelerometer.getCurrentAcceleration', arguments); if (cordova.platformId === \"windowsphone\") { exec(function (a) { accel = new Acceleration(a.x, a.y, a.z, a.timestamp); successCallback(accel); }, function (e) { errorCallback(e); }, \"Accelerometer\", \"getCurrentAcceleration\", []); return; } if (cordova.platformId === \"browser\" &amp;&amp; !eventTimerId) { // fire devicemotion event once var devicemotionEvent = new Event('devicemotion'); window.setTimeout(function() { window.dispatchEvent(devicemotionEvent); }, 200); } var p; var win = function (a) { removeListeners(p); successCallback(a); }; var fail = function (e) { removeListeners(p); if (errorCallback) { errorCallback(e); } }; p = createCallbackPair(win, fail); listeners.push(p); if (!running) { start(); } }, /** * Asynchronously acquires the acceleration repeatedly at a given interval. * * @param {Function} successCallback The function to call each time the acceleration data is available * @param {Function} errorCallback The function to call when there is an error getting the acceleration data. (OPTIONAL) * @param {AccelerationOptions} options The options for getting the accelerometer data such as timeout. (OPTIONAL) * @return String The watch id that must be passed to #clearWatch to stop watching. */ watchAcceleration: function (successCallback, errorCallback, options) { argscheck.checkArgs('fFO', 'accelerometer.watchAcceleration', arguments); // Default interval (10 sec) var frequency = (options &amp;&amp; options.frequency &amp;&amp; typeof options.frequency == 'number') ? options.frequency : 10000; // Keep reference to watch id, and report accel readings as often as defined in frequency var id = utils.createUUID(); var p = createCallbackPair(function () { }, function (e) { removeListeners(p); if (errorCallback) { errorCallback(e); } }); listeners.push(p); timers[id] = { timer: window.setInterval(function () { if (accel) { successCallback(accel); } }, frequency), listeners: p }; if (running) { // If we're already running then immediately invoke the success callback // but only if we have retrieved a value, sample code does not check for null ... if (accel) { successCallback(accel); } } else { start(); } if (cordova.platformId === \"browser\" &amp;&amp; !eventTimerId) { // Start firing devicemotion events if we haven't already var devicemotionEvent = new Event('devicemotion'); eventTimerId = window.setInterval(function() { window.dispatchEvent(devicemotionEvent); }, 200); } return id; }, /** * Clears the specified accelerometer watch. * * @param {String} id The id of the watch returned from #watchAcceleration. */ clearWatch: function (id) { // Stop javascript timer &amp; remove from timer list if (id &amp;&amp; timers[id]) { window.clearInterval(timers[id].timer); removeListeners(timers[id].listeners); delete timers[id]; if (eventTimerId &amp;&amp; Object.keys(timers).length === 0) { // No more watchers, so stop firing 'devicemotion' events window.clearInterval(eventTimerId); eventTimerId = null; } } } }; module.exports = accelerometer; × Search results Close "},"elastos-trinity-plugins-appmanager_www_AppManager.js.html":{"id":"elastos-trinity-plugins-appmanager_www_AppManager.js.html","title":"Source: elastos-trinity-plugins-appmanager/www/AppManager.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: elastos-trinity-plugins-appmanager/www/AppManager.js /* * Copyright (c) 2018 Elastos Foundation * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in all * copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE * SOFTWARE. */ 'use strict'; var exec = require('cordova/exec'); /** * @module AppManager */ /** * The icons info. * * @typedef Icon * @type {Object} * @property {string} src The icon src. * @property {string} sizes The icon sizes. * @property {string} type The icon type. */ /** * The plugin authority status. * * @typedef PluginAuthority * @type {Object} * @property {string} plugin The plugin name. * @property {AuthorityStatus} authority The authority status. */ /** * The access url authority status. * * @typedef UrlAuthority * @type {Object} * @property {string} url The url access. * @property {AuthorityStatus} authority The authority status. */ /** * The App information. * * @typedef AppInfo * @type {Object} * @property {string} id The app id. * @property {string} version The app version. * @property {string} name The app name. * @property {string} shortName The app shortName. * @property {string} description The app description. * @property {string} startUrl The app startUrl. * @property {Icon[]} icons The app icons. * @property {string} authorName The app authorName. * @property {string} authorEmail The app authorEmail. * @property {string} defaultLocale The app defaultLocale. * @property {PluginAuthority[]} plugins The app PluginAuthority list. * @property {UrlAuthority[]} urls The app UrlAuthoritylist. * @property {string} backgroundColor The app backgroundColor. * @property {string} themeDisplay The app theme display. * @property {string} themeColor The app theme color. * @property {string} themeFontName The app theme font name. * @property {string} themeFontColor The app theme font color. * @property {number} installTime The app intall time. * @property {number} builtIn The app builtIn. * @property {string} appPath The app path. * @property {string} dataPath The app data path. */ /** * The callback function to receive message. * * @callback onReceiveMessage * * @param {string} msg The message receive * @param {number} type The message type * @param {string} from The message from */ /** * The callback function to receive message. * * @callback onReceiveIntent * * @param {string} action The intent action * @param {Object} params The intent params * @param {string} from The intent from */ /** * The class representing dapp manager for launcher. * @class */ function AppManager() { var me = this; /** * @description * Message type to send or receive. * * @enum {number} */ this.MessageType = { /** The internal message */ INTERNAL: 1, /** The internal return message. */ IN_RETURN: 2, /** The external launcher message */ EXTERNAL_LAUNCHER: 3, /** The external install message */ EXTERNAL_INSTALL: 4, /** The external return message. */ EX_RETURN: 5, } /** * @description * Message type to send or receive. * * @enum {number} */ this.AuthorityStatus = { /** Not initialise */ NOINIT: 0, /** Ask for authority. */ ASK: 1, /** Allow the authority. */ ALLOW: 2, /** Deny the authority. */ DENY: 3, } } function jsonInfo(info) { if (typeof (info.icons) == \"string\") { info.icons = JSON.parse(info.icons); } if (typeof (info.plugins) == \"string\") { info.plugins = JSON.parse(info.plugins); } if (typeof (info.urls) == \"string\") { info.urls = JSON.parse(info.urls); } } AppManager.prototype = { constructor: AppManager, /** * Get locale. * * @param {Function} onSuccess The function to call.the param include 'defaultLang' and 'systemLang'. */ getLocale: function (onSuccess) { exec(onSuccess, null, 'AppManager', 'getLocale'); }, /** * Set current locale. * * @param {string} code The current locale code. * @param {Function} onSuccess The function to call when success.the param is a AppInfo. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. */ setCurrentLocate: function (code, onSuccess, onError) { exec(onSuccess, onError, 'AppManager', 'setCurrentLocale', [code]); }, /** * Install a dapp by path. * * @param {string} url The dapp install url. * @param {Function} onSuccess The function to call when success.the param is a AppInfo. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. */ install: function (url, dev, onSuccess, onError) { function _onSuccess(info) { jsonInfo(info); if (onSuccess) { onSuccess(info); } }; exec(_onSuccess, onError, 'AppManager', 'install', [url, dev]); }, /** * Uninstall a dapp by id. * * @param {string} id The dapp id. * @param {Function} onSuccess The function to call when success.the param is the id. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. */ unInstall: function (id, onSuccess, onError) { exec(onSuccess, onError, 'AppManager', 'unInstall', [id]); }, /** * Get a dapp info. * * @param {string} id The dapp id. * @param {Function} onSuccess The function to call when success, the param is a AppInfo. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. */ getAppInfo: function (id, onSuccess, onError) { function _onSuccess(info) { jsonInfo(info); if (onSuccess) { onSuccess(info); } }; exec(_onSuccess, onError, 'AppManager', 'getAppInfo', [id]); }, /** * Get a dapp info. * * @param {Function} onSuccess The function to call when success, the param is include 'infos' and 'list'. */ getAppInfos: function (onSuccess) { function _onSuccess(infos) { for (var id in infos) { jsonInfo(infos[id]); } if (onSuccess) { onSuccess(infos); } }; exec(_onSuccess, null, 'AppManager', 'getAppInfos'); }, /** * Start a dapp by id. If the dapp running, it will be swith to curent. * * @param {string} id The dapp id. * @param {Function} onSuccess The function to call when success. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. */ start: function (id, onSuccess, onError) { exec(onSuccess, onError, 'AppManager', 'start', [id]); }, /** * Start the launcher.If the launcher running, it will be swith to curent. * * @param {Function} onSuccess The function to call when success. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. */ launcher: function (onSuccess, onError) { exec(onSuccess, onError, 'AppManager', 'launcher', []); }, /** * Close a dapp by id. * * @param {string} id The dapp id. * @param {Function} onSuccess The function to call when success. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. */ close: function (id, onSuccess, onError) { exec(onSuccess, onError, 'AppManager', 'close', [id]); }, /** * Send a message by id. * * @param {string} id The dapp id. * @param {MessageType} type The message type. * @param {string} msg The message content. * @param {Function} onSuccess The function to call when success. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. */ sendMessage: function (id, type, msg, onSuccess, onError) { exec(onSuccess, onError, 'AppManager', 'sendMessage', [id, type, msg]); }, /** * Set listener for message callback. * * @param {onReceiveMessage} callback The function receive the message. */ setListener: function (callback) { exec(callback, null, 'AppManager', 'setListener'); }, /** * Get running list. * * @param {Function} onSuccess The function to call when success,the param is a dapp id list. */ getRunningList: function (onSuccess) { exec(onSuccess, null, 'AppManager', 'getRunningList'); }, /** * Get dapp list. * * @param {Function} onSuccess The function to call when success,the param is a dapp id list. */ getAppList: function (onSuccess) { exec(onSuccess, null, 'AppManager', 'getAppList'); }, /** * Get last run list. * * @param {Function} onSuccess The function to call when success,the param is a dapp id list. */ getLastList: function (onSuccess) { exec(onSuccess, null, 'AppManager', 'getLastList'); }, /** * Set a plugin authority. Only the launcher can set. * * @param {string} id The dapp id. * @param {string} plugin The plugin id to set authorty. * @param {AuthorityStatus} authority The authority to set. * @param {Function} onSuccess The function to call when success. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. */ setPluginAuthority: function (id, plugin, authority, onSuccess, onError) { exec(onSuccess, onError, 'AppManager', 'setPluginAuthority', [id, plugin, authority]); }, /** * Set a url authority. Only the launcher can set. * * @param {string} id The dapp id. * @param {string} url The url to set authority. * @param {AuthorityStatus} authority The authority to set. * @param {Function} onSuccess The function to call when success. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. */ setUrlAuthority: function (id, url, authority, onSuccess, onError) { exec(onSuccess, onError, 'AppManager', 'setUrlAuthority', [id, url, authority]); }, /** * Display a alert dialog prompt. * * @param {string} title The dialog title. * @param {string} message The dialog message. */ alertPrompt: function (title, message) { exec(null, null, 'AppManager', 'alertPrompt', [title, message]); }, /** * Display a info dialog prompt. * * @param {string} title The dialog title. * @param {string} message The dialog message. */ infoPrompt: function (title, message) { exec(null, null, 'AppManager', 'infoPrompt', [title, message]); }, /** * Display a ask dialog prompt. * * @param {string} title The dialog title. * @param {string} message The dialog message. * @param {Function} onOK The function to call when click ok. */ askPrompt: function (title, message, onOK) { exec(onOK, null, 'AppManager', 'askPrompt', [title, message]); }, /** * Send a intent by action. * * @param {string} action The intent action. * @param {Object} params The intent params. * @param {Function} onSuccess The function to call when success. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. */ sendIntent: function (action, params, onSuccess, onError) { var str = JSON.stringify(params); function _onSuccess(ret) { if (typeof (ret.result) == \"string\") { ret.result = JSON.parse(ret.result); } if (onSuccess) { onSuccess(ret); } }; exec(_onSuccess, onError, 'AppManager', 'sendIntent', [action, str]); }, /** * Set intent listener for message callback. * * @param {onReceiveIntent} callback The function receive the intent. */ setIntentListener: function (callback) { function _onReceiveIntent(ret) { if (typeof (ret.params) == \"string\") { ret.params = JSON.parse(ret.params); } if (callback) { callback(ret); } } exec(_onReceiveIntent, null, 'AppManager', 'setIntentListener'); }, /** * Send a intent respone by id. * * @param {string} action The intent action. * @param {Object} result The intent respone result. * @param {long} intentId The intent id. * @param {Function} onSuccess The function to call when success. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. */ sendIntentRespone: function (action, result, intentId, onSuccess, onError) { var str = JSON.stringify(result); exec(onSuccess, onError, 'AppManager', 'sendIntentRespone', [action, str, intentId]); }, } var appManager = new AppManager(); module.exports = appManager; × Search results Close "},"elastos-trinity-plugins-appservice_www_AppService.js.html":{"id":"elastos-trinity-plugins-appservice_www_AppService.js.html","title":"Source: elastos-trinity-plugins-appservice/www/AppService.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: elastos-trinity-plugins-appservice/www/AppService.js /* * Copyright (c) 2018 Elastos Foundation * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in all * copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE * SOFTWARE. */ 'use strict'; var exec = require('cordova/exec'); /** * @module AppService */ /** * The icons info. * * @typedef Icon * @type {Object} * @property {string} src The icon src. * @property {string} sizes The icon sizes. * @property {string} type The icon type. */ /** * The plugin authority status. * * @typedef PluginAuthority * @type {Object} * @property {string} plugin The plugin name. * @property {AuthorityStatus} authority The authority status. */ /** * The access url authority status. * * @typedef UrlAuthority * @type {Object} * @property {string} url The url access. * @property {AuthorityStatus} authority The authority status. */ /** * The App information. * * @typedef AppInfo * @type {Object} * @property {string} id The app id. * @property {string} version The app version. * @property {string} name The app name. * @property {string} shortName The app shortName. * @property {string} description The app description. * @property {string} startUrl The app startUrl. * @property {Icon[]} icons The app icons. * @property {string} authorName The app authorName. * @property {string} authorEmail The app authorEmail. * @property {string} defaultLocale The app defaultLocale. * @property {PluginAuthority[]} plugins The app PluginAuthority list. * @property {UrlAuthority[]} urls The app UrlAuthoritylist. * @property {string} backgroundColor The app backgroundColor. * @property {string} themeDisplay The app theme display. * @property {string} themeColor The app theme color. * @property {string} themeFontName The app theme font name. * @property {string} themeFontColor The app theme font color. * @property {number} installTime The app intall time. * @property {number} builtIn The app builtIn. * @property {string} appPath The app path. * @property {string} dataPath The app data path. */ /** * The callback function to receive message. * * @callback onReceiveMessage * * @param {string} msg The message receive * @param {number} type The message type * @param {string} from The message from */ /** * The callback function to receive message. * * @callback onReceiveIntent * * @param {string} action The intent action * @param {Object} params The intent params * @param {string} from The intent from */ /** * The class representing dapp service. * @class */ function AppService() { var me = this; /** * @description * Message type to send or receive. * * @enum {number} */ this.MessageType = { /** The internal message */ INTERNAL: 1, /** The internal return message. */ IN_RETURN: 2, /** The external launcher message */ EXTERNAL_LAUNCHER: 3, /** The external install message */ EXTERNAL_INSTALL: 4, /** The external return message. */ EX_RETURN: 5, } } function jsonInfo(info) { if (typeof (info.icons) == \"string\") { info.icons = JSON.parse(info.icons); } if (typeof (info.plugins) == \"string\") { info.plugins = JSON.parse(info.plugins); } if (typeof (info.urls) == \"string\") { info.urls = JSON.parse(info.urls); } } AppService.prototype = { constructor: AppService, /** * Get locale. * * @param {Function} onSuccess The function to call.the param include 'defaultLang', 'currentLang' and 'systemLang'. */ getLocale: function (onSuccess) { exec(onSuccess, null, 'AppService', 'getLocale'); }, /** * Start a dapp by id. If the dapp running, it will be swith to curent. * * @param {string} id The dapp id. * @param {Function} onSuccess The function to call when success. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. */ start: function (id, onSuccess, onError) { exec(onSuccess, onError, 'AppService', 'start', [id]); }, /** * Start the launcher.If the launcher running, it will be swith to curent. * * @param {Function} onSuccess The function to call when success. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. */ launcher: function (onSuccess, onError) { exec(onSuccess, onError, 'AppService', 'launcher', []); }, /** * Close the dapp. * * @param {Function} onSuccess The function to call when success. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. */ close: function (onSuccess, onError) { exec(onSuccess, onError, 'AppService', 'close'); }, /** * Get a dapp info. * * @param {Function} onSuccess The function to call when success, the param is a AppInfo. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. */ getAppInfo: function (onSuccess, onError) { function _onSuccess(info) { jsonInfo(info); if (onSuccess) { onSuccess(info); } }; exec(_onSuccess, onError, 'AppService', 'getAppInfo'); }, /** * Send a message by id. * * @param {string} id The dapp id. * @param {MessageType} type The message type. * @param {string} msg The message content. * @param {Function} onSuccess The function to call when success. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. */ sendMessage: function (id, type, msg, onSuccess, onError) { exec(onSuccess, onError, 'AppService', 'sendMessage', [id, type, msg]); }, /** * Set listener for message callback. * * @param {onReceiveMessage} callback The function receive the message. */ setListener: function (callback) { exec(callback, null, 'AppService', 'setListener'); }, /** * Send a intent by action. * * @param {string} action The intent action. * @param {Object} params The intent params. * @param {Function} onSuccess The function to call when success. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. */ sendIntent: function (action, params, onSuccess, onError) { var str = JSON.stringify(params); function _onSuccess(ret) { if (typeof (ret.result) == \"string\") { ret.result = JSON.parse(ret.result); } if (onSuccess) { onSuccess(ret); } }; exec(_onSuccess, onError, 'AppService', 'sendIntent', [action, str]); }, /** * Set intent listener for message callback. * * @param {onReceiveIntent} callback The function receive the intent. */ setIntentListener: function (callback) { function _onReceiveIntent(ret) { if (typeof (ret.params) == \"string\") { ret.params = JSON.parse(ret.params); } if (callback) { callback(ret); } } exec(_onReceiveIntent, null, 'AppService', 'setIntentListener'); }, /** * Send a intent respone by id. * * @param {string} action The intent action. * @param {Object} result The intent respone result. * @param {long} intentId The intent id. * @param {Function} onSuccess The function to call when success. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. */ sendIntentRespone: function (action, result, intentId, onSuccess, onError) { var str = JSON.stringify(result); exec(onSuccess, onError, 'AppService', 'sendIntentRespone', [action, str, intentId]); }, } module.exports = new AppService(); × Search results Close "},"cordova-plugin-camera_www_Camera.js.html":{"id":"cordova-plugin-camera_www_Camera.js.html","title":"Source: cordova-plugin-camera/www/Camera.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: cordova-plugin-camera/www/Camera.js /* * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. * */ var argscheck = require('cordova/argscheck'); var exec = require('cordova/exec'); var Camera = require('./Camera'); // XXX: commented out // CameraPopoverHandle = require('./CameraPopoverHandle'); /** * @exports Camera */ var cameraExport = {}; // Tack on the Camera Constants to the base camera plugin. for (var key in Camera) { cameraExport[key] = Camera[key]; } /** * Callback function that provides an error message. * @callback module:Camera.onError * @param {string} message - The message is provided by the device's native code. */ /** * Callback function that provides the image data. * @callback module:Camera.onSuccess * @param {string} imageData - Base64 encoding of the image data, _or_ the image file URI, depending on [`cameraOptions`]{@link module:camera.CameraOptions} in effect. * @example * // Show image * // * function cameraCallback(imageData) { * var image = document.getElementById('myImage'); * image.src = \"data:image/jpeg;base64,\" + imageData; * } */ /** * Optional parameters to customize the camera settings. * * [Quirks](#CameraOptions-quirks) * @typedef module:Camera.CameraOptions * @type {Object} * @property {number} [quality=50] - Quality of the saved image, expressed as a range of 0-100, where 100 is typically full resolution with no loss from file compression. (Note that information about the camera's resolution is unavailable.) * @property {module:Camera.DestinationType} [destinationType=FILE_URI] - Choose the format of the return value. * @property {module:Camera.PictureSourceType} [sourceType=CAMERA] - Set the source of the picture. * @property {Boolean} [allowEdit=false] - Allow simple editing of image before selection. * @property {module:Camera.EncodingType} [encodingType=JPEG] - Choose the returned image file's encoding. * @property {number} [targetWidth] - Width in pixels to scale image. Must be used with `targetHeight`. Aspect ratio remains constant. * @property {number} [targetHeight] - Height in pixels to scale image. Must be used with `targetWidth`. Aspect ratio remains constant. * @property {module:Camera.MediaType} [mediaType=PICTURE] - Set the type of media to select from. Only works when `PictureSourceType` is `PHOTOLIBRARY` or `SAVEDPHOTOALBUM`. * @property {Boolean} [correctOrientation] - Rotate the image to correct for the orientation of the device during capture. * @property {Boolean} [saveToPhotoAlbum] - Save the image to the photo album on the device after capture. * @property {module:CameraPopoverOptions} [popoverOptions] - iOS-only options that specify popover location in iPad. * @property {module:Camera.Direction} [cameraDirection=BACK] - Choose the camera to use (front- or back-facing). */ /** * @description Takes a photo using the camera, or retrieves a photo from the device's * image gallery. The image is passed to the success callback as a * Base64-encoded `String`, or as the URI for the image file. * * The `camera.getPicture` function opens the device's default camera * application that allows users to snap pictures by default - this behavior occurs, * when `Camera.sourceType` equals [`Camera.PictureSourceType.CAMERA`]{@link module:Camera.PictureSourceType}. * Once the user snaps the photo, the camera application closes and the application is restored. * * If `Camera.sourceType` is `Camera.PictureSourceType.PHOTOLIBRARY` or * `Camera.PictureSourceType.SAVEDPHOTOALBUM`, then a dialog displays * that allows users to select an existing image. * * The return value is sent to the [`cameraSuccess`]{@link module:Camera.onSuccess} callback function, in * one of the following formats, depending on the specified * `cameraOptions`: * * - A `String` containing the Base64-encoded photo image. * - A `String` representing the image file location on local storage (default). * * You can do whatever you want with the encoded image or URI, for * example: * * - Render the image in an `&lt;img&gt;` tag, as in the example below * - Save the data locally (`LocalStorage`, [Lawnchair](http://brianleroux.github.com/lawnchair/), etc.) * - Post the data to a remote server * * __NOTE__: Photo resolution on newer devices is quite good. Photos * selected from the device's gallery are not downscaled to a lower * quality, even if a `quality` parameter is specified. To avoid common * memory problems, set `Camera.destinationType` to `FILE_URI` rather * than `DATA_URL`. * * __Supported Platforms__ * * - Android * - BlackBerry * - Browser * - Firefox * - FireOS * - iOS * - Windows * - WP8 * - Ubuntu * * More examples [here](#camera-getPicture-examples). Quirks [here](#camera-getPicture-quirks). * * @example * navigator.camera.getPicture(cameraSuccess, cameraError, cameraOptions); * @param {module:Camera.onSuccess} successCallback * @param {module:Camera.onError} errorCallback * @param {module:Camera.CameraOptions} options CameraOptions */ cameraExport.getPicture = function (successCallback, errorCallback, options) { argscheck.checkArgs('fFO', 'Camera.getPicture', arguments); options = options || {}; var getValue = argscheck.getValue; var quality = getValue(options.quality, 50); var destinationType = getValue(options.destinationType, Camera.DestinationType.FILE_URI); var sourceType = getValue(options.sourceType, Camera.PictureSourceType.CAMERA); var targetWidth = getValue(options.targetWidth, -1); var targetHeight = getValue(options.targetHeight, -1); var encodingType = getValue(options.encodingType, Camera.EncodingType.JPEG); var mediaType = getValue(options.mediaType, Camera.MediaType.PICTURE); var allowEdit = !!options.allowEdit; var correctOrientation = !!options.correctOrientation; var saveToPhotoAlbum = !!options.saveToPhotoAlbum; var popoverOptions = getValue(options.popoverOptions, null); var cameraDirection = getValue(options.cameraDirection, Camera.Direction.BACK); var args = [quality, destinationType, sourceType, targetWidth, targetHeight, encodingType, mediaType, allowEdit, correctOrientation, saveToPhotoAlbum, popoverOptions, cameraDirection]; exec(successCallback, errorCallback, 'Camera', 'takePicture', args); // XXX: commented out // return new CameraPopoverHandle(); }; /** * Removes intermediate image files that are kept in temporary storage * after calling [`camera.getPicture`]{@link module:Camera.getPicture}. Applies only when the value of * `Camera.sourceType` equals `Camera.PictureSourceType.CAMERA` and the * `Camera.destinationType` equals `Camera.DestinationType.FILE_URI`. * * __Supported Platforms__ * * - iOS * * @example * navigator.camera.cleanup(onSuccess, onFail); * * function onSuccess() { * console.log(\"Camera cleanup success.\") * } * * function onFail(message) { * alert('Failed because: ' + message); * } */ cameraExport.cleanup = function (successCallback, errorCallback) { exec(successCallback, errorCallback, 'Camera', 'cleanup', []); }; module.exports = cameraExport; × Search results Close "},"cordova-plugin-camera_www_CameraConstants.js.html":{"id":"cordova-plugin-camera_www_CameraConstants.js.html","title":"Source: cordova-plugin-camera/www/CameraConstants.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: cordova-plugin-camera/www/CameraConstants.js /* * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. * */ /** * @module CameraConstants */ module.exports = { /** * @description * Defines the output format of `Camera.getPicture` call. * _Note:_ On iOS passing `DestinationType.NATIVE_URI` along with * `PictureSourceType.PHOTOLIBRARY` or `PictureSourceType.SAVEDPHOTOALBUM` will * disable any image modifications (resize, quality change, cropping, etc.) due * to implementation specific. * * @enum {number} */ DestinationType: { /** Return base64 encoded string. DATA_URL can be very memory intensive and cause app crashes or out of memory errors. Use FILE_URI or NATIVE_URI if possible */ DATA_URL: 0, /** Return file uri (content://media/external/images/media/2 for Android) */ FILE_URI: 1, /** Return native uri (eg. asset-library://... for iOS) */ NATIVE_URI: 2 }, /** * @enum {number} */ EncodingType: { /** Return JPEG encoded image */ JPEG: 0, /** Return PNG encoded image */ PNG: 1 }, /** * @enum {number} */ MediaType: { /** Allow selection of still pictures only. DEFAULT. Will return format specified via DestinationType */ PICTURE: 0, /** Allow selection of video only, ONLY RETURNS URL */ VIDEO: 1, /** Allow selection from all media types */ ALLMEDIA: 2 }, /** * @description * Defines the output format of `Camera.getPicture` call. * _Note:_ On iOS passing `PictureSourceType.PHOTOLIBRARY` or `PictureSourceType.SAVEDPHOTOALBUM` * along with `DestinationType.NATIVE_URI` will disable any image modifications (resize, quality * change, cropping, etc.) due to implementation specific. * * @enum {number} */ PictureSourceType: { /** Choose image from the device's photo library (same as SAVEDPHOTOALBUM for Android) */ PHOTOLIBRARY: 0, /** Take picture from camera */ CAMERA: 1, /** Choose image only from the device's Camera Roll album (same as PHOTOLIBRARY for Android) */ SAVEDPHOTOALBUM: 2 }, /** * Matches iOS UIPopoverArrowDirection constants to specify arrow location on popover. * @enum {number} */ PopoverArrowDirection: { ARROW_UP: 1, ARROW_DOWN: 2, ARROW_LEFT: 4, ARROW_RIGHT: 8, ARROW_ANY: 15 }, /** * @enum {number} */ Direction: { /** Use the back-facing camera */ BACK: 0, /** Use the front-facing camera */ FRONT: 1 } }; × Search results Close "},"cordova-plugin-camera_www_CameraPopoverOptions.js.html":{"id":"cordova-plugin-camera_www_CameraPopoverOptions.js.html","title":"Source: cordova-plugin-camera/www/CameraPopoverOptions.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: cordova-plugin-camera/www/CameraPopoverOptions.js /* * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. * */ var Camera = require('./Camera'); /** * iOS-only parameters that specify the anchor element location and arrow * direction of the popover when selecting images from an iPad's library * or album. * Note that the size of the popover may change to adjust to the * direction of the arrow and orientation of the screen. Make sure to * account for orientation changes when specifying the anchor element * location. * @module CameraPopoverOptions * @param {Number} [x=0] - x pixel coordinate of screen element onto which to anchor the popover. * @param {Number} [y=32] - y pixel coordinate of screen element onto which to anchor the popover. * @param {Number} [width=320] - width, in pixels, of the screen element onto which to anchor the popover. * @param {Number} [height=480] - height, in pixels, of the screen element onto which to anchor the popover. * @param {module:Camera.PopoverArrowDirection} [arrowDir=ARROW_ANY] - Direction the arrow on the popover should point. * @param {Number} [popoverWidth=0] - width of the popover (0 or not specified will use apple's default width). * @param {Number} [popoverHeight=0] - height of the popover (0 or not specified will use apple's default height). */ var CameraPopoverOptions = function (x, y, width, height, arrowDir, popoverWidth, popoverHeight) { // information of rectangle that popover should be anchored to this.x = x || 0; this.y = y || 32; this.width = width || 320; this.height = height || 480; this.arrowDir = arrowDir || Camera.PopoverArrowDirection.ARROW_ANY; this.popoverWidth = popoverWidth || 0; this.popoverHeight = popoverHeight || 0; }; module.exports = CameraPopoverOptions; × Search results Close "},"cordova-plugin-media-capture_www_capture.js.html":{"id":"cordova-plugin-media-capture_www_capture.js.html","title":"Source: cordova-plugin-media-capture/www/capture.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: cordova-plugin-media-capture/www/capture.js /* * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. * */ /** * @exports Capture */ var exec = require('cordova/exec'); var helpers = require('./helpers'); /** * Launches a capture of different types. * * @param (DOMString} type * @param {Function} successCB * @param {Function} errorCB * @param {CaptureVideoOptions} options */ function _capture (type, successCallback, errorCallback, options) { var win = function (pluginResult) { successCallback(helpers.wrapMediaFiles(pluginResult)); }; exec(win, errorCallback, 'Capture', type, [options]); } /** * The Capture interface exposes an interface to the camera and microphone of the hosting device. */ function Capture () { this.supportedAudioModes = []; this.supportedImageModes = []; this.supportedVideoModes = []; } /** * Launch audio recorder application for recording audio clip(s). * * @param {Function} successCB * @param {Function} errorCB * @param {CaptureAudioOptions} options */ Capture.prototype.captureAudio = function (successCallback, errorCallback, options) { _capture('captureAudio', successCallback, errorCallback, options); }; /** * Launch camera application for taking image(s). * * @param {Function} successCB * @param {Function} errorCB * @param {CaptureImageOptions} options */ Capture.prototype.captureImage = function (successCallback, errorCallback, options) { _capture('captureImage', successCallback, errorCallback, options); }; /** * Launch device camera application for recording video(s). * * @param {Function} successCB * @param {Function} errorCB * @param {CaptureVideoOptions} options */ Capture.prototype.captureVideo = function (successCallback, errorCallback, options) { _capture('captureVideo', successCallback, errorCallback, options); }; module.exports = new Capture(); × Search results Close "},"elastos-trinity-plugins-carrier_www_carrier.js.html":{"id":"elastos-trinity-plugins-carrier_www_carrier.js.html","title":"Source: elastos-trinity-plugins-carrier/www/carrier.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: elastos-trinity-plugins-carrier/www/carrier.js /* * Copyright (c) 2018 Elastos Foundation * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in all * copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE * SOFTWARE. */ var exec = require('cordova/exec'); const CARRIER_CB_NAMES = [ \"onConnection\", \"onReady\", \"onSelfInfoChanged\", \"onFriends\", \"onFriendConnection\", \"onFriendInfoChanged\", \"onFriendPresence\", \"onFriendRequest\", \"onFriendAdded\", \"onFriendRemoved\", \"onFriendMessage\", \"onFriendInviteRequest\", \"onSessionRequest\", ]; const STREAM_CB_NAMES = [ \"onStateChanged\", \"onStreamData\", \"onChannelOpen\", \"onChannelOpened\", \"onChannelClose\", \"onChannelData\", \"onChannelPending\", \"onChannelResume\", ]; /** * @module CarrierPlugin */ /** * The Carrier user information. * * @typedef BootstrapNode * @type {Object} * @property {string} ipv4 The server ipv4. * @property {string} ipv6 The server ipv6. * @property {string} port The server port. * @property {string} publicKey The publicKey. */ /** * Options defines several settings that control the way the Carrier node connects to the carrier network. * Default values are not defined for bootstraps options, so application should be set bootstrap nodes clearly. * * @typedef Options * @type {Object} * @property {Boolean} udpEnabled Set to use udp transport or not. Setting this value to false will force carrier node to TCP only, * which will potentially slow down the message to run through. * @property {string} persistentLocation Set the persistent data location. The location must be set. * @property {Array} bootstraps BootstrapNode Array. */ /** * The Carrier user information. * * @typedef UserInfo * @type {Object} * @property {string} userId The user ID. * @property {string} name The nickname. * @property {string} description user's brief description. * @property {Boolean} hasAvatar Has avatar or not. * @property {string} gender The gender. * @property {string} phone The phone number. * @property {string} email The email address. * @property {string} region The region. */ /** * The Carrier friend information. * * @typedef FriendInfo * @type {Object} * @property {UserInfo} userInfo The user info. * @property {PresenceStatus} presence The presence status. * @property {ConnectionStatus} connection The connection status. * @property {string} label The friend's label name. */ /** * The netword address information. * * @typedef AddressInfo * @type {Object} * @property {CandidateType} type The address type. * @property {string} address The address. * @property {string} port The port. * @property {string} [relatedAddress] The related address status. * @property {string} [relatedPort] The related port. */ /** * The netword transport information. * * @typedef TransportInfo * @type {Object} * @property {NetworkTopology} topology The network topology. * @property {AddressInfo} localAddr The local address. * @property {AddressInfo} remoteAddr The remote address. */ /** * The Carrier callbacks. * * @typedef CarrierCallbacks * @type {Object} * @property {onConnection} onConnection The callback function to process the self connection status. * @property {onReady} onReady The callback function to process the ready notification. * @property {onSelfInfoChanged} onSelfInfoChanged The callback function to process the self info changed event. * @property {onFriends} onFriends The callback function to iterate the each friend item in friend list. * @property {onFriendConnection} onFriendConnection The callback function to process the friend connections status changed event. * @property {onFriendInfoChanged} onFriendInfoChanged The callback function to process the friend information changed event. * @property {onFriendPresence} onFriendPresence The callback function to process the friend presence changed event. * @property {onFriendRequest} onFriendRequest The callback function to process the friend request. * @property {onFriendAdded} onFriendAdded The callback function to process the new friend added event. * @property {onFriendRemoved} onFriendRemoved The callback function to process the friend removed event. * @property {onFriendMessage} onFriendMessage The callback function to process the friend message. * @property {onFriendInviteRequest} onFriendInviteRequest The callback function to process the friend invite request. * @property {onSessionRequest} onSessionRequest The callback function that handle session request. */ /** * The Stream callbacks. * * @typedef StreamCallbacks * @type {Object} * @property {onStateChanged} onStateChanged The callback function to report state of stream when it's state changes. * @property {onStreamData} onStreamData The callback will be called when the stream receives incoming packet. * @property {onChannelOpen} onChannelOpen The callback function to be called when new multiplexing channel opened. * @property {onChannelOpened} onChannelOpened The callback function to be called when new multiplexing channel opened. * @property {onChannelClose} onChannelClose The callback function to be called when channel close. * @property {onChannelData} onChannelData The callback functiont to be called when channel received incoming data. * @property {onChannelPending} onChannelPending The callback function to be called when remote peer ask to pend data sending. * @property {onChannelResume} onChannelResume The callback function to be called when remote peer ask to resume data sending. */ /** * The callback function to process the friend invite response. * * @callback onFriendInviteResponse * * @param {string} from The target user id who send friend invite response * @param {number} status The status code of invite response. 0 is success, otherwise error * @param {string} reason The error message if status is error, otherwise null * @param {string} data The application defined data return by target user */ /** * The callback function to receive session request complete event. * * @callback onSessionRequestComplete * * @param {Session} session The carrier session instance. * @param {number} status The status code of the response. 0 is success, otherwise is error. * @param {string} reason The error message if status is error, or nil if session request error happened. * @param {string} sdp The remote users SDP. Reference: https://tools.ietf.org/html/rfc4566 */ /** * The class representing Carrier stream. * @class */ function Stream() { this.objId = null; this.carrierPlugin = null; /** @property {number} id Stream ID. **/ this.id = null; /** @property {Carrier} carrier Parent carrier object. **/ this.carrier = null; /** @property {Session} session Parent session object. **/ this.session = null; this.callbacks = { /* Common callbacks */ /** * The callback function to report state of stream when it's state changes. * * @callback onStateChanged * * @param {Stream} stream The carrier stream instance * @param {StreamState} state Stream state defined in StreamState */ onStateChanged: null, /* Stream layered data callbacks */ /** * The callback will be called when the stream receives incoming packet. * If the stream enabled multiplexing mode, application will not * receive stream-layered data callback any more. All data will reported * as multiplexing channel data. * * @callback onStreamData * * @param {Stream} stream The carrier stream instance * @param {base64} data The received packet data. */ onStreamData: null, /* Channel callbacks */ /** * The callback function to be called when new multiplexing channel request to open. * * @callback onChannelOpen * * @param * @param {Stream} stream The carrier stream instance * @param {number} channel The current channel ID. * @param {string} cookie Application defined string data send from remote peer. * */ onChannelOpen: null, /** * The callback function to be called when new multiplexing channel opened. * * @callback onChannelOpened * * @param {Stream} stream The carrier stream instance * @param {number} channel The current channel ID. */ onChannelOpened: null, /** * The callback function to be called when channel close. * * @callback onChannelClose * * @param {Stream} stream The carrier stream instance * @param {number} channel The current channel ID. * @param {string} reason Channel close reason code, defined in CloseReason. */ onChannelClose: null, /** * The callback functiont to be called when channel received incoming data. * * @callback onChannelData * * @param {Stream} stream The carrier stream instance * @param {number} channel The current channel ID. * @param {base64} data The received packet data. */ onChannelData: null, /** * The callback function to be called when remote peer ask to pend data sending. * * @callback onChannelPending * * @param {Stream} stream The carrier stream instance * @param {number} channel The current channel ID. */ onChannelPending: null, /** * The callback function to be called when remote peer ask to resume data sending. * * @callback onChannelResume * * @param {Stream} stream The carrier stream instance * @param {number} channel The current channel ID. */ onChannelResume: null, } } Stream.prototype = { constructor: Stream, /** * Add or remove Stream callback. * * @param {string} name The callback name. * @param {Function} callback The function to add or change callback function. If set to null, will remove callback. */ on: function (name, callback) { if (typeof callback != 'function') { return false; } for (var i = 0; i &lt; STREAM_CB_NAMES.length; i++) { if (name == STREAM_CB_NAMES[i]) { this.callbacks[name] = callback; return true; } } return fasle; }, process: function (onSuccess, onError, name, args) { var me = this; var _onSuccess = function (ret) { ret.stream = me; if (onSuccess) onSuccess(ret); }; exec(_onSuccess, onError, 'CarrierPlugin', name, args); }, /** * Get tranport info of carrier stream. * @param {Function} onSuccess The function to call when success, the param is a TransportInfo object * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. */ getTransportInfo: function (onSuccess, onError) { this.process(onSuccess, onError, \"getTransportInfo\", [this.objId]); }, /** * Send outgoing data to remote peer. * If the stream is in multiplexing mode, application can not call this function. * * @param {Function} onSuccess The function to call when success, the param is a Number: Bytes of data sent. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. * @param {base64} data The send data. */ write: function (onSuccess, onError, data) { this.process(onSuccess, onError, \"streamWrite\", [this.objId, data]); }, /** * Open a new channel on multiplexing stream. * If the stream is in multiplexing mode, application can not call this function. * * @param {Function} onSuccess The function to call when success, the param is a Number: New channel ID. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. * @param {string} cookie The application defined data passed to remote peer */ openChannel: function (onSuccess, onError, cookie) { this.process(onSuccess, onError, \"openChannel\", [this.objId, cookie]); }, /** * Close a new channel on multiplexing stream. * If the stream is in multiplexing mode, application can not call this function. * * @param {Function} onSuccess The function to call when success. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. * @param {number} channel The channel ID to close */ closeChannel: function (onSuccess, onError, channel) { this.process(onSuccess, onError, \"closeChannel\", [this.objId, channel]); }, /** * Send outgoing data to remote peer. * If the stream is in multiplexing mode, application can not call this function. * * @param {Function} onSuccess The function to call when success, the param is a Number: Bytes of data sent. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. * @param {number} channel The current channel ID. * @param {base64} data The send data. */ writeChannel: function (onSuccess, onError, channel, data) { this.process(onSuccess, onError, \"writeChannel\", [this.objId, channel, data]); }, /** * Request remote peer to pend channel data sending. * If the stream is in multiplexing mode, application can not call this function. * * @param {Function} onSuccess The function to call when success. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. * @param {number} channel The current channel ID. */ pendChannel: function (onSuccess, onError, channel) { this.process(onSuccess, onError, \"pendChannel\", [this.objId, channel]); }, /** * Request remote peer to resume channel data sending. * If the stream is in multiplexing mode, application can not call this function. * * @param {Function} onSuccess The function to call when success. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. * @param {number} channel The current channel ID. */ resumeChannel: function (onSuccess, onError, channel) { this.process(onSuccess, onError, \"resumeChannel\", [this.objId, channel]); }, /** * Open a port forwarding to remote service over multiplexing. * If the stream is in multiplexing mode, application can not call this function. * * @param {Function} onSuccess The function to call when success, the param is a Number: Port forwarding ID. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. * @param {string} service The remote service name * @param {PortForwardingProtocol} protocol Port forwarding protocol * @param {string} host Local host or ip to binding. If host is null, port forwarding will bind to localhost * @param {number} port Local port to binding. */ openPortForwarding: function (onSuccess, onError, service, protocol, host, port) { this.process(onSuccess, onError, \"openPortForwarding\", [this.objId, service, protocol, host, port]); }, /** * Close a port forwarding. * If the stream is in multiplexing mode, application can not call this function. * * @param {Function} onSuccess The function to call when success. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. * @param {number} portForwarding The portforwarding ID. */ closePortForwarding: function (onSuccess, onError, portForwarding) { this.process(onSuccess, onError, \"closePortForwarding\", [this.objId, portForwarding]); }, } /** * The class representing Carrier Session. * @class */ function Session() { this.objId = null; this.carrierPlugin = null; this.streams = []; /** @property {string} peer The remote peer userid. **/ this.peer = null; /** @property {Carrier} carrier Parent carrier object. */ this.carrier = null; } Session.prototype = { constructor: Session, process: function (onSuccess, onError, name, args) { var me = this; var _onSuccess = function (ret) { ret.session = me; if (onSuccess) onSuccess(ret); }; exec(_onSuccess, onError, 'CarrierPlugin', name, args); }, /** * Close a session to friend. All resources include streams, channels, portforwardings * associated with current session will be destroyed. */ close: function (onSuccess, onError) { this.process(onSuccess, onError, \"sessionClose\", [this.objId]); }, // /** // * Get remote peer id. // * // * @param {Function} onSuccess The function to call when success, the param is a String: The remote peer userid. // * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. // */ // getPeer: function (onSuccess, onError) { // this.process(onSuccess, onError, \"getPeer\", [this.objId]); // }, /** * Send session request to the friend. * * @param {Function} onSuccess The function to call when success. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. * @param {onSessionRequestComplete} handler A handler to the SessionRequestCompleteHandler to receive the session response */ request: function (onSuccess, onError, handler) { var handlerId = 0; if (typeof handler == \"function\") { handlerId = this.carrierPlugin.addSessionRequestCompleteCB(handler, this); } this.process(onSuccess, onError, \"sessionRequest\", [this.objId, handlerId]); }, /** * Reply the session request from friend. * * This function will send a session response to friend. * * @param {Function} onSuccess The function to call when success. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. * @param {number} status The status code of the response. 0 is success, otherwise is error * @param {string} reason The error message if status is error, or null if success */ replyRequest: function (onSuccess, onError, status, reason) { this.process(onSuccess, onError, \"sessionReplyRequest\", [this.objId, status, reason]); }, /** * Begin to start a session. * * All streams in current session will try to connect with remote friend, * The stream status will update to application by stream's StreamHandler. * * @param {Function} onSuccess The function to call when success. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. * @param {string} sdp The remote user's SDP. Reference: https://tools.ietf.org/html/rfc4566 */ start: function (onSuccess, onError, sdp) { this.process(onSuccess, onError, \"sessionStart\", [this.objId, sdp]); }, /** * Add a new stream to session. * * Carrier stream supports several underlying transport mechanisms: * * - Plain/encrypted UDP data gram protocol * - Plain/encrypted TCP like reliable stream protocol * - Multiplexing over UDP * - Multiplexing over TCP like reliable protocol * * Application can use options to specify the new stream mode. * Multiplexing over UDP can not provide reliable transport. * * @param {Function} onSuccess The function to call when success, the param is a Stream object: The new added carrier stream. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. * @param {StreamType} type The stream type defined in StreamType * @param {number} options The stream mode options. options are constructed by a bitwise-inclusive OR of flags * @param {StreamCallbacks} callbacks The stream callbacks. */ addStream: function (onSuccess, onError, type, options, callbacks) { var stream = new Stream(); var me = this; var _onSuccess = function (ret) { stream.type = type; stream.objId = ret.objId; stream.id = ret.id; stream.carrierPlugin = me.carrierPlugin; stream.carrier = me.carrier; stream.session = me.session; me.streams[stream.id] = stream; me.carrierPlugin.streams[stream.objId] = stream; if (onSuccess) onSuccess(stream); }; if (callbacks) { for (var i = 0; i &lt; STREAM_CB_NAMES.length; i++) { var name = STREAM_CB_NAMES[i]; stream.callbacks[name] = callbacks[name]; } } exec(_onSuccess, onError, 'CarrierPlugin', 'addStream', [this.objId, type, options]); }, /** * Remove a stream from session. * * @param {Function} onSuccess The function to call when success. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. * @param {stream} stream The Stream to be removed */ removeStream: function (onSuccess, onError, stream) { if (stream == this.streams[stream.id]) { var me = this; var _onSuccess = function (ret) { ret.session = me; me.streams[stream.id] = null; me.carrierPlugin.streams[stream.objId] = null; if (onSuccess) onSuccess(ret); }; exec(_onSuccess, onError, 'CarrierPlugin', \"removeStream\", [this.objId, stream.objId]); } else { error(\"This steam isn't belong the session!\"); } }, /** * Add a new portforwarding service to session. * * The registered services can be used by remote peer in portforwarding request. * * @param {Function} onSuccess The function to call when success. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. * @param {string} service The new service name, should be unique in session scope. * @param {PortForwardingProtocol} protocol The protocol of the service. * @param {string} host The host name or ip of the service. * @param {number} port The port of the service. */ addService: function (onSuccess, onError, service, protocol, host, port) { this.process(onSuccess, onError, \"addService\", [this.objId, service, protocol, host, port]); }, /** * Remove a portforwarding server to session. * * This function has not effect on existing portforwarings. * * @param {Function} onSuccess The function to call when success. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. * @param {string} service The service name. */ removeService: function (onSuccess, onError, service) { this.process(onSuccess, onError, \"removeService\", [this.objId, service]); } } /** * The class representing Carrier. * @class */ function Carrier() { this.objId = null; this.carrierPlugin = null; /** @property {string} nodeId Node id. **/ this.nodeId = null; /** @property {string} userId User id. **/ this.userId = null; /** @property {string} address Node address. **/ this.address = null; this._nospam = null; this._presence = null; this.callbacks = { /** * The callback function to process the self connection status. * *@callback onConnection * * @param {Carrier} carrier Carrier node instance * @param {number} status Current connection status. @see ConnectionStatus */ onConnection: null, /** * The callback function to process the ready notification. * * Application should wait this callback invoked before calling any * function to interact with friends. * * @callback onReady * * @param {Carrier} carrier Carrier node instance */ onReady: null, /** * The callback function to process the self info changed event. * * @callback onSelfInfoChanged * * @param {Carrier} carrier Carrier node instance * @param {UserInfo} userInfo The updated user information */ onSelfInfoChanged: null, /** * The callback function to iterate the each friend item in friend list. * * @callback onFriends * * @param {Carrier} carrier Carrier node instance * @param {Array} friends The friends list. */ onFriends: null, /** * The callback function to process the friend connections status changed event. * * @callback onFriendConnection * * @param {Carrier} carrier Carrier node instance * @param {string} friendId The friend's user id. * @param {number} status The connection status of friend. @see ConnectionStatus */ onFriendConnection: null, /** * The callback function to process the friend information changed event. * * @callback onFriendInfoChanged * * @param {Carrier} carrier Carrier node instance * @param {string} friendId The friend's user id * @param {FriendInfo} info The update friend information */ onFriendInfoChanged: null, /** * The callback function to process the friend presence changed event. * * @callback onFriendPresence * * @param {Carrier} carrier Carrier node instance * @param {string} friendId The friend's user id * @param {number} presence The presence status of the friend */ onFriendPresence: null, /** * The callback function to process the friend request. * * @callback onFriendRequest * * @param {Carrier} carrier Carrier node instance * @param {string} userId The user id who want be friend with current user * @param {UserInfo} info The user information to `userId` * @param {string} hello The PIN for target user, or any application defined content */ onFriendRequest: null, /** * The callback function to process the new friend added event. * * @callback onFriendAdded * * @param {Carrier} carrier Carrier node instance * @param {FriendInfo} friendInfo The added friend's information */ onFriendAdded: null, /** * The callback function to process the friend removed event. * * @callback onFriendRemoved * * @param {Carrier} carrier Carrier node instance * @param {string} friendId The friend's user id */ onFriendRemoved: null, /** * The callback function to process the friend message. * * @callback onFriendMessage * * @param {Carrier} carrier Carrier node instance * @param {string} from The id from who send the message * @param {string} message The message content */ onFriendMessage: null, /** * The callback function to process the friend invite request. * * @callback onFriendInviteRequest * * @param {Carrier} carrier Carrier node instance * @param {string} from The user id from who send the invite request * @param {string} data The application defined data sent from friend */ onFriendInviteRequest: null, /** * The callback function that handle session request. * * @callback onSessionRequest * * @param {Carrier} carrier Carrier node instance * @param {string} from The id who send the message * @param {string} sdp The remote users SDP. Reference: https://tools.ietf.org/html/rfc4566 */ onSessionRequest: null, } } Carrier.prototype = { constructor: Carrier, /** @property {number} nospam The nospam for Carrier address is used to eliminate spam friend. **/ set nospam(value) { var me = this; var success = function(ret) { me._nospam = value; }; this.process(success, null, \"setNospam\", [this.objId, value]); }, get nospam() { return this._nospam; }, /** @property {number} presence Presence status. **/ set presence(value) { var me = this; var success = function(ret) { me._presence = value; }; this.process(success, null, \"setPresence\", [this.objId, value]); }, get presence() { return this._presence; }, /** * Add or remove Carrier callback. * * @param {string} name The callback name. * @param {Function} callback The function to add or change callback function. If set to null, will remove callback. */ on: function (name, callback) { if (typeof callback != 'function') { return false; } for (var i = 0; i &lt; CARRIER_CB_NAMES.length; i++) { if (name == CARRIER_CB_NAMES[i]) { this.callbacks[name] = callback; return true; } } return fasle; }, process: function (onSuccess, onError, name, args) { var me = this; var _onSuccess = function (ret) { ret.carrier = me; if (onSuccess) onSuccess(ret); }; exec(_onSuccess, onError, 'CarrierPlugin', name, args); }, /** * Start carrier node asynchronously to connect to carrier network. If the connection * to network is successful, carrier node starts working. * * @param {Function} onSuccess The function to call when success. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. * @param {number} iterateInterval Internal loop interval, in milliseconds. */ start: function (onSuccess, onError, iterateInterval) { this.process(onSuccess, onError, \"carrierStart\", [this.objId, iterateInterval]); }, /** * Get self user information. * * @param {Function} onSuccess The function to call when success, the param is a UserInfo: the user information to the carrier node. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. */ getSelfInfo: function (onSuccess, onError) { this.process(onSuccess, onError, \"getSelfInfo\", [this.objId]); }, /** * Update self user information. * After self user information changed, carrier node will update this information * to carrier network, and thereupon network broadcasts the change to all friends. * * @param {Function} onSuccess The function to call when success. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. * @param {UserInfo} userinfo The user information to update for this carrier node. */ setSelfInfo: function (onSuccess, onError, name, value) { this.process(onSuccess, onError, \"setSelfInfo\", [this.objId, name, value]); }, // /** // * Get the nospam for Carrier address. // * // * Get the 4-byte nospam part of the Carrier address with host byte order // * expected. Nospam for Carrier address is used to eliminate spam friend // * request. // * // * @param {Function} onSuccess The function to call when success, the param is a Number: nospam. // * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. // */ // getNospam: function (onSuccess, onError) { // this.process(onSuccess, onError, \"getNospam\", [this.objId]); // }, // /** // * Update self nospam of address for this carrier node. // * // * Update the nospam of carrier node address with host byte order // * expected. Nospam for Carrier address is used to eliminate spam friend // * request. // * // * @param {Function} onSuccess The function to call when success. // * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. // * @param {number} nospam An integer value. // */ // setNospam: function (onSuccess, onError, nospam) { // this.process(onSuccess, onError, \"setNospam\", [this.objId, nospam]); // }, // /** // * Get self presence status. // * // * @param {Function} onSuccess The function to call when success, the param is a Number: presence status. // * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. // */ // getPresence: function (onSuccess, onError) { // this.process(onSuccess, onError, \"getPresence\", [this.objId]); // }, // /** // * Update self presence status. // * // * @param {Function} onSuccess The function to call when success. // * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. // * @param {number} presence the new presence status. // */ // setPresence: function (onSuccess, onError, presence) { // this.process(onSuccess, onError, \"setPresence\", [this.objId, presence]); // }, /** * Check if carrier node instance is being ready. * * All carrier interactive APIs should be called only if carrier node instance * is being ready. * * @param {Function} onSuccess The function to call when success, the param is a Boolean: true if the carrier node instance is ready, or false if not. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. */ isReady: function (onSuccess, onError) { this.process(onSuccess, onError, \"isReady\", [this.objId]); }, /** * Get friends list. * * @param {Function} onSuccess The function to call when success, the param is a {friendId: info} Object: The list of friend information to current user. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. */ getFriends: function (onSuccess, onError) { this.process(onSuccess, onError, \"getFriends\", [this.objId]); }, /** * Get specified friend information. * * @param {Function} onSuccess The function to call when success, the param is a FriendInfo: The friend information. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. * @param {string} userId The user identifier of friend */ getFriend: function (onSuccess, onError, userId) { this.process(onSuccess, onError, \"getFriend\", [this.objId, userId]); }, /** * Set the label of the specified friend. * * The label of a friend is a private alias name for current user. It can be * seen by current user only, and has no impact to the target friend itself. * * @param {Function} onSuccess The function to call when success. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. * @param {string} userId The friend's user identifier * @param {string} label The new label of specified friend */ labelFriend: function (onSuccess, onError, userId, label) { this.process(onSuccess, onError, \"labelFriend\", [this.objId, userId, label]); }, /** * Check if the user ID is friend. * * @param {Function} onSuccess The function to call when success, the param is a Boolean: True if the user is a friend, or false if not. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. * @param {string} userId The userId to check. */ isFriend: function (onSuccess, onError, userId, label) { this.process(onSuccess, onError, \"isFriend\", [this.objId, userId]); }, /** * Add friend by sending a new friend request. * * This function will add a new friend with specific address, and then * send a friend request to the target node. * * @param {Function} onSuccess The function to call when success. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. * @param {string} address the target user address of remote carrier node. * @param {string} hello PIN for target user, or any application defined content. */ addFriend: function (onSuccess, onError, address, hello) { this.process(onSuccess, onError, \"addFriend\", [this.objId, address, hello]); }, /** * Accept the friend request. * * This function is used to add a friend in response to a friend request. * * @param {Function} onSuccess The function to call when success. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. * @param {string} userId The user id who want be friend with us. */ acceptFriend: function (onSuccess, onError, userId) { this.process(onSuccess, onError, \"acceptFriend\", [this.objId, userId]); }, /** * Remove a friend. * * This function will remove a friend on this carrier node. * * @param {Function} onSuccess The function to call when success. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. * @param {string} userId The target user id to remove friendship */ removeFriend: function (onSuccess, onError, userId) { this.process(onSuccess, onError, \"removeFriend\", [this.objId, userId]); }, /** * Send a message to a friend. * * The message length may not exceed MAX_APP_MESSAGE_LEN, and message itself * should be text-formatted. Larger messages must be split by application * and sent as separate messages. Other nodes can reassemble the fragments. * * @param {Function} onSuccess The function to call when success. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. * @param {string} to The target id * @param {string} message The message content defined by application */ sendFriendMessage: function (onSuccess, onError, to, message) { this.process(onSuccess, onError, \"sendFriendMessage\", [this.objId, to, message]); }, /** * Send invite request to a friend. * * Application can attach the application defined data with in the invite * request, and the data will send to target friend. * * @param {Function} onSuccess The function to call when success. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. * @param {string} to The target id * @param {string} data The application defined data send to target user * @param {onFriendInviteResponse} handler The handler to receive invite reponse */ inviteFriend: function (onSuccess, onError, to, data, handler) { var handlerId = 0; if (typeof handler == \"function\") { handlerId = this.carrierPlugin.addFriendInviteResponseCB(handler, this); } this.process(onSuccess, onError, \"inviteFriend\", [this.objId, to, data, handlerId]); }, /** * Reply the friend invite request. * * This function will send a invite response to friend. * * @param {Function} onSuccess The function to call when success. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. * @param {string} to The id who send invite request * @param {number} status The status code of the response. 0 is success, otherwise is error * @param {string} reason The error message if status is error, or null if success * @param {string} data The application defined data send to target user. If the status is error, this will be ignored */ replyFriendInvite: function (onSuccess, onError, to, status, reason, data) { this.process(onSuccess, onError, \"replyFriendInvite\", [this.objId, to, status, reason, data]); }, /** * Create a new session to a friend. * * The session object represent a conversation handle to a friend. * * @param {Function} onSuccess The function to call when success, the param is a Session Object: The new Session object * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. * @param {string} to The target id(userid or userid@nodeid). */ newSession: function (onSuccess, onError, to) { var me = this; var _onSuccess = function (ret) { var session = new Session(); session.objId = ret.id; session.peer = ret.peer; session.carrier = me; session.carrierPlugin = me.carrierPlugin; if (onSuccess) onSuccess(session); }; exec(_onSuccess, onError, 'CarrierPlugin', 'newSession', [this.objId, to]); }, /** * Disconnect carrier node from carrier network, and destroy all associated resources to carreier node instance. * After calling the method, the carrier node instance becomes invalid. * * @param {Function} onSuccess The function to call when success. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. */ destroy: function (onSuccess, onError) { exec(onSuccess, onError, 'CarrierPlugin', 'destroy', [this.objId]); } } /** * @exports carrierPlugin */ function CarrierPlugin() { this.carriers = []; this.streams = []; this.FriendInviteEvent = []; this.FriendInviteCount = 0; this.SRCEvent = []; this.SRCCount = 0; const CARRIER = 1; const SESSION = 2; const STREAM = 3; const FRIEND_INVITE = 4; /** * @description * Carrier node connection status to the carrier network. * * @enum {number} */ this.ConnectionStatus = { /** Carrier node connected to the carrier network. */ CONNECTED: 0, /** There is no connection to the carrier network. */ DISCONNECTED: 1 } /** * @description * Carrier node presence status. * * @enum {number} */ this.PresenceStatus = { /** Carrier node is online and available. */ NONE: 0, /** Carrier node is being away. */ AWAY: 1, /** Carrier node is being busy. */ BUSY: 2 } /** * @description * Carrier stream type. Reference: https://tools.ietf.org/html/rfc4566#section-5.14 https://tools.ietf.org/html/rfc4566#section-8 * * @enum {number} */ this.StreamType = { /** Audio stream. */ AUDIO: 0, /** Video stream. */ VIDEO: 1, /** Text stream. */ TEXT: 2, /** Application stream. */ APPLICATION: 3, /** Message stream. */ MESSAGE: 4, } /** * @description * Carrier stream state The stream state will be changed according to the phase of the stream. * * @enum {number} */ this.StreamState = { /** Raw stream. */ RAW: 0, /** Initialized stream. */ INITIALIZED: 1, /** The underlying transport is ready for the stream to start. */ TRANSPORT_READY: 2, /** The stream is trying to connect the remote. */ CONNECTING: 3, /** The stream connected with remove peer. */ CONNECTED: 4, /** The stream is deactived. */ DEACTIVATED: 5, /** The stream closed gracefully. */ CLOSED: 6, /** The stream is on error, cannot to continue. */ ERROR: 7, } /** * @description * Carrier Stream's candidate type. * * @enum {number} */ this.CandidateType = { /** Host candidate. */ HOST: 0, /** Server reflexive, only valid to ICE transport. */ SERVE_RREFLEXIVE: 1, /** Peer reflexive, only valid to ICE transport. */ PEER_REFLEXIVE: 2, /** Relayed Candidate, only valid to ICE tranport. */ RELAYED: 3, } /** * @description * Carrier network topology for session peers related to each other. * * @enum {number} */ this.NetworkTopology = { /** LAN network topology. */ LAN: 0, /** P2P network topology. */ P2P: 1, /** Relayed netowrk topology. */ RELAYED: 2, } /** * @description * Port forwarding supported protocols. * * @enum {number} */ this.PortForwardingProtocol = { /** TCP protocol. */ TCP: 1, } /** * @description * Multiplexing channel close reason mode. * * @enum {number} */ this.CloseReason = { /** Channel closed normaly. */ NORMAL: 0, /** Channel closed because of timeout. */ TIMEOUT: 1, /** Channel closed because error occured. */ ERROR: 2, } /** * @description * Carrier stream mode. * * @enum {number} */ this.StreamMode = { /** * Compress option, indicates data would be compressed before transmission. * For now, just reserved this bit option for future implement. */ COMPRESS: 1, /** * Encrypt option, indicates data would be transmitted with plain mode. * which means that transmitting data would be encrypted in default. */ PLAIN: 2, /** * Relaible option, indicates data transmission would be reliable, and be * guranteed to received by remote peer, which acts as TCP transmission * protocol. Without this option bitwised, the transmission would be * unreliable as UDP transmission protocol. */ RELIABLE: 4, /** * Multiplexing option, indicates multiplexing would be activated on * enstablished stream, and need to use multipexing APIs related with channel * instread of APIs related strema to send/receive data. */ MULTIPLEXING: 8, /** * PortForwarding option, indicates port forwarding would be activated * on established stream. This options should bitwise with 'Multiplexing' * option. */ PORT_FORWARDING: 16, } Object.freeze(CarrierPlugin.prototype); Object.freeze(Carrier.prototype); Object.freeze(Session.prototype); Object.freeze(Stream.prototype); Object.freeze(this.ConnectionStatus); Object.freeze(this.PresenceStatus); Object.freeze(this.StreamType); Object.freeze(this.StreamState); Object.freeze(this.CandidateType); Object.freeze(this.NetworkTopology); Object.freeze(this.PortForwardingProtocol); Object.freeze(this.CloseReason); Object.freeze(this.StreamMode); exec(function () { }, null, 'CarrierPlugin', 'initVal', []); var me = this; this.onCarrierEvent = function (event) { event.carrier = me.carriers[event.id]; if (event.carrier) { // event.id = null; if (event.carrier.callbacks[event.name]) { event.carrier.callbacks[event.name](event); } } else { alert(event.name); } }, this.onStreamEvent = function (event) { event.stream = me.streams[event.id]; event.id = null; if (event.stream &amp;&amp; event.stream.callbacks[event.name]) { event.stream.callbacks[event.name](event); } }, //FriendInviteResponseHandler this.addFriendInviteResponseCB = function (callback, carrier) { me.FriendInviteCount++; me.FriendInviteEvent[me.FriendInviteCount] = new Object; me.FriendInviteEvent[me.FriendInviteCount].callback = callback; me.FriendInviteEvent[me.FriendInviteCount].carrier = carrier return me.FriendInviteCount; }, this.onFriendInviteResponse = function (event) { var id = event.id; event.id = null; if (me.FriendInviteEvent[id].callback) { event.carrier = me.FriendInviteEvent[id].carrier; me.FriendInviteEvent[id].callback(event); } }; //SessionRequestCompleteHandler this.addSessionRequestCompleteCB = function (callback, session) { me.SRCCount++; me.SRCEvent[me.SRCCount] = new Object; me.SRCEvent[me.SRCCount].callback = callback; me.SRCEvent[me.SRCCount].session = session return me.SRCCount; }; this.onSessionRequestComplete = function (event) { var id = event.id; event.id = null; if (me.SRCEvent[id].callback) { event.session = me.SRCEvent[id].session; me.SRCEvent[id].callback(event); } }; this.setListener(CARRIER, this.onCarrierEvent); this.setListener(STREAM, this.onStreamEvent); this.setListener(FRIEND_INVITE, this.onFriendInviteResponse); this.setListener(SESSION, this.onSessionRequestComplete); } CarrierPlugin.prototype = { constructor: CarrierPlugin, options: { udpEnabled: true, persistentLocation: \".data\" }, setListener: function (type, eventCallback) { exec(eventCallback, null, 'CarrierPlugin', 'setListener', [type]); }, /** * Get current version of Carrier node. * * @param {Function} onSuccess The function to call when success, the param is a String: The version of carrier node. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. * @param {callback} onSuccess The version of carrier node */ getVersion: function (onSuccess, onError) { exec(onSuccess, onError, 'CarrierPlugin', 'getVersion', []); }, /** * Check if the ID is Carrier node id. * * @param {Function} onSuccess The function to call when success, the param is a Boolean: True if id is valid, otherwise false. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. * @param {string} id The carrier node id to be check. */ isValidId: function (onSuccess, onError, id) { var _onSuccess = function (ret) { if (onSuccess) onSuccess(ret == \"true\" ? true : false); }; exec(_onSuccess, onError, 'CarrierPlugin', 'isValidAddress', [id]); }, /** * Check if the carrier node address is valid. * * @param {Function} onSuccess The function to call when success, the param is a Boolean: True if key is valid, otherwise false. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. * @param {string} address The carrier node address to be check. */ isValidAddress: function (onSuccess, onError, address) { var _onSuccess = function (ret) { if (onSuccess) onSuccess(ret == \"true\" ? true : false); }; exec(_onSuccess, onError, 'CarrierPlugin', 'isValidAddress', [address]); }, /** * Get carrier ID from carrier node address. * * @param {Function} onSuccess The function to call when success, the param is a String: User id if address is valid, otherwise null. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. * @param {string} address The carrier node address. */ getIdFromAddress: function (onSuccess, onError, address) { exec(onSuccess, onError, 'CarrierPlugin', 'getIdFromAddress', [address]); }, /** * Create a carrier object instance. After initializing the instance, * it's ready to start and therefore connect to carrier network. * * @param {Function} onSuccess The function to call when success. * @param {Function} [onError] The function to call when error, the param is a String. Or set to null. * @param {Options} [options] The options to set for creating carrier node. If set to null, will use default. * @param {CarrierCallbacks} callbacks The callbacks for carrier node. */ createObject: function (onSuccess, onError, options, callbacks) { var carrier = new Carrier(); var me = this; var _onSuccess = function (ret) { carrier.objId = ret.id; carrier.nodeId = ret.nodeId; carrier.userId = ret.userId; carrier.address = ret.address; carrier._nospam = ret.nospam; carrier._presence = ret.presence; carrier.carrierPlugin = me; me.carriers[carrier.objId] = carrier; if (onSuccess) onSuccess(carrier); }; if (typeof (options) == \"undefined\" || options == null) { options = this.options; } if (typeof (callbacks) != \"undefined\" &amp;&amp; callbacks != null) { for (var i = 0; i &lt; CARRIER_CB_NAMES.length; i++) { var name = CARRIER_CB_NAMES[i]; carrier.callbacks[name] = callbacks[name]; } } var configString = JSON.stringify(options); exec(_onSuccess, onError, 'CarrierPlugin', 'createObject', [\"im\", configString]); }, } CarrierPlugin.prototype.test = function (onSuccess, onError, buf) { // var data = base64.fromArrayBuffer(buf); exec(onSuccess, onError, 'CarrierPlugin', 'test', [buf]); }; module.exports = new CarrierPlugin(); × Search results Close "},"cordova-plugin-network-information_www_Connection.js.html":{"id":"cordova-plugin-network-information_www_Connection.js.html","title":"Source: cordova-plugin-network-information/www/Connection.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: cordova-plugin-network-information/www/Connection.js /* * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. * */ /** * @module Connection * * @description * Network status * * @enum {number} */ module.exports = { UNKNOWN: 'unknown', ETHERNET: 'ethernet', WIFI: 'wifi', CELL_2G: '2g', CELL_3G: '3g', CELL_4G: '4g', CELL: 'cellular', NONE: 'none' }; × Search results Close "},"cordova-plugin-network-information_www_network.js.html":{"id":"cordova-plugin-network-information_www_network.js.html","title":"Source: cordova-plugin-network-information/www/network.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: cordova-plugin-network-information/www/network.js /* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. * */ var exec = require('cordova/exec'); var cordova = require('cordova'); var channel = require('cordova/channel'); var utils = require('cordova/utils'); // Link the onLine property with the Cordova-supplied network info. // This works because we clobber the navigator object with our own // object in bootstrap.js. // Browser platform do not need to define this property, because // it is already supported by modern browsers if (cordova.platformId !== 'browser' &amp;&amp; typeof navigator !== 'undefined') { utils.defineGetter(navigator, 'onLine', function () { return this.connection.type !== 'none'; }); } function NetworkConnection () { this.type = 'unknown'; } /** * Get connection info * * @param {Function} successCallback The function to call when the Connection data is available * @param {Function} errorCallback The function to call when there is an error getting the Connection data. (OPTIONAL) */ NetworkConnection.prototype.getInfo = function (successCallback, errorCallback) { exec(successCallback, errorCallback, 'NetworkStatus', 'getConnectionInfo', []); }; var me = new NetworkConnection(); var timerId = null; var timeout = 500; channel.createSticky('onCordovaConnectionReady'); channel.waitForInitialization('onCordovaConnectionReady'); channel.onCordovaReady.subscribe(function () { me.getInfo(function (info) { me.type = info; if (info === 'none') { // set a timer if still offline at the end of timer send the offline event timerId = setTimeout(function () { cordova.fireDocumentEvent('offline'); timerId = null; }, timeout); } else { // If there is a current offline event pending clear it if (timerId !== null) { clearTimeout(timerId); timerId = null; } cordova.fireDocumentEvent('online'); } // should only fire this once if (channel.onCordovaConnectionReady.state !== 2) { channel.onCordovaConnectionReady.fire(); } }, function (e) { // If we can't get the network info we should still tell Cordova // to fire the deviceready event. if (channel.onCordovaConnectionReady.state !== 2) { channel.onCordovaConnectionReady.fire(); } console.log('Error initializing Network Connection: ' + e); }); }); /** * @module Connection * @example * var connectionStatus = navigator.connection.type; */ module.exports = me; × Search results Close "},"cordova-plugin-flashlight_www_Flashlight.js.html":{"id":"cordova-plugin-flashlight_www_Flashlight.js.html","title":"Source: cordova-plugin-flashlight/www/Flashlight.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: cordova-plugin-flashlight/www/Flashlight.js /** * @exports Flashlight */ function Flashlight() { // track flashlight state this._isSwitchedOn = false; } Flashlight.prototype = { /** @function */ available: function (callback) { cordova.exec(function (avail) { callback(avail ? true : false); }, function() { callback(false); }, \"Flashlight\", \"available\", []); }, /** @function */ switchOn: function (successCallback, errorCallback, options) { var opts = options || {}; this._isSwitchedOn = true; cordova.exec(successCallback, errorCallback, \"Flashlight\", \"switchOn\", [opts]); }, /** @function */ switchOff: function (successCallback, errorCallback) { this._isSwitchedOn = false; cordova.exec(successCallback, errorCallback, \"Flashlight\", \"switchOff\", []); }, /** @function */ toggle: function (successCallback, errorCallback, options) { if (this._isSwitchedOn) { this.switchOff(successCallback, errorCallback); } else { this.switchOn(successCallback, errorCallback, options); } }, /** @function */ isSwitchedOn: function () { return this._isSwitchedOn; } }; Flashlight.install = function () { if (!window.plugins) { window.plugins = {}; } window.plugins.flashlight = new Flashlight(); return window.plugins.flashlight; }; cordova.addConstructor(Flashlight.install); × Search results Close "},"cordova-plugin-geolocation_www_geolocation.js.html":{"id":"cordova-plugin-geolocation_www_geolocation.js.html","title":"Source: cordova-plugin-geolocation/www/geolocation.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: cordova-plugin-geolocation/www/geolocation.js /* * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. * */ /** * @exports Geolocation */ var argscheck = require('cordova/argscheck'); var utils = require('cordova/utils'); var exec = require('cordova/exec'); var PositionError = require('./PositionError'); var Position = require('./Position'); var timers = {}; // list of timers in use // Returns default params, overrides if provided with values function parseParameters (options) { var opt = { maximumAge: 0, enableHighAccuracy: false, timeout: Infinity }; if (options) { if (options.maximumAge !== undefined &amp;&amp; !isNaN(options.maximumAge) &amp;&amp; options.maximumAge &gt; 0) { opt.maximumAge = options.maximumAge; } if (options.enableHighAccuracy !== undefined) { opt.enableHighAccuracy = options.enableHighAccuracy; } if (options.timeout !== undefined &amp;&amp; !isNaN(options.timeout)) { if (options.timeout &lt; 0) { opt.timeout = 0; } else { opt.timeout = options.timeout; } } } return opt; } // Returns a timeout failure, closed over a specified timeout value and error callback. function createTimeout (errorCallback, timeout) { var t = setTimeout(function () { clearTimeout(t); t = null; errorCallback({ code: PositionError.TIMEOUT, message: 'Position retrieval timed out.' }); }, timeout); return t; } var geolocation = { lastPosition: null, // reference to last known (cached) position returned /** * @function getCurrentPosition * @description * Asynchronously acquires the current position. * * @param {Function} successCallback The function to call when the position data is available * @param {Function} errorCallback The function to call when there is an error getting the heading position. (OPTIONAL) * @param {PositionOptions} options The options for getting the position data. (OPTIONAL) */ getCurrentPosition: function (successCallback, errorCallback, options) { argscheck.checkArgs('fFO', 'geolocation.getCurrentPosition', arguments); options = parseParameters(options); // Timer var that will fire an error callback if no position is retrieved from native // before the \"timeout\" param provided expires var timeoutTimer = {timer: null}; var win = function (p) { clearTimeout(timeoutTimer.timer); if (!(timeoutTimer.timer)) { // Timeout already happened, or native fired error callback for // this geo request. // Don't continue with success callback. return; } var pos = new Position( { latitude: p.latitude, longitude: p.longitude, altitude: p.altitude, accuracy: p.accuracy, heading: p.heading, velocity: p.velocity, altitudeAccuracy: p.altitudeAccuracy }, p.timestamp ); geolocation.lastPosition = pos; successCallback(pos); }; var fail = function (e) { clearTimeout(timeoutTimer.timer); timeoutTimer.timer = null; var err = new PositionError(e.code, e.message); if (errorCallback) { errorCallback(err); } }; // Check our cached position, if its timestamp difference with current time is less than the maximumAge, then just // fire the success callback with the cached position. if (geolocation.lastPosition &amp;&amp; options.maximumAge &amp;&amp; (((new Date()).getTime() - geolocation.lastPosition.timestamp) &lt;= options.maximumAge)) { successCallback(geolocation.lastPosition); // If the cached position check failed and the timeout was set to 0, error out with a TIMEOUT error object. } else if (options.timeout === 0) { fail({ code: PositionError.TIMEOUT, message: \"timeout value in PositionOptions set to 0 and no cached Position object available, or cached Position object's age exceeds provided PositionOptions' maximumAge parameter.\" }); // Otherwise we have to call into native to retrieve a position. } else { if (options.timeout !== Infinity) { // If the timeout value was not set to Infinity (default), then // set up a timeout function that will fire the error callback // if no successful position was retrieved before timeout expired. timeoutTimer.timer = createTimeout(fail, options.timeout); } else { // This is here so the check in the win function doesn't mess stuff up // may seem weird but this guarantees timeoutTimer is // always truthy before we call into native timeoutTimer.timer = true; } exec(win, fail, 'Geolocation', 'getLocation', [options.enableHighAccuracy, options.maximumAge]); } return timeoutTimer; }, /** * @function watchPosition * @description * Asynchronously watches the geolocation for changes to geolocation. When a change occurs, * the successCallback is called with the new location. * * @param {Function} successCallback The function to call each time the location data is available * @param {Function} errorCallback The function to call when there is an error getting the location data. (OPTIONAL) * @param {PositionOptions} options The options for getting the location data such as frequency. (OPTIONAL) * @return String The watch id that must be passed to #clearWatch to stop watching. */ watchPosition: function (successCallback, errorCallback, options) { argscheck.checkArgs('fFO', 'geolocation.getCurrentPosition', arguments); options = parseParameters(options); var id = utils.createUUID(); // Tell device to get a position ASAP, and also retrieve a reference to the timeout timer generated in getCurrentPosition timers[id] = geolocation.getCurrentPosition(successCallback, errorCallback, options); var fail = function (e) { clearTimeout(timers[id].timer); var err = new PositionError(e.code, e.message); if (errorCallback) { errorCallback(err); } }; var win = function (p) { clearTimeout(timers[id].timer); if (options.timeout !== Infinity) { timers[id].timer = createTimeout(fail, options.timeout); } var pos = new Position( { latitude: p.latitude, longitude: p.longitude, altitude: p.altitude, accuracy: p.accuracy, heading: p.heading, velocity: p.velocity, altitudeAccuracy: p.altitudeAccuracy }, p.timestamp ); geolocation.lastPosition = pos; successCallback(pos); }; exec(win, fail, 'Geolocation', 'addWatch', [id, options.enableHighAccuracy]); return id; }, /** * @function clearWatch * @description * Clears the specified heading watch. * * @param {String} id The ID of the watch returned from #watchPosition */ clearWatch: function (id) { if (id &amp;&amp; timers[id] !== undefined) { clearTimeout(timers[id].timer); timers[id].timer = false; exec(null, null, 'Geolocation', 'clearWatch', [id]); } } }; module.exports = geolocation; × Search results Close "},"cordova-plugin-inappbrowser_www_inappbrowser.js.html":{"id":"cordova-plugin-inappbrowser_www_inappbrowser.js.html","title":"Source: cordova-plugin-inappbrowser/www/inappbrowser.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: cordova-plugin-inappbrowser/www/inappbrowser.js /* * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. * */ (function () { // special patch to correctly work on Ripple emulator (CB-9760) if (window.parent &amp;&amp; !!window.parent.ripple) { // https://gist.github.com/triceam/4658021 module.exports = window.open.bind(window); // fallback to default window.open behaviour return; } var exec = require('cordova/exec'); var channel = require('cordova/channel'); var modulemapper = require('cordova/modulemapper'); var urlutil = require('cordova/urlutil'); function InAppBrowser () { this.channels = { 'beforeload': channel.create('beforeload'), 'loadstart': channel.create('loadstart'), 'loadstop': channel.create('loadstop'), 'loaderror': channel.create('loaderror'), 'exit': channel.create('exit'), 'customscheme': channel.create('customscheme'), 'message': channel.create('message') }; } InAppBrowser.prototype = { _eventHandler: function (event) { if (event &amp;&amp; (event.type in this.channels)) { if (event.type === 'beforeload') { this.channels[event.type].fire(event, this._loadAfterBeforeload); } else { this.channels[event.type].fire(event); } } }, _loadAfterBeforeload: function (strUrl) { strUrl = urlutil.makeAbsolute(strUrl); exec(null, null, 'InAppBrowser', 'loadAfterBeforeload', [strUrl]); }, close: function (eventname) { exec(null, null, 'InAppBrowser', 'close', []); }, show: function (eventname) { exec(null, null, 'InAppBrowser', 'show', []); }, hide: function (eventname) { exec(null, null, 'InAppBrowser', 'hide', []); }, addEventListener: function (eventname, f) { if (eventname in this.channels) { this.channels[eventname].subscribe(f); } }, removeEventListener: function (eventname, f) { if (eventname in this.channels) { this.channels[eventname].unsubscribe(f); } }, executeScript: function (injectDetails, cb) { if (injectDetails.code) { exec(cb, null, 'InAppBrowser', 'injectScriptCode', [injectDetails.code, !!cb]); } else if (injectDetails.file) { exec(cb, null, 'InAppBrowser', 'injectScriptFile', [injectDetails.file, !!cb]); } else { throw new Error('executeScript requires exactly one of code or file to be specified'); } }, insertCSS: function (injectDetails, cb) { if (injectDetails.code) { exec(cb, null, 'InAppBrowser', 'injectStyleCode', [injectDetails.code, !!cb]); } else if (injectDetails.file) { exec(cb, null, 'InAppBrowser', 'injectStyleFile', [injectDetails.file, !!cb]); } else { throw new Error('insertCSS requires exactly one of code or file to be specified'); } } }; /** * @exports InAppBrowser */ module.exports = function (strUrl, strWindowName, strWindowFeatures, callbacks) { // Don't catch calls that write to existing frames (e.g. named iframes). if (window.frames &amp;&amp; window.frames[strWindowName]) { var origOpenFunc = modulemapper.getOriginalSymbol(window, 'open'); return origOpenFunc.apply(window, arguments); } strUrl = urlutil.makeAbsolute(strUrl); var iab = new InAppBrowser(); callbacks = callbacks || {}; for (var callbackName in callbacks) { iab.addEventListener(callbackName, callbacks[callbackName]); } var cb = function (eventname) { iab._eventHandler(eventname); }; strWindowFeatures = strWindowFeatures || ''; exec(cb, cb, 'InAppBrowser', 'open', [strUrl, strWindowName, strWindowFeatures]); return iab; }; })(); × Search results Close "},"cordova-plugin-dialogs_www_notification.js.html":{"id":"cordova-plugin-dialogs_www_notification.js.html","title":"Source: cordova-plugin-dialogs/www/notification.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: cordova-plugin-dialogs/www/notification.js /* * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. * */ var exec = require('cordova/exec'); var platform = require('cordova/platform'); /** * Provides access to notifications on the device. */ /** * @exports Notification */ module.exports = { /** * Open a native alert dialog, with a customizable title and button text. * * @param {String} message Message to print in the body of the alert * @param {Function} completeCallback The callback that is called when user clicks on a button. * @param {String} title Title of the alert dialog (default: Alert) * @param {String} buttonLabel Label of the close button (default: OK) */ alert: function (message, completeCallback, title, buttonLabel) { var _message = (typeof message === 'string' ? message : JSON.stringify(message)); var _title = (typeof title === 'string' ? title : 'Alert'); var _buttonLabel = (buttonLabel &amp;&amp; typeof buttonLabel === 'string' ? buttonLabel : 'OK'); exec(completeCallback, null, 'Notification', 'alert', [_message, _title, _buttonLabel]); }, /** * Open a native confirm dialog, with a customizable title and button text. * The result that the user selects is returned to the result callback. * * @param {String} message Message to print in the body of the alert * @param {Function} resultCallback The callback that is called when user clicks on a button. * @param {String} title Title of the alert dialog (default: Confirm) * @param {Array} buttonLabels Array of the labels of the buttons (default: ['OK', 'Cancel']) */ confirm: function (message, resultCallback, title, buttonLabels) { var _message = (typeof message === 'string' ? message : JSON.stringify(message)); var _title = (typeof title === 'string' ? title : 'Confirm'); var _buttonLabels = (buttonLabels || ['OK', 'Cancel']); // Strings are deprecated! if (typeof _buttonLabels === 'string') { console.log('Notification.confirm(string, function, string, string) is deprecated. Use Notification.confirm(string, function, string, array).'); } _buttonLabels = convertButtonLabels(_buttonLabels); exec(resultCallback, null, 'Notification', 'confirm', [_message, _title, _buttonLabels]); }, /** * Open a native prompt dialog, with a customizable title and button text. * The following results are returned to the result callback: * buttonIndex Index number of the button selected. * input1 The text entered in the prompt dialog box. * * @param {String} message Dialog message to display (default: \"Prompt message\") * @param {Function} resultCallback The callback that is called when user clicks on a button. * @param {String} title Title of the dialog (default: \"Prompt\") * @param {Array} buttonLabels Array of strings for the button labels (default: [\"OK\",\"Cancel\"]) * @param {String} defaultText Textbox input value (default: empty string) */ prompt: function (message, resultCallback, title, buttonLabels, defaultText) { var _message = (typeof message === 'string' ? message : JSON.stringify(message)); var _title = (typeof title === 'string' ? title : 'Prompt'); var _buttonLabels = (buttonLabels || ['OK', 'Cancel']); // Strings are deprecated! if (typeof _buttonLabels === 'string') { console.log('Notification.prompt(string, function, string, string) is deprecated. Use Notification.confirm(string, function, string, array).'); } _buttonLabels = convertButtonLabels(_buttonLabels); var _defaultText = (defaultText || ''); exec(resultCallback, null, 'Notification', 'prompt', [_message, _title, _buttonLabels, _defaultText]); }, /** * Causes the device to beep. * On Android, the default notification ringtone is played \"count\" times. * * @param {Integer} count The number of beeps. */ beep: function (count) { var defaultedCount = count || 1; exec(null, null, 'Notification', 'beep', [ defaultedCount ]); } }; function convertButtonLabels (buttonLabels) { // Some platforms take an array of button label names. // Other platforms take a comma separated list. // For compatibility, we convert to the desired type based on the platform. if (platform.id === 'amazon-fireos' || platform.id === 'android' || platform.id === 'ios' || platform.id === 'windowsphone' || platform.id === 'firefoxos' || platform.id === 'ubuntu' || platform.id === 'windows8' || platform.id === 'windows') { if (typeof buttonLabels === 'string') { buttonLabels = buttonLabels.split(','); // not crazy about changing the var type here } } else { if (Array.isArray(buttonLabels)) { var buttonLabelArray = buttonLabels; buttonLabels = buttonLabelArray.toString(); } } return buttonLabels; } × Search results Close "},"cordova-plugin-geolocation_www_Position.js.html":{"id":"cordova-plugin-geolocation_www_Position.js.html","title":"Source: cordova-plugin-geolocation/www/Position.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: cordova-plugin-geolocation/www/Position.js /* * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. * */ /** * @exports Position */ var Coordinates = require('./Coordinates'); var Position = function (coords, timestamp) { if (coords) { this.coords = new Coordinates(coords.latitude, coords.longitude, coords.altitude, coords.accuracy, coords.heading, coords.velocity, coords.altitudeAccuracy); } else { this.coords = new Coordinates(); } this.timestamp = (timestamp !== undefined) ? timestamp : new Date().getTime(); }; module.exports = Position; × Search results Close "},"cordova-plugin-screen-orientation_www_screenorientation.js.html":{"id":"cordova-plugin-screen-orientation_www_screenorientation.js.html","title":"Source: cordova-plugin-screen-orientation/www/screenorientation.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: cordova-plugin-screen-orientation/www/screenorientation.js /* * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. * */ var screenOrientation = {}; if (!window.OrientationType) { window.OrientationType = { 'portrait-primary': 0, 'portrait-secondary': 180, 'landscape-primary': 90, 'landscape-secondary': -90 }; } if (!window.OrientationLockType) { window.OrientationLockType = { 'portrait-primary': 1, 'portrait-secondary': 2, 'landscape-primary': 4, 'landscape-secondary': 8, 'portrait': 3, // either portrait-primary or portrait-secondary. 'landscape': 12, // either landscape-primary or landscape-secondary. 'any': 15 // All orientations are supported (unlocked orientation) }; } var orientationMask = 1; screenOrientation.setOrientation = function(orientation) { orientationMask = window.OrientationLockType[orientation]; cordova.exec(null, null, \"CDVOrientation\", \"screenOrientation\", [orientationMask, orientation]); }; if (!screen.orientation) { screen.orientation = {}; } setOrientationProperties(); function addScreenOrientationApi(screenObject) { if (screenObject.unlock || screenObject.lock) { screenObject.nativeLock = screenObject.lock; } screenObject.lock = function(orientation) { var promiseLock; var p = new Promise(function(resolve, reject) { if (screenObject.nativeLock) { promiseLock = screenObject.nativeLock(orientation); promiseLock.then(function success(res) { resolve(); }, function error(err) { screenObject.nativeLock = null; resolveOrientation(orientation, resolve, reject); }); } else { resolveOrientation(orientation, resolve, reject); } }); return p; }; screenObject.unlock = function() { screenOrientation.setOrientation('any'); }; } function resolveOrientation(orientation, resolve, reject) { if (!OrientationLockType.hasOwnProperty(orientation)) { var err = new Error(); err.name = \"NotSupportedError\"; reject(err); //\"cannot change orientation\"); } else { screenOrientation.setOrientation(orientation); resolve(\"Orientation set\"); // orientation change successful } } addScreenOrientationApi(screen.orientation); var onChangeListener = null; Object.defineProperty(screen.orientation, 'onchange', { set: function(listener) { if (onChangeListener) { screen.orientation.removeEventListener('change', onChangeListener); } onChangeListener = listener; if (onChangeListener) { screen.orientation.addEventListener('change', onChangeListener); } }, get: function() { return (onChangeListener ? onChangeListener : null); }, enumerable: true, }); var evtTarget = new XMLHttpRequest(); //document.createElement('div'); var orientationchange = function() { setOrientationProperties(); var event = document.createEvent('Events'); event.initEvent(\"change\", false, false); evtTarget.dispatchEvent(event); }; screen.orientation.addEventListener = function(a,b,c) { return evtTarget.addEventListener(a,b,c); }; screen.orientation.removeEventListener = function(a,b,c) { return evtTarget.removeEventListener(a,b,c); }; function setOrientationProperties() { switch (window.orientation) { case 0: screen.orientation.type = 'portrait-primary'; break; case 90: screen.orientation.type = 'landscape-primary'; break; case 180: screen.orientation.type = 'portrait-secondary'; break; case -90: screen.orientation.type = 'landscape-secondary'; break; default: screen.orientation.type = 'portrait-primary'; break; } screen.orientation.angle = window.orientation || 0; } window.addEventListener(\"orientationchange\", orientationchange, true); /** * @exports ScreenOrientation */ module.exports = screenOrientation; × Search results Close "},"cordova-plugin-splashscreen_www_splashscreen.js.html":{"id":"cordova-plugin-splashscreen_www_splashscreen.js.html","title":"Source: cordova-plugin-splashscreen/www/splashscreen.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: cordova-plugin-splashscreen/www/splashscreen.js /* * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. * */ var exec = require('cordova/exec'); var splashscreen = { show:function() { exec(null, null, \"SplashScreen\", \"show\", []); }, hide:function() { exec(null, null, \"SplashScreen\", \"hide\", []); } }; /** * @exports Splashscreen * @example * navigator.splashscreen.hide(); * or * navigator.splashscreen.show(); */ module.exports = splashscreen; × Search results Close "},"cordova-plugin-statusbar_www_statusbar.js.html":{"id":"cordova-plugin-statusbar_www_statusbar.js.html","title":"Source: cordova-plugin-statusbar/www/statusbar.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: cordova-plugin-statusbar/www/statusbar.js /* * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. * */ /* global cordova */ var exec = require('cordova/exec'); /** * StatusBar.NameColors * @enum {string} */ var namedColors = { \"black\": \"#000000\", \"darkGray\": \"#A9A9A9\", \"lightGray\": \"#D3D3D3\", \"white\": \"#FFFFFF\", \"gray\": \"#808080\", \"red\": \"#FF0000\", \"green\": \"#00FF00\", \"blue\": \"#0000FF\", \"cyan\": \"#00FFFF\", \"yellow\": \"#FFFF00\", \"magenta\": \"#FF00FF\", \"orange\": \"#FFA500\", \"purple\": \"#800080\", \"brown\": \"#A52A2A\" }; /** * @exports StatusBar */ var StatusBar = { /** @property {boolean} isVisible*/ isVisible: true, /** * @function * @param {boolean} doOverlay */ overlaysWebView: function (doOverlay) { exec(null, null, \"StatusBar\", \"overlaysWebView\", [doOverlay]); }, /** @function */ styleDefault: function () { // dark text ( to be used on a light background ) exec(null, null, \"StatusBar\", \"styleDefault\", []); }, /** @function */ styleLightContent: function () { // light text ( to be used on a dark background ) exec(null, null, \"StatusBar\", \"styleLightContent\", []); }, /** @function */ styleBlackTranslucent: function () { // #88000000 ? Apple says to use lightContent instead exec(null, null, \"StatusBar\", \"styleBlackTranslucent\", []); }, /** @function */ styleBlackOpaque: function () { // #FF000000 ? Apple says to use lightContent instead exec(null, null, \"StatusBar\", \"styleBlackOpaque\", []); }, /** * @function * @param {boolean} colorname */ backgroundColorByName: function (colorname) { return StatusBar.backgroundColorByHexString(namedColors[colorname]); }, /** * @function * @param {boolean} hexString */ backgroundColorByHexString: function (hexString) { if (hexString.charAt(0) !== \"#\") { hexString = \"#\" + hexString; } if (hexString.length === 4) { var split = hexString.split(\"\"); hexString = \"#\" + split[1] + split[1] + split[2] + split[2] + split[3] + split[3]; } exec(null, null, \"StatusBar\", \"backgroundColorByHexString\", [hexString]); }, /** @function */ hide: function () { exec(null, null, \"StatusBar\", \"hide\", []); StatusBar.isVisible = false; }, /** @function */ show: function () { exec(null, null, \"StatusBar\", \"show\", []); StatusBar.isVisible = true; } }; // prime it. setTimeout so that proxy gets time to init window.setTimeout(function () { exec(function (res) { if (typeof res == 'object') { if (res.type == 'tap') { cordova.fireWindowEvent('statusTap'); } } else { StatusBar.isVisible = res; } }, null, \"StatusBar\", \"_ready\", []); }, 0); module.exports = StatusBar; × Search results Close "},"cordova-plugin-vibration_www_vibration.js.html":{"id":"cordova-plugin-vibration_www_vibration.js.html","title":"Source: cordova-plugin-vibration/www/vibration.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: cordova-plugin-vibration/www/vibration.js /* * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. * */ var exec = require('cordova/exec'); /** * Provides access to the vibration mechanism on the device. */ /** * @exports Vibration */ module.exports = { /** * Vibrates the device for a given amount of time or for a given pattern or immediately cancels any ongoing vibrations (depending on the parameter). * * @param {Integer} param The number of milliseconds to vibrate (if 0, cancels vibration) * * * @param {number[]} param Pattern with which to vibrate the device. * Pass in an array of integers that * are the durations for which to * turn on or off the vibrator in * milliseconds. The FIRST value * indicates the * number of milliseconds for which * to keep the vibrator ON before * turning it off. The NEXT value indicates the * number of milliseconds for which * to keep the vibrator OFF before * turning it on. Subsequent values * alternate between durations in * milliseconds to turn the vibrator * off or to turn the vibrator on. * (if empty, cancels vibration) */ vibrate: function (param) { /* Aligning with w3c spec */ // vibrate if ((typeof param === 'number') &amp;&amp; param !== 0) { exec(null, null, 'Vibration', 'vibrate', [param]); // vibrate with array ( i.e. vibrate([3000]) ) } else if ((typeof param === 'object') &amp;&amp; param.length === 1) { // cancel if vibrate([0]) if (param[0] === 0) { exec(null, null, 'Vibration', 'cancelVibration', []); // else vibrate } else { exec(null, null, 'Vibration', 'vibrate', [param[0]]); } // vibrate with a pattern } else if ((typeof param === 'object') &amp;&amp; param.length &gt; 1) { var repeat = -1; // no repeat exec(null, null, 'Vibration', 'vibrateWithPattern', [param, repeat]); // cancel vibration (param = 0 or []) } else { exec(null, null, 'Vibration', 'cancelVibration', []); } return true; } }; × Search results Close "},"cordova-plugin-geolocation_www_PositionError.js.html":{"id":"cordova-plugin-geolocation_www_PositionError.js.html","title":"Source: cordova-plugin-geolocation/www/PositionError.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: cordova-plugin-geolocation/www/PositionError.js /* * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. * */ /** * Position error object * * @constructor * @param code * @param message */ var PositionError = function (code, message) { this.code = code || null; this.message = message || ''; }; PositionError.prototype.PERMISSION_DENIED = PositionError.PERMISSION_DENIED = 1; PositionError.prototype.POSITION_UNAVAILABLE = PositionError.POSITION_UNAVAILABLE = 2; PositionError.prototype.TIMEOUT = PositionError.TIMEOUT = 3; module.exports = PositionError; × Search results Close "},"cordova-plugin-file_www_resolveLocalFileSystemURI.js.html":{"id":"cordova-plugin-file_www_resolveLocalFileSystemURI.js.html","title":"Source: cordova-plugin-file/www/resolveLocalFileSystemURI.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: cordova-plugin-file/www/resolveLocalFileSystemURI.js /* * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. * */ (function () { // For browser platform: not all browsers use overrided `resolveLocalFileSystemURL`. function checkBrowser () { if (cordova.platformId === 'browser' &amp;&amp; require('./isChrome')()) { // eslint-disable-line no-undef module.exports.resolveLocalFileSystemURL = window.resolveLocalFileSystemURL || window.webkitResolveLocalFileSystemURL; return true; } return false; } if (checkBrowser()) { return; } var argscheck = require('cordova/argscheck'); var DirectoryEntry = require('./DirectoryEntry'); var FileEntry = require('./FileEntry'); var FileError = require('./FileError'); var exec = require('cordova/exec'); var fileSystems = require('./fileSystems'); /** * Look up file system Entry referred to by local URI. * @param {DOMString} uri URI referring to a local file or directory * @param successCallback invoked with Entry object corresponding to URI * @param errorCallback invoked if error occurs retrieving file system entry */ module.exports.resolveLocalFileSystemURL = module.exports.resolveLocalFileSystemURL || function (uri, successCallback, errorCallback) { argscheck.checkArgs('sFF', 'resolveLocalFileSystemURI', arguments); // error callback var fail = function (error) { if (errorCallback) { errorCallback(new FileError(error)); } }; // sanity check for 'not:valid:filename' or '/not:valid:filename' // file.spec.12 window.resolveLocalFileSystemURI should error (ENCODING_ERR) when resolving invalid URI with leading /. if (!uri || uri.split(':').length &gt; 2) { setTimeout(function () { fail(FileError.ENCODING_ERR); }, 0); return; } // if successful, return either a file or directory entry var success = function (entry) { if (entry) { if (successCallback) { // create appropriate Entry object var fsName = entry.filesystemName || (entry.filesystem &amp;&amp; entry.filesystem.name) || (entry.filesystem === window.PERSISTENT ? 'persistent' : 'temporary'); // eslint-disable-line no-undef fileSystems.getFs(fsName, function (fs) { // This should happen only on platforms that haven't implemented requestAllFileSystems (windows) if (!fs) { fs = new FileSystem(fsName, {name: '', fullPath: '/'}); // eslint-disable-line no-undef } var result = (entry.isDirectory) ? new DirectoryEntry(entry.name, entry.fullPath, fs, entry.nativeURL) : new FileEntry(entry.name, entry.fullPath, fs, entry.nativeURL); successCallback(result); }); } } else { // no Entry object returned fail(FileError.NOT_FOUND_ERR); } }; exec(success, fail, 'File', 'resolveLocalFileSystemURI', [uri]); }; module.exports.resolveLocalFileSystemURI = function () { console.log('resolveLocalFileSystemURI is deprecated. Please call resolveLocalFileSystemURL instead.'); module.exports.resolveLocalFileSystemURL.apply(this, arguments); }; })(); × Search results Close "},"elastos-trinity-plugins-qrscanner_node_modules_webrtc-adapter_src_js_utils.js.html":{"id":"elastos-trinity-plugins-qrscanner_node_modules_webrtc-adapter_src_js_utils.js.html","title":"Source: elastos-trinity-plugins-qrscanner/node_modules/webrtc-adapter/src/js/utils.js","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Source: elastos-trinity-plugins-qrscanner/node_modules/webrtc-adapter/src/js/utils.js /* * Copyright (c) 2016 The WebRTC project authors. All Rights Reserved. * * Use of this source code is governed by a BSD-style license * that can be found in the LICENSE file in the root of the source * tree. */ /* eslint-env node */ 'use strict'; var logDisabled_ = true; // Utility methods. var utils = { disableLog: function(bool) { if (typeof bool !== 'boolean') { return new Error('Argument type: ' + typeof bool + '. Please use a boolean.'); } logDisabled_ = bool; return (bool) ? 'adapter.js logging disabled' : 'adapter.js logging enabled'; }, log: function() { if (typeof window === 'object') { if (logDisabled_) { return; } if (typeof console !== 'undefined' &amp;&amp; typeof console.log === 'function') { console.log.apply(console, arguments); } } }, /** * Extract browser version out of the provided user agent string. * * @param {!string} uastring userAgent string. * @param {!string} expr Regular expression used as match criteria. * @param {!number} pos position in the version string to be returned. * @return {!number} browser version. */ extractVersion: function(uastring, expr, pos) { var match = uastring.match(expr); return match &amp;&amp; match.length &gt;= pos &amp;&amp; parseInt(match[pos], 10); }, /** * Browser detector. * * @return {object} result containing browser and version * properties. */ detectBrowser: function() { // Returned result object. var result = {}; result.browser = null; result.version = null; // Fail early if it's not a browser if (typeof window === 'undefined' || !window.navigator) { result.browser = 'Not a browser.'; return result; } // Firefox. if (navigator.mozGetUserMedia) { result.browser = 'firefox'; result.version = this.extractVersion(navigator.userAgent, /Firefox\\/(\\d+)\\./, 1); } else if (navigator.webkitGetUserMedia) { // Chrome, Chromium, Webview, Opera, all use the chrome shim for now if (window.webkitRTCPeerConnection) { result.browser = 'chrome'; result.version = this.extractVersion(navigator.userAgent, /Chrom(e|ium)\\/(\\d+)\\./, 2); } else { // Safari (in an unpublished version) or unknown webkit-based. if (navigator.userAgent.match(/Version\\/(\\d+).(\\d+)/)) { result.browser = 'safari'; result.version = this.extractVersion(navigator.userAgent, /AppleWebKit\\/(\\d+)\\./, 1); } else { // unknown webkit-based browser. result.browser = 'Unsupported webkit-based browser ' + 'with GUM support but no WebRTC support.'; return result; } } } else if (navigator.mediaDevices &amp;&amp; navigator.userAgent.match(/Edge\\/(\\d+).(\\d+)$/)) { // Edge. result.browser = 'edge'; result.version = this.extractVersion(navigator.userAgent, /Edge\\/(\\d+).(\\d+)$/, 2); } else if (navigator.mediaDevices &amp;&amp; navigator.userAgent.match(/AppleWebKit\\/(\\d+)\\./)) { // Safari, with webkitGetUserMedia removed. result.browser = 'safari'; result.version = this.extractVersion(navigator.userAgent, /AppleWebKit\\/(\\d+)\\./, 1); } else { // Default fallthrough: not supported. result.browser = 'Not a supported browser.'; return result; } return result; }, // shimCreateObjectURL must be called before shimSourceObject to avoid loop. shimCreateObjectURL: function() { if (!(typeof window === 'object' &amp;&amp; window.HTMLMediaElement &amp;&amp; 'srcObject' in window.HTMLMediaElement.prototype)) { // Only shim CreateObjectURL using srcObject if srcObject exists. return undefined; } var nativeCreateObjectURL = URL.createObjectURL.bind(URL); var nativeRevokeObjectURL = URL.revokeObjectURL.bind(URL); var streams = new Map(), newId = 0; URL.createObjectURL = function(stream) { if ('getTracks' in stream) { var url = 'polyblob:' + (++newId); streams.set(url, stream); console.log('URL.createObjectURL(stream) is deprecated! ' + 'Use elem.srcObject = stream instead!'); return url; } return nativeCreateObjectURL(stream); }; URL.revokeObjectURL = function(url) { nativeRevokeObjectURL(url); streams.delete(url); }; var dsc = Object.getOwnPropertyDescriptor(window.HTMLMediaElement.prototype, 'src'); Object.defineProperty(window.HTMLMediaElement.prototype, 'src', { get: function() { return dsc.get.apply(this); }, set: function(url) { this.srcObject = streams.get(url) || null; return dsc.set.apply(this, [url]); } }); var nativeSetAttribute = HTMLMediaElement.prototype.setAttribute; HTMLMediaElement.prototype.setAttribute = function() { if (arguments.length === 2 &amp;&amp; ('' + arguments[0]).toLowerCase() === 'src') { this.srcObject = streams.get(arguments[1]) || null; } return nativeSetAttribute.apply(this, arguments); }; } }; // Export. module.exports = { log: utils.log, disableLog: utils.disableLog, browserDetails: utils.detectBrowser(), extractVersion: utils.extractVersion, shimCreateObjectURL: utils.shimCreateObjectURL, detectBrowser: utils.detectBrowser.bind(utils) }; × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Global Members cordova Creates the exec bridge used to notify the native code of commands. Source: elastos-trinity-plugins-ionicwebview/src/www/ios/ios-wkwebview-exec.js, line 26 namedColors :string StatusBar.NameColors Type: string Properties: Name Type Default Description black string #000000 darkGray string #A9A9A9 lightGray string #D3D3D3 white string #FFFFFF gray string #808080 red string #FF0000 green string #00FF00 blue string #0000FF cyan string #00FFFF yellow string #FFFF00 magenta string #FF00FF orange string #FFA500 purple string #800080 brown string #A52A2A Source: cordova-plugin-statusbar/www/statusbar.js, line 30 resolveLocalFileSystemURL Look up file system Entry referred to by local URI. Source: cordova-plugin-file/www/resolveLocalFileSystemURI.js, line 47 Methods CaptureAudioOptions() Encapsulates all audio capture operation configuration options. Source: cordova-plugin-media-capture/www/CaptureAudioOptions.js, line 25 CaptureError() The CaptureError interface encapsulates all errors in the Capture API. Source: cordova-plugin-media-capture/www/CaptureError.js, line 25 CaptureImageOptions() Encapsulates all image capture operation configuration options. Source: cordova-plugin-media-capture/www/CaptureImageOptions.js, line 25 CaptureVideoOptions() Encapsulates all video capture operation configuration options. Source: cordova-plugin-media-capture/www/CaptureVideoOptions.js, line 25 ConfigurationData() Encapsulates a set of parameters that the capture device supports. Source: cordova-plugin-media-capture/www/ConfigurationData.js, line 25 DirectoryEntry() An interface representing a directory on the file system. {boolean} isFile always false (readonly) {boolean} isDirectory always true (readonly) {DOMString} name of the directory, excluding the path leading to it (readonly) {DOMString} fullPath the absolute full path to the directory (readonly) {FileSystem} filesystem on which the directory resides (readonly) Source: cordova-plugin-file/www/DirectoryEntry.js, line 38 DirectoryReader() An interface that lists the files and directories in a directory. Source: cordova-plugin-file/www/DirectoryReader.js, line 28 Entry(isFile, isDirectory, name, fullPath, fileSystem, nativeURL) Represents a file or directory on the local file system. Parameters: Name Type Description isFile boolean true if Entry is a file (readonly) isDirectory boolean true if Entry is a directory (readonly) name DOMString name of the file or directory, excluding the path leading to it (readonly) fullPath DOMString the absolute full path to the file or directory (readonly) fileSystem FileSystem the filesystem on which this entry resides (readonly) nativeURL DOMString an alternate URL which can be used by native webview controls, for example media players. (optional, readonly) Source: cordova-plugin-file/www/Entry.js, line 48 File() Constructor. name {DOMString} name of the file, without path information fullPath {DOMString} the full path of the file, including the name type {DOMString} mime type lastModifiedDate {Date} last modified date size {Number} size of the file in bytes Source: cordova-plugin-file/www/File.js, line 31 FileEntry() An interface representing a file on the file system. {boolean} isFile always true (readonly) {boolean} isDirectory always false (readonly) {DOMString} name of the file, excluding the path leading to it (readonly) {DOMString} fullPath the absolute full path to the file (readonly) {FileSystem} filesystem on which the file resides (readonly) Source: cordova-plugin-file/www/FileEntry.js, line 38 FileError() FileError Source: cordova-plugin-file/www/FileError.js, line 25 Flags(create, exclusive) Supplies arguments to methods that lookup or create files and directories. Parameters: Name Type Description create boolean file or directory if it doesn't exist exclusive boolean used with create; if true the command will fail if target path exists Source: cordova-plugin-file/www/Flags.js, line 31 MediaFile() Represents a single file. name {DOMString} name of the file, without path information fullPath {DOMString} the full path of the file, including the name type {DOMString} mime type lastModifiedDate {Date} last modified date size {Number} size of the file in bytes Source: cordova-plugin-media-capture/www/MediaFile.js, line 35 MediaFileData(codecs, bitrate, height, width, duration) MediaFileData encapsulates format information of a media file. Parameters: Name Type Description codecs DOMString bitrate long height long width long duration float Source: cordova-plugin-media-capture/www/MediaFileData.js, line 31 Metadata() Information about the state of the file or directory {Date} modificationTime (readonly) Source: cordova-plugin-file/www/Metadata.js, line 27 readFailureCallback() Callback used by the following read* functions to handle errors. Must be bound to the FileReader's this, e.g. readFailureCallback.bind(this) Source: cordova-plugin-file/www/FileReader.js, line 172 readSuccessCallback(readType, encoding, offset, totalSize, accumulate, r) Callback used by the following read* functions to handle incremental or final success. Must be bound to the FileReader's this along with all but the last parameter, e.g. readSuccessCallback.bind(this, \"readAsText\", \"UTF-8\", offset, totalSize, accumulate) Parameters: Name Type Description readType The name of the read function to call. encoding Text encoding, or null if this is not a text type read. offset Starting offset of the read. totalSize Total number of bytes or chars to read. accumulate A function that takes the callback result and accumulates it in this._result. r Callback result returned by the last read exec() call, or null to begin reading. Source: cordova-plugin-file/www/FileReader.js, line 119 × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Modules Classes Battery Clipboard Coordinates Device FileReader FileSystem FileUploadOptions FileUploadResult FileWriter Media AppManager AppService Carrier Session Stream PositionError × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Classes Classes Battery Clipboard Coordinates Device FileReader FileSystem FileUploadOptions FileUploadResult FileWriter Media AppManager AppService Carrier Session Stream PositionError × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Introduction Welcome to the Elastos Browser (Trinity) plugins documentation. Plugin types Trinity plugins are used by DApps that run inside Trinity. There 2 kinds of plugins: Standard cordova plugins (device info, accelerometer, camera ...) Elastos ecosystem plugins (hive, carrier, did, wallet, ethereum ...) Developer guides For a quick start developing Elastos browser applications, please take a look at the developer website. This is where you can start learning how to setup the native Elastos browser app, installed development tools, or create and deploy DApps. × Search results Close "},"Battery.html":{"id":"Battery.html","title":"Class: Battery","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Class: Battery Battery new Battery() This class contains information about the current battery status. Source: cordova-plugin-battery-status/www/battery.js, line 33 Methods &lt;static&gt; onHasSubscribersChange() Event handlers for when callbacks get registered for the battery. Keep track of how many handlers we have so we can start and stop the native battery listener appropriately (and hopefully save on battery life!). Source: cordova-plugin-battery-status/www/battery.js, line 58 _error() Error callback for battery start Source: cordova-plugin-battery-status/www/battery.js, line 104 _status(info) Callback for battery status Parameters: Name Type Description info Object keys: level, isPlugged Source: cordova-plugin-battery-status/www/battery.js, line 72 × Search results Close "},"Clipboard.html":{"id":"Clipboard.html","title":"Class: Clipboard","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Class: Clipboard Clipboard new Clipboard() Clipboard plugin for Cordova Source: cordova-clipboard/www/clipboard.js, line 8 Methods clear(onSuccess, onFail) Clear the clipboard content Parameters: Name Type Description onSuccess function The function to call in case of success onFail function The function to call in case of error Source: cordova-clipboard/www/clipboard.js, line 38 copy(text, onSuccess, onFail) Sets the clipboard content Parameters: Name Type Description text String The content to copy to the clipboard onSuccess function The function to call in case of success (takes the copied text as argument) onFail function The function to call in case of error Source: cordova-clipboard/www/clipboard.js, line 17 paste(onSuccess, onFail) Gets the clipboard content Parameters: Name Type Description onSuccess function The function to call in case of success onFail function The function to call in case of error Source: cordova-clipboard/www/clipboard.js, line 28 × Search results Close "},"Coordinates.html":{"id":"Coordinates.html","title":"Class: Coordinates","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Class: Coordinates Coordinates new Coordinates(lat, lng, alt, acc, head, vel, altacc) This class contains position information. Parameters: Name Type Description lat Object lng Object alt Object acc Object head Object vel Object altacc Object Source: cordova-plugin-geolocation/www/Coordinates.js, line 33 Members accuracy The accuracy of the position. Source: cordova-plugin-geolocation/www/Coordinates.js, line 45 altitude The altitude of the position. Source: cordova-plugin-geolocation/www/Coordinates.js, line 49 altitudeAccuracy The altitude accuracy of the position. Source: cordova-plugin-geolocation/www/Coordinates.js, line 66 heading The direction the device is moving at the position. Source: cordova-plugin-geolocation/www/Coordinates.js, line 53 latitude The latitude of the position. Source: cordova-plugin-geolocation/www/Coordinates.js, line 37 longitude The longitude of the position, Source: cordova-plugin-geolocation/www/Coordinates.js, line 41 speed The velocity with which the device is moving at the position. Source: cordova-plugin-geolocation/www/Coordinates.js, line 57 × Search results Close "},"Device.html":{"id":"Device.html","title":"Class: Device","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Class: Device Device new Device() This represents the mobile device, and provides properties for inspecting the model, version, UUID of the phone, etc. Properties: Name Type Description cordova boolean Get the version of Cordova running on the device. model string The device.model returns the name of the device's model or product. platform string Get the device's operating system name. uuid string Get the device's Universally Unique Identifier. version string Get the operating system version. manufacturer string Get the device's manufacturer. isVirtual boolean whether the device is running on a simulator. serial string Get the device hardware serial number. Source: cordova-plugin-device/www/device.js, line 45 Methods getInfo(successCallback, errorCallback) Get device info Parameters: Name Type Description successCallback function The function to call when the heading data is available errorCallback function The function to call when there is an error getting the heading data. (OPTIONAL) Source: cordova-plugin-device/www/device.js, line 86 × Search results Close "},"FileReader.html":{"id":"FileReader.html","title":"Class: FileReader","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Class: FileReader FileReader new FileReader() This class reads the mobile device file system. For Android: The root directory is the root of the file system. To read from the SD card, the file name is \"sdcard/my_file.txt\" Source: cordova-plugin-file/www/FileReader.js, line 37 Members &lt;static&gt; READ_CHUNK_SIZE Defines the maximum size to read at a time via the native API. The default value is a compromise between minimizing the overhead of many exec() calls while still reporting progress frequently enough for large files. (Note attempts to allocate more than a few MB of contiguous memory on the native side are likely to cause OOM exceptions, while the JS engine seems to have fewer problems managing large strings or ArrayBuffers.) Source: cordova-plugin-file/www/FileReader.js, line 52 Methods abort() Abort reading file. Source: cordova-plugin-file/www/FileReader.js, line 193 readAsArrayBuffer(file) Read file and return data as a binary data. Parameters: Name Type Description file File File object containing file properties Source: cordova-plugin-file/www/FileReader.js, line 285 readAsBinaryString(file) Read file and return data as a binary data. Parameters: Name Type Description file File File object containing file properties Source: cordova-plugin-file/www/FileReader.js, line 266 readAsDataURL(file) Read file and return data as a base64 encoded data url. A data url is of the form: data:[][;base64], Parameters: Name Type Description file File File object containing file properties Source: cordova-plugin-file/www/FileReader.js, line 245 readAsText(file, encoding) Read text file. Parameters: Name Type Description file File File object containing file properties encoding [Optional] (see http://www.iana.org/assignments/character-sets) Source: cordova-plugin-file/www/FileReader.js, line 221 × Search results Close "},"FileSystem.html":{"id":"FileSystem.html","title":"Class: FileSystem","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Class: FileSystem FileSystem new FileSystem() An interface representing a file system {DOMString} name the unique name of the file system (readonly) {DirectoryEntry} root directory of the file system (readonly) Source: cordova-plugin-file/www/FileSystem.js, line 31 × Search results Close "},"FileUploadOptions.html":{"id":"FileUploadOptions.html","title":"Class: FileUploadOptions","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Class: FileUploadOptions FileUploadOptions new FileUploadOptions(fileKey, fileName, mimeType, params, headers) Options to customize the HTTP request used to upload files. Parameters: Name Type Description fileKey String Name of file request parameter. fileName String Filename to be used by the server. Defaults to image.jpg. mimeType String Mimetype of the uploaded file. Defaults to image/jpeg. params Object Object with key: value params to send to the server. headers Object Keys are header names, values are header values. Multiple headers of the same name are not supported. Source: cordova-plugin-file/www/FileUploadOptions.js, line 32 × Search results Close "},"FileUploadResult.html":{"id":"FileUploadResult.html","title":"Class: FileUploadResult","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Class: FileUploadResult FileUploadResult new FileUploadResult() FileUploadResult Source: cordova-plugin-file/www/FileUploadResult.js, line 26 × Search results Close "},"FileWriter.html":{"id":"FileWriter.html","title":"Class: FileWriter","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Class: FileWriter FileWriter new FileWriter(file, append) This class writes to the mobile device file system. For Android: The root directory is the root of the file system. To write to the SD card, the file name is \"sdcard/my_file.txt\" Parameters: Name Type Description file File File object containing file properties append if true write to the end of the file, otherwise overwrite the file Source: cordova-plugin-file/www/FileWriter.js, line 38 Methods abort() Abort writing file. Source: cordova-plugin-file/www/FileWriter.js, line 72 seek(offset) Moves the file pointer to the location specified. If the offset is a negative number the position of the file pointer is rewound. If the offset is greater than the file size the position is set to the end of the file. Parameters: Name Type Description offset is the location to move the file pointer to. Source: cordova-plugin-file/www/FileWriter.js, line 229 truncate(size) Truncates the file to the size specified. Parameters: Name Type Description size to chop the file at. Source: cordova-plugin-file/www/FileWriter.js, line 258 write(data, isPendingBlobReadResult) Writes data to the file Parameters: Name Type Description data text or blob to be written isPendingBlobReadResult Boolean true if the data is the pending blob read operation result Source: cordova-plugin-file/www/FileWriter.js, line 100 × Search results Close "},"Media.html":{"id":"Media.html","title":"Class: Media","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Class: Media Media new Media(src, successCallback, errorCallback, statusCallback) This class provides access to the device media, interfaces to both sound and video Parameters: Name Type Description src The file name or url to play successCallback The callback to be called when the file is done playing or recording. successCallback() errorCallback The callback to be called if there is an error. errorCallback(int errorCode) - OPTIONAL statusCallback The callback to be called when media status has changed. statusCallback(int statusCode) - OPTIONAL Source: elastos-trinity-plugins-media/www/Media.js, line 40 Methods &lt;static&gt; onStatus(id, msgType, value) Audio has status update. PRIVATE Parameters: Name Type Description id The media object id (string) msgType The 'type' of update this is value Use of value is determined by the msgType Source: elastos-trinity-plugins-media/www/Media.js, line 197 getCurrentAmplitude() Get amplitude of audio. Source: elastos-trinity-plugins-media/www/Media.js, line 183 getCurrentPosition() Get position of audio. Source: elastos-trinity-plugins-media/www/Media.js, line 119 getDuration() Get duration of an audio file. The duration is only set for audio that is playing, paused or stopped. Source: elastos-trinity-plugins-media/www/Media.js, line 112 Returns: duration or -1 if not known. pause() Pause playing audio file. Source: elastos-trinity-plugins-media/www/Media.js, line 102 pauseRecord() Pause recording audio file. Source: elastos-trinity-plugins-media/www/Media.js, line 144 play() Start or resume playing audio file. Source: elastos-trinity-plugins-media/www/Media.js, line 75 release() Release the resources. Source: elastos-trinity-plugins-media/www/Media.js, line 158 resumeRecord() Resume recording audio file. Source: elastos-trinity-plugins-media/www/Media.js, line 151 seekTo() Seek or jump to a new time in the track.. Source: elastos-trinity-plugins-media/www/Media.js, line 92 setRate() Adjust the playback rate. Source: elastos-trinity-plugins-media/www/Media.js, line 172 setVolume() Adjust the volume. Source: elastos-trinity-plugins-media/www/Media.js, line 165 startRecord() Start recording audio file. Source: elastos-trinity-plugins-media/www/Media.js, line 130 stop() Stop playing audio file. Source: elastos-trinity-plugins-media/www/Media.js, line 82 stopRecord() Stop recording audio file. Source: elastos-trinity-plugins-media/www/Media.js, line 137 × Search results Close "},"module-Acceleration.html":{"id":"module-Acceleration.html","title":"Module: Acceleration","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Module: Acceleration Source: cordova-plugin-device-motion/www/Acceleration.js, line 26 × Search results Close "},"module-Accelerometer.html":{"id":"module-Accelerometer.html","title":"Module: Accelerometer","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Module: Accelerometer Source: cordova-plugin-device-motion/www/accelerometer.js, line 30 × Search results Close "},"module-AppManager.html":{"id":"module-AppManager.html","title":"Module: AppManager","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Module: AppManager Source: elastos-trinity-plugins-appmanager/www/AppManager.js, line 26 Classes AppManager Type Definitions AppInfo The App information. Type: Object Properties: Name Type Description id string The app id. version string The app version. name string The app name. shortName string The app shortName. description string The app description. startUrl string The app startUrl. icons Array.&lt;Icon&gt; The app icons. authorName string The app authorName. authorEmail string The app authorEmail. defaultLocale string The app defaultLocale. plugins Array.&lt;PluginAuthority&gt; The app PluginAuthority list. urls Array.&lt;UrlAuthority&gt; The app UrlAuthoritylist. backgroundColor string The app backgroundColor. themeDisplay string The app theme display. themeColor string The app theme color. themeFontName string The app theme font name. themeFontColor string The app theme font color. installTime number The app intall time. builtIn number The app builtIn. appPath string The app path. dataPath string The app data path. Source: elastos-trinity-plugins-appmanager/www/AppManager.js, line 58 Icon The icons info. Type: Object Properties: Name Type Description src string The icon src. sizes string The icon sizes. type string The icon type. Source: elastos-trinity-plugins-appmanager/www/AppManager.js, line 30 onReceiveIntent(action, params, from) The callback function to receive message. Parameters: Name Type Description action string The intent action params Object The intent params from string The intent from Source: elastos-trinity-plugins-appmanager/www/AppManager.js, line 96 onReceiveMessage(msg, type, from) The callback function to receive message. Parameters: Name Type Description msg string The message receive type number The message type from string The message from Source: elastos-trinity-plugins-appmanager/www/AppManager.js, line 86 PluginAuthority The plugin authority status. Type: Object Properties: Name Type Description plugin string The plugin name. authority AuthorityStatus The authority status. Source: elastos-trinity-plugins-appmanager/www/AppManager.js, line 40 UrlAuthority The access url authority status. Type: Object Properties: Name Type Description url string The url access. authority AuthorityStatus The authority status. Source: elastos-trinity-plugins-appmanager/www/AppManager.js, line 49 × Search results Close "},"module-AppManager-AppManager.html":{"id":"module-AppManager-AppManager.html","title":"Class: AppManager","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Class: AppManager AppManager~ AppManager new AppManager() The class representing dapp manager for launcher. Source: elastos-trinity-plugins-appmanager/www/AppManager.js, line 110 Members AuthorityStatus :number Message type to send or receive. Type: number Properties: Name Type Default Description NOINIT number 0 Not initialise ASK number 1 Ask for authority. ALLOW number 2 Allow the authority. DENY number 3 Deny the authority. Source: elastos-trinity-plugins-appmanager/www/AppManager.js, line 139 MessageType :number Message type to send or receive. Type: number Properties: Name Type Default Description INTERNAL number 1 The internal message IN_RETURN number 2 The internal return message. EXTERNAL_LAUNCHER number 3 The external launcher message EXTERNAL_INSTALL number 4 The external install message EX_RETURN number 5 The external return message. Source: elastos-trinity-plugins-appmanager/www/AppManager.js, line 120 Methods alertPrompt(title, message) Display a alert dialog prompt. Parameters: Name Type Description title string The dialog title. message string The dialog message. Source: elastos-trinity-plugins-appmanager/www/AppManager.js, line 364 askPrompt(title, message, onOK) Display a ask dialog prompt. Parameters: Name Type Description title string The dialog title. message string The dialog message. onOK function The function to call when click ok. Source: elastos-trinity-plugins-appmanager/www/AppManager.js, line 385 close(id, onSuccess [, onError]) Close a dapp by id. Parameters: Name Type Argument Description id string The dapp id. onSuccess function The function to call when success. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. Source: elastos-trinity-plugins-appmanager/www/AppManager.js, line 279 getAppInfo(id, onSuccess [, onError]) Get a dapp info. Parameters: Name Type Argument Description id string The dapp id. onSuccess function The function to call when success, the param is a AppInfo. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. Source: elastos-trinity-plugins-appmanager/www/AppManager.js, line 223 getAppInfos(onSuccess) Get a dapp info. Parameters: Name Type Description onSuccess function The function to call when success, the param is include 'infos' and 'list'. Source: elastos-trinity-plugins-appmanager/www/AppManager.js, line 238 getAppList(onSuccess) Get dapp list. Parameters: Name Type Description onSuccess function The function to call when success,the param is a dapp id list. Source: elastos-trinity-plugins-appmanager/www/AppManager.js, line 319 getLastList(onSuccess) Get last run list. Parameters: Name Type Description onSuccess function The function to call when success,the param is a dapp id list. Source: elastos-trinity-plugins-appmanager/www/AppManager.js, line 328 getLocale(onSuccess) Get locale. Parameters: Name Type Description onSuccess function The function to call.the param include 'defaultLang' and 'systemLang'. Source: elastos-trinity-plugins-appmanager/www/AppManager.js, line 172 getRunningList(onSuccess) Get running list. Parameters: Name Type Description onSuccess function The function to call when success,the param is a dapp id list. Source: elastos-trinity-plugins-appmanager/www/AppManager.js, line 310 infoPrompt(title, message) Display a info dialog prompt. Parameters: Name Type Description title string The dialog title. message string The dialog message. Source: elastos-trinity-plugins-appmanager/www/AppManager.js, line 374 install(url, onSuccess [, onError]) Install a dapp by path. Parameters: Name Type Argument Description url string The dapp install url. onSuccess function The function to call when success.the param is a AppInfo. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. Source: elastos-trinity-plugins-appmanager/www/AppManager.js, line 194 launcher(onSuccess [, onError]) Start the launcher.If the launcher running, it will be swith to curent. Parameters: Name Type Argument Description onSuccess function The function to call when success. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. Source: elastos-trinity-plugins-appmanager/www/AppManager.js, line 268 sendIntent(action, params, onSuccess [, onError]) Send a intent by action. Parameters: Name Type Argument Description action string The intent action. params Object The intent params. onSuccess function The function to call when success. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. Source: elastos-trinity-plugins-appmanager/www/AppManager.js, line 398 sendIntentRespone(action, result, intentId, onSuccess [, onError]) Send a intent respone by id. Parameters: Name Type Argument Description action string The intent action. result Object The intent respone result. intentId long The intent id. onSuccess function The function to call when success. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. Source: elastos-trinity-plugins-appmanager/www/AppManager.js, line 437 sendMessage(id, type, msg, onSuccess [, onError]) Send a message by id. Parameters: Name Type Argument Description id string The dapp id. type MessageType The message type. msg string The message content. onSuccess function The function to call when success. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. Source: elastos-trinity-plugins-appmanager/www/AppManager.js, line 292 setCurrentLocate(code, onSuccess [, onError]) Set current locale. Parameters: Name Type Argument Description code string The current locale code. onSuccess function The function to call when success.the param is a AppInfo. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. Source: elastos-trinity-plugins-appmanager/www/AppManager.js, line 183 setIntentListener(callback) Set intent listener for message callback. Parameters: Name Type Description callback onReceiveIntent The function receive the intent. Source: elastos-trinity-plugins-appmanager/www/AppManager.js, line 416 setListener(callback) Set listener for message callback. Parameters: Name Type Description callback onReceiveMessage The function receive the message. Source: elastos-trinity-plugins-appmanager/www/AppManager.js, line 301 setPluginAuthority(id, plugin, authority, onSuccess [, onError]) Set a plugin authority. Only the launcher can set. Parameters: Name Type Argument Description id string The dapp id. plugin string The plugin id to set authorty. authority AuthorityStatus The authority to set. onSuccess function The function to call when success. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. Source: elastos-trinity-plugins-appmanager/www/AppManager.js, line 341 setUrlAuthority(id, url, authority, onSuccess [, onError]) Set a url authority. Only the launcher can set. Parameters: Name Type Argument Description id string The dapp id. url string The url to set authority. authority AuthorityStatus The authority to set. onSuccess function The function to call when success. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. Source: elastos-trinity-plugins-appmanager/www/AppManager.js, line 354 start(id, onSuccess [, onError]) Start a dapp by id. If the dapp running, it will be swith to curent. Parameters: Name Type Argument Description id string The dapp id. onSuccess function The function to call when success. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. Source: elastos-trinity-plugins-appmanager/www/AppManager.js, line 258 unInstall(id, onSuccess [, onError]) Uninstall a dapp by id. Parameters: Name Type Argument Description id string The dapp id. onSuccess function The function to call when success.the param is the id. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. Source: elastos-trinity-plugins-appmanager/www/AppManager.js, line 211 × Search results Close "},"module-AppService.html":{"id":"module-AppService.html","title":"Module: AppService","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Module: AppService Source: elastos-trinity-plugins-appservice/www/AppService.js, line 26 Classes AppService Type Definitions AppInfo The App information. Type: Object Properties: Name Type Description id string The app id. version string The app version. name string The app name. shortName string The app shortName. description string The app description. startUrl string The app startUrl. icons Array.&lt;Icon&gt; The app icons. authorName string The app authorName. authorEmail string The app authorEmail. defaultLocale string The app defaultLocale. plugins Array.&lt;PluginAuthority&gt; The app PluginAuthority list. urls Array.&lt;UrlAuthority&gt; The app UrlAuthoritylist. backgroundColor string The app backgroundColor. themeDisplay string The app theme display. themeColor string The app theme color. themeFontName string The app theme font name. themeFontColor string The app theme font color. installTime number The app intall time. builtIn number The app builtIn. appPath string The app path. dataPath string The app data path. Source: elastos-trinity-plugins-appservice/www/AppService.js, line 58 Icon The icons info. Type: Object Properties: Name Type Description src string The icon src. sizes string The icon sizes. type string The icon type. Source: elastos-trinity-plugins-appservice/www/AppService.js, line 30 onReceiveIntent(action, params, from) The callback function to receive message. Parameters: Name Type Description action string The intent action params Object The intent params from string The intent from Source: elastos-trinity-plugins-appservice/www/AppService.js, line 96 onReceiveMessage(msg, type, from) The callback function to receive message. Parameters: Name Type Description msg string The message receive type number The message type from string The message from Source: elastos-trinity-plugins-appservice/www/AppService.js, line 86 PluginAuthority The plugin authority status. Type: Object Properties: Name Type Description plugin string The plugin name. authority AuthorityStatus The authority status. Source: elastos-trinity-plugins-appservice/www/AppService.js, line 40 UrlAuthority The access url authority status. Type: Object Properties: Name Type Description url string The url access. authority AuthorityStatus The authority status. Source: elastos-trinity-plugins-appservice/www/AppService.js, line 49 × Search results Close "},"module-AppService-AppService.html":{"id":"module-AppService-AppService.html","title":"Class: AppService","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Class: AppService AppService~ AppService new AppService() The class representing dapp service. Source: elastos-trinity-plugins-appservice/www/AppService.js, line 110 Members MessageType :number Message type to send or receive. Type: number Properties: Name Type Default Description INTERNAL number 1 The internal message IN_RETURN number 2 The internal return message. EXTERNAL_LAUNCHER number 3 The external launcher message EXTERNAL_INSTALL number 4 The external install message EX_RETURN number 5 The external return message. Source: elastos-trinity-plugins-appservice/www/AppService.js, line 120 Methods close(onSuccess [, onError]) Close the dapp. Parameters: Name Type Argument Description onSuccess function The function to call when success. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. Source: elastos-trinity-plugins-appservice/www/AppService.js, line 185 getAppInfo(onSuccess [, onError]) Get a dapp info. Parameters: Name Type Argument Description onSuccess function The function to call when success, the param is a AppInfo. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. Source: elastos-trinity-plugins-appservice/www/AppService.js, line 195 getLocale(onSuccess) Get locale. Parameters: Name Type Description onSuccess function The function to call.the param include 'defaultLang', 'currentLang' and 'systemLang'. Source: elastos-trinity-plugins-appservice/www/AppService.js, line 154 launcher(onSuccess [, onError]) Start the launcher.If the launcher running, it will be swith to curent. Parameters: Name Type Argument Description onSuccess function The function to call when success. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. Source: elastos-trinity-plugins-appservice/www/AppService.js, line 175 sendIntent(action, params, onSuccess [, onError]) Send a intent by action. Parameters: Name Type Argument Description action string The intent action. params Object The intent params. onSuccess function The function to call when success. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. Source: elastos-trinity-plugins-appservice/www/AppService.js, line 235 sendIntentRespone(action, result, intentId, onSuccess [, onError]) Send a intent respone by id. Parameters: Name Type Argument Description action string The intent action. result Object The intent respone result. intentId long The intent id. onSuccess function The function to call when success. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. Source: elastos-trinity-plugins-appservice/www/AppService.js, line 274 sendMessage(id, type, msg, onSuccess [, onError]) Send a message by id. Parameters: Name Type Argument Description id string The dapp id. type MessageType The message type. msg string The message content. onSuccess function The function to call when success. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. Source: elastos-trinity-plugins-appservice/www/AppService.js, line 214 setIntentListener(callback) Set intent listener for message callback. Parameters: Name Type Description callback onReceiveIntent The function receive the intent. Source: elastos-trinity-plugins-appservice/www/AppService.js, line 253 setListener(callback) Set listener for message callback. Parameters: Name Type Description callback onReceiveMessage The function receive the message. Source: elastos-trinity-plugins-appservice/www/AppService.js, line 223 start(id, onSuccess [, onError]) Start a dapp by id. If the dapp running, it will be swith to curent. Parameters: Name Type Argument Description id string The dapp id. onSuccess function The function to call when success. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. Source: elastos-trinity-plugins-appservice/www/AppService.js, line 165 × Search results Close "},"module-Camera.html":{"id":"module-Camera.html","title":"Module: Camera","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Module: Camera Source: cordova-plugin-camera/www/Camera.js, line 31 Methods &lt;static&gt; cleanup() Removes intermediate image files that are kept in temporary storage after calling camera.getPicture. Applies only when the value of Camera.sourceType equals Camera.PictureSourceType.CAMERA and the Camera.destinationType equals Camera.DestinationType.FILE_URI. Supported Platforms iOS Source: cordova-plugin-camera/www/Camera.js, line 177 Example navigator.camera.cleanup(onSuccess, onFail); function onSuccess() { console.log(\"Camera cleanup success.\") } function onFail(message) { alert('Failed because: ' + message); } &lt;static&gt; getPicture(successCallback, errorCallback, options) Takes a photo using the camera, or retrieves a photo from the device's image gallery. The image is passed to the success callback as a Base64-encoded String, or as the URI for the image file. The camera.getPicture function opens the device's default camera application that allows users to snap pictures by default - this behavior occurs, when Camera.sourceType equals Camera.PictureSourceType.CAMERA. Once the user snaps the photo, the camera application closes and the application is restored. If Camera.sourceType is Camera.PictureSourceType.PHOTOLIBRARY or Camera.PictureSourceType.SAVEDPHOTOALBUM, then a dialog displays that allows users to select an existing image. The return value is sent to the cameraSuccess callback function, in one of the following formats, depending on the specified cameraOptions: A String containing the Base64-encoded photo image. A String representing the image file location on local storage (default). You can do whatever you want with the encoded image or URI, for example: Render the image in an &lt;img&gt; tag, as in the example below Save the data locally (LocalStorage, Lawnchair, etc.) Post the data to a remote server NOTE: Photo resolution on newer devices is quite good. Photos selected from the device's gallery are not downscaled to a lower quality, even if a quality parameter is specified. To avoid common memory problems, set Camera.destinationType to FILE_URI rather than DATA_URL. Supported Platforms Android BlackBerry Browser Firefox FireOS iOS Windows WP8 Ubuntu More examples here. Quirks here. Parameters: Name Type Description successCallback module:Camera.onSuccess errorCallback module:Camera.onError options module:Camera.CameraOptions CameraOptions Source: cordova-plugin-camera/www/Camera.js, line 130 Example navigator.camera.getPicture(cameraSuccess, cameraError, cameraOptions); Type Definitions CameraOptions Optional parameters to customize the camera settings. Quirks Type: Object Properties: Name Type Argument Default Description quality number &lt;optional&gt; 50 Quality of the saved image, expressed as a range of 0-100, where 100 is typically full resolution with no loss from file compression. (Note that information about the camera's resolution is unavailable.) destinationType module:Camera.DestinationType &lt;optional&gt; FILE_URI Choose the format of the return value. sourceType module:Camera.PictureSourceType &lt;optional&gt; CAMERA Set the source of the picture. allowEdit Boolean &lt;optional&gt; false Allow simple editing of image before selection. encodingType module:Camera.EncodingType &lt;optional&gt; JPEG Choose the returned image file's encoding. targetWidth number &lt;optional&gt; Width in pixels to scale image. Must be used with targetHeight. Aspect ratio remains constant. targetHeight number &lt;optional&gt; Height in pixels to scale image. Must be used with targetWidth. Aspect ratio remains constant. mediaType module:Camera.MediaType &lt;optional&gt; PICTURE Set the type of media to select from. Only works when PictureSourceType is PHOTOLIBRARY or SAVEDPHOTOALBUM. correctOrientation Boolean &lt;optional&gt; Rotate the image to correct for the orientation of the device during capture. saveToPhotoAlbum Boolean &lt;optional&gt; Save the image to the photo album on the device after capture. popoverOptions module:CameraPopoverOptions &lt;optional&gt; iOS-only options that specify popover location in iPad. cameraDirection module:Camera.Direction &lt;optional&gt; BACK Choose the camera to use (front- or back-facing). Source: cordova-plugin-camera/www/Camera.js, line 57 onError(message) Callback function that provides an error message. Parameters: Name Type Description message string The message is provided by the device's native code. Source: cordova-plugin-camera/www/Camera.js, line 38 onSuccess(imageData) Callback function that provides the image data. Parameters: Name Type Description imageData string Base64 encoding of the image data, or the image file URI, depending on cameraOptions in effect. Source: cordova-plugin-camera/www/Camera.js, line 44 Example // Show image // function cameraCallback(imageData) { var image = document.getElementById('myImage'); image.src = \"data:image/jpeg;base64,\" + imageData; } × Search results Close "},"module-CameraConstants.html":{"id":"module-CameraConstants.html","title":"Module: CameraConstants","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Module: CameraConstants Source: cordova-plugin-camera/www/CameraConstants.js, line 22 Members &lt;static&gt; DestinationType :number Defines the output format of Camera.getPicture call. Note: On iOS passing DestinationType.NATIVE_URI along with PictureSourceType.PHOTOLIBRARY or PictureSourceType.SAVEDPHOTOALBUM will disable any image modifications (resize, quality change, cropping, etc.) due to implementation specific. Type: number Properties: Name Type Default Description DATA_URL number 0 Return base64 encoded string. DATA_URL can be very memory intensive and cause app crashes or out of memory errors. Use FILE_URI or NATIVE_URI if possible FILE_URI number 1 Return file uri (content://media/external/images/media/2 for Android) NATIVE_URI number 2 Return native uri (eg. asset-library://... for iOS) Source: cordova-plugin-camera/www/CameraConstants.js, line 36 &lt;static&gt; Direction :number Type: number Properties: Name Type Default Description BACK number 0 Use the back-facing camera FRONT number 1 Use the front-facing camera Source: cordova-plugin-camera/www/CameraConstants.js, line 95 &lt;static&gt; EncodingType :number Type: number Properties: Name Type Default Description JPEG number 0 Return JPEG encoded image PNG number 1 Return PNG encoded image Source: cordova-plugin-camera/www/CameraConstants.js, line 47 &lt;static&gt; MediaType :number Type: number Properties: Name Type Default Description PICTURE number 0 Allow selection of still pictures only. DEFAULT. Will return format specified via DestinationType VIDEO number 1 Allow selection of video only, ONLY RETURNS URL ALLMEDIA number 2 Allow selection from all media types Source: cordova-plugin-camera/www/CameraConstants.js, line 56 &lt;static&gt; PictureSourceType :number Defines the output format of Camera.getPicture call. Note: On iOS passing PictureSourceType.PHOTOLIBRARY or PictureSourceType.SAVEDPHOTOALBUM along with DestinationType.NATIVE_URI will disable any image modifications (resize, quality change, cropping, etc.) due to implementation specific. Type: number Properties: Name Type Default Description PHOTOLIBRARY number 0 Choose image from the device's photo library (same as SAVEDPHOTOALBUM for Android) CAMERA number 1 Take picture from camera SAVEDPHOTOALBUM number 2 Choose image only from the device's Camera Roll album (same as PHOTOLIBRARY for Android) Source: cordova-plugin-camera/www/CameraConstants.js, line 73 &lt;static&gt; PopoverArrowDirection :number Matches iOS UIPopoverArrowDirection constants to specify arrow location on popover. Type: number Properties: Name Type Default Description ARROW_UP number 1 ARROW_DOWN number 2 ARROW_LEFT number 4 ARROW_RIGHT number 8 ARROW_ANY number 15 Source: cordova-plugin-camera/www/CameraConstants.js, line 85 × Search results Close "},"module-CameraPopoverHandle.html":{"id":"module-CameraPopoverHandle.html","title":"Module: CameraPopoverHandle","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Module: CameraPopoverHandle A handle to an image picker popover. Supported Platforms iOS Source: cordova-plugin-camera/www/ios/CameraPopoverHandle.js, line 24 Example navigator.camera.getPicture(onSuccess, onFail, { destinationType: Camera.DestinationType.FILE_URI, sourceType: Camera.PictureSourceType.PHOTOLIBRARY, popoverOptions: new CameraPopoverOptions(300, 300, 100, 100, Camera.PopoverArrowDirection.ARROW_ANY, 300, 600) }); // Reposition the popover if the orientation changes. window.onorientationchange = function() { var cameraPopoverHandle = new CameraPopoverHandle(); var cameraPopoverOptions = new CameraPopoverOptions(0, 0, 100, 100, Camera.PopoverArrowDirection.ARROW_ANY, 400, 500); cameraPopoverHandle.setPosition(cameraPopoverOptions); } × Search results Close "},"module-CameraPopoverOptions.html":{"id":"module-CameraPopoverOptions.html","title":"Module: CameraPopoverOptions","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Module: CameraPopoverOptions iOS-only parameters that specify the anchor element location and arrow direction of the popover when selecting images from an iPad's library or album. Note that the size of the popover may change to adjust to the direction of the arrow and orientation of the screen. Make sure to account for orientation changes when specifying the anchor element location. Source: cordova-plugin-camera/www/CameraPopoverOptions.js, line 24 × Search results Close "},"module-Capture.html":{"id":"module-Capture.html","title":"Module: Capture","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Module: Capture Source: cordova-plugin-media-capture/www/capture.js, line 26 Methods &lt;inner&gt; _capture((DOMString}, successCB, errorCB, options) Launches a capture of different types. Parameters: Name Type Description (DOMString} type successCB function errorCB function options CaptureVideoOptions Source: cordova-plugin-media-capture/www/capture.js, line 37 &lt;inner&gt; Capture() The Capture interface exposes an interface to the camera and microphone of the hosting device. Source: cordova-plugin-media-capture/www/capture.js, line 47 × Search results Close "},"module-CarrierPlugin.html":{"id":"module-CarrierPlugin.html","title":"Module: CarrierPlugin","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Module: CarrierPlugin Source: elastos-trinity-plugins-carrier/www/carrier.js, line 52 Classes Carrier Session Stream Type Definitions AddressInfo The netword address information. Type: Object Properties: Name Type Argument Description type CandidateType The address type. address string The address. port string The port. relatedAddress string &lt;optional&gt; The related address status. relatedPort string &lt;optional&gt; The related port. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 105 BootstrapNode The Carrier user information. Type: Object Properties: Name Type Description ipv4 string The server ipv4. ipv6 string The server ipv6. port string The server port. publicKey string The publicKey. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 56 CarrierCallbacks The Carrier callbacks. Type: Object Properties: Name Type Description onConnection onConnection The callback function to process the self connection status. onReady onReady The callback function to process the ready notification. onSelfInfoChanged onSelfInfoChanged The callback function to process the self info changed event. onFriends onFriends The callback function to iterate the each friend item in friend list. onFriendConnection onFriendConnection The callback function to process the friend connections status changed event. onFriendInfoChanged onFriendInfoChanged The callback function to process the friend information changed event. onFriendPresence onFriendPresence The callback function to process the friend presence changed event. onFriendRequest onFriendRequest The callback function to process the friend request. onFriendAdded onFriendAdded The callback function to process the new friend added event. onFriendRemoved onFriendRemoved The callback function to process the friend removed event. onFriendMessage onFriendMessage The callback function to process the friend message. onFriendInviteRequest onFriendInviteRequest The callback function to process the friend invite request. onSessionRequest onSessionRequest The callback function that handle session request. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 127 FriendInfo The Carrier friend information. Type: Object Properties: Name Type Description userInfo UserInfo The user info. presence PresenceStatus The presence status. connection ConnectionStatus The connection status. label string The friend's label name. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 94 onChannelClose(stream, channel, reason) The callback function to be called when channel close. Parameters: Name Type Description stream Stream The carrier stream instance channel number The current channel ID. reason string Channel close reason code, defined in CloseReason. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 249 onChannelData(stream, channel, data) The callback functiont to be called when channel received incoming data. Parameters: Name Type Description stream Stream The carrier stream instance channel number The current channel ID. data base64 The received packet data. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 260 onChannelOpen(stream, channel, cookie) The callback function to be called when new multiplexing channel request to open. Parameters: Name Type Description stream Stream The carrier stream instance channel number The current channel ID. cookie string Application defined string data send from remote peer. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 226 onChannelOpened(stream, channel) The callback function to be called when new multiplexing channel opened. Parameters: Name Type Description stream Stream The carrier stream instance channel number The current channel ID. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 239 onChannelPending(stream, channel) The callback function to be called when remote peer ask to pend data sending. Parameters: Name Type Description stream Stream The carrier stream instance channel number The current channel ID. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 271 onChannelResume(stream, channel) The callback function to be called when remote peer ask to resume data sending. Parameters: Name Type Description stream Stream The carrier stream instance channel number The current channel ID. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 281 onConnection(carrier, status) The callback function to process the self connection status. Parameters: Name Type Description carrier Carrier Carrier node instance status number Current connection status. @see ConnectionStatus Source: elastos-trinity-plugins-carrier/www/carrier.js, line 638 onFriendAdded(carrier, friendInfo) The callback function to process the new friend added event. Parameters: Name Type Description carrier Carrier Carrier node instance friendInfo FriendInfo The added friend's information Source: elastos-trinity-plugins-carrier/www/carrier.js, line 725 onFriendConnection(carrier, friendId, status) The callback function to process the friend connections status changed event. Parameters: Name Type Description carrier Carrier Carrier node instance friendId string The friend's user id. status number The connection status of friend. @see ConnectionStatus Source: elastos-trinity-plugins-carrier/www/carrier.js, line 680 onFriendInfoChanged(carrier, friendId, info) The callback function to process the friend information changed event. Parameters: Name Type Description carrier Carrier Carrier node instance friendId string The friend's user id info FriendInfo The update friend information Source: elastos-trinity-plugins-carrier/www/carrier.js, line 691 onFriendInviteRequest(carrier, from, data) The callback function to process the friend invite request. Parameters: Name Type Description carrier Carrier Carrier node instance from string The user id from who send the invite request data string The application defined data sent from friend Source: elastos-trinity-plugins-carrier/www/carrier.js, line 756 onFriendInviteResponse(from, status, reason, data) The callback function to process the friend invite response. Parameters: Name Type Description from string The target user id who send friend invite response status number The status code of invite response. 0 is success, otherwise error reason string The error message if status is error, otherwise null data string The application defined data return by target user Source: elastos-trinity-plugins-carrier/www/carrier.js, line 162 onFriendMessage(carrier, from, message) The callback function to process the friend message. Parameters: Name Type Description carrier Carrier Carrier node instance from string The id from who send the message message string The message content Source: elastos-trinity-plugins-carrier/www/carrier.js, line 745 onFriendPresence(carrier, friendId, presence) The callback function to process the friend presence changed event. Parameters: Name Type Description carrier Carrier Carrier node instance friendId string The friend's user id presence number The presence status of the friend Source: elastos-trinity-plugins-carrier/www/carrier.js, line 702 onFriendRemoved(carrier, friendId) The callback function to process the friend removed event. Parameters: Name Type Description carrier Carrier Carrier node instance friendId string The friend's user id Source: elastos-trinity-plugins-carrier/www/carrier.js, line 735 onFriendRequest(carrier, userId, info, hello) The callback function to process the friend request. Parameters: Name Type Description carrier Carrier Carrier node instance userId string The user id who want be friend with current user info UserInfo The user information to userId hello string The PIN for target user, or any application defined content Source: elastos-trinity-plugins-carrier/www/carrier.js, line 713 onFriends(carrier, friends) The callback function to iterate the each friend item in friend list. Parameters: Name Type Description carrier Carrier Carrier node instance friends Array The friends list. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 670 onReady(carrier) The callback function to process the ready notification. Application should wait this callback invoked before calling any function to interact with friends. Parameters: Name Type Description carrier Carrier Carrier node instance Source: elastos-trinity-plugins-carrier/www/carrier.js, line 648 onSelfInfoChanged(carrier, userInfo) The callback function to process the self info changed event. Parameters: Name Type Description carrier Carrier Carrier node instance userInfo UserInfo The updated user information Source: elastos-trinity-plugins-carrier/www/carrier.js, line 660 onSessionRequest(carrier, from, sdp) The callback function that handle session request. Parameters: Name Type Description carrier Carrier Carrier node instance from string The id who send the message sdp string The remote users SDP. Reference: https://tools.ietf.org/html/rfc4566 Source: elastos-trinity-plugins-carrier/www/carrier.js, line 767 onSessionRequestComplete(session, status, reason, sdp) The callback function to receive session request complete event. Parameters: Name Type Description session Session The carrier session instance. status number The status code of the response. 0 is success, otherwise is error. reason string The error message if status is error, or nil if session request error happened. sdp string The remote users SDP. Reference: https://tools.ietf.org/html/rfc4566 Source: elastos-trinity-plugins-carrier/www/carrier.js, line 173 onStateChanged(stream, state) The callback function to report state of stream when it's state changes. Parameters: Name Type Description stream Stream The carrier stream instance state StreamState Stream state defined in StreamState Source: elastos-trinity-plugins-carrier/www/carrier.js, line 201 onStreamData(stream, data) The callback will be called when the stream receives incoming packet. If the stream enabled multiplexing mode, application will not receive stream-layered data callback any more. All data will reported as multiplexing channel data. Parameters: Name Type Description stream Stream The carrier stream instance data base64 The received packet data. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 212 Options Options defines several settings that control the way the Carrier node connects to the carrier network. Default values are not defined for bootstraps options, so application should be set bootstrap nodes clearly. Type: Object Properties: Name Type Description udpEnabled Boolean Set to use udp transport or not. Setting this value to false will force carrier node to TCP only, which will potentially slow down the message to run through. persistentLocation string Set the persistent data location. The location must be set. bootstraps Array BootstrapNode Array. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 67 StreamCallbacks The Stream callbacks. Type: Object Properties: Name Type Description onStateChanged onStateChanged The callback function to report state of stream when it's state changes. onStreamData onStreamData The callback will be called when the stream receives incoming packet. onChannelOpen onChannelOpen The callback function to be called when new multiplexing channel opened. onChannelOpened onChannelOpened The callback function to be called when new multiplexing channel opened. onChannelClose onChannelClose The callback function to be called when channel close. onChannelData onChannelData The callback functiont to be called when channel received incoming data. onChannelPending onChannelPending The callback function to be called when remote peer ask to pend data sending. onChannelResume onChannelResume The callback function to be called when remote peer ask to resume data sending. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 147 TransportInfo The netword transport information. Type: Object Properties: Name Type Description topology NetworkTopology The network topology. localAddr AddressInfo The local address. remoteAddr AddressInfo The remote address. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 117 UserInfo The Carrier user information. Type: Object Properties: Name Type Description userId string The user ID. name string The nickname. description string user's brief description. hasAvatar Boolean Has avatar or not. gender string The gender. phone string The phone number. email string The email address. region string The region. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 79 × Search results Close "},"module-carrierPlugin_.html":{"id":"module-carrierPlugin_.html","title":"Module: carrierPlugin","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Module: carrierPlugin Source: elastos-trinity-plugins-carrier/www/carrier.js, line 1114 Members CandidateType :number Carrier Stream's candidate type. Type: number Properties: Name Type Default Description HOST number 0 Host candidate. SERVE_RREFLEXIVE number 1 Server reflexive, only valid to ICE transport. PEER_REFLEXIVE number 2 Peer reflexive, only valid to ICE transport. RELAYED number 3 Relayed Candidate, only valid to ICE tranport. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 1206 CloseReason :number Multiplexing channel close reason mode. Type: number Properties: Name Type Default Description NORMAL number 0 Channel closed normaly. TIMEOUT number 1 Channel closed because of timeout. ERROR number 2 Channel closed because error occured. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 1249 ConnectionStatus :number Carrier node connection status to the carrier network. Type: number Properties: Name Type Default Description CONNECTED number 0 Carrier node connected to the carrier network. DISCONNECTED number 1 There is no connection to the carrier network. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 1134 NetworkTopology :number Carrier network topology for session peers related to each other. Type: number Properties: Name Type Default Description LAN number 0 LAN network topology. P2P number 1 P2P network topology. RELAYED number 2 Relayed netowrk topology. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 1223 PortForwardingProtocol :number Port forwarding supported protocols. Type: number Properties: Name Type Default Description TCP number 1 TCP protocol. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 1238 PresenceStatus :number Carrier node presence status. Type: number Properties: Name Type Default Description NONE number 0 Carrier node is online and available. AWAY number 1 Carrier node is being away. BUSY number 2 Carrier node is being busy. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 1147 StreamMode :number Carrier stream mode. Type: number Properties: Name Type Default Description COMPRESS number 1 Compress option, indicates data would be compressed before transmission. For now, just reserved this bit option for future implement. PLAIN number 2 Encrypt option, indicates data would be transmitted with plain mode. which means that transmitting data would be encrypted in default. RELIABLE number 4 Relaible option, indicates data transmission would be reliable, and be guranteed to received by remote peer, which acts as TCP transmission protocol. Without this option bitwised, the transmission would be unreliable as UDP transmission protocol. MULTIPLEXING number 8 Multiplexing option, indicates multiplexing would be activated on enstablished stream, and need to use multipexing APIs related with channel instread of APIs related strema to send/receive data. PORT_FORWARDING number 16 PortForwarding option, indicates port forwarding would be activated on established stream. This options should bitwise with 'Multiplexing' option. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 1264 StreamState :number Carrier stream state The stream state will be changed according to the phase of the stream. Type: number Properties: Name Type Default Description RAW number 0 Raw stream. INITIALIZED number 1 Initialized stream. TRANSPORT_READY number 2 The underlying transport is ready for the stream to start. CONNECTING number 3 The stream is trying to connect the remote. CONNECTED number 4 The stream connected with remove peer. DEACTIVATED number 5 The stream is deactived. CLOSED number 6 The stream closed gracefully. ERROR number 7 The stream is on error, cannot to continue. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 1181 StreamType :number Carrier stream type. Reference: https://tools.ietf.org/html/rfc4566#section-5.14 https://tools.ietf.org/html/rfc4566#section-8 Type: number Properties: Name Type Default Description AUDIO number 0 Audio stream. VIDEO number 1 Video stream. TEXT number 2 Text stream. APPLICATION number 3 Application stream. MESSAGE number 4 Message stream. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 1162 Methods createObject(onSuccess [, onError] [, options], callbacks) Create a carrier object instance. After initializing the instance, it's ready to start and therefore connect to carrier network. Parameters: Name Type Argument Description onSuccess function The function to call when success. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. options Options &lt;optional&gt; The options to set for creating carrier node. If set to null, will use default. callbacks CarrierCallbacks The callbacks for carrier node. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 1451 getIdFromAddress(onSuccess [, onError], address) Get carrier ID from carrier node address. Parameters: Name Type Argument Description onSuccess function The function to call when success, the param is a String: User id if address is valid, otherwise null. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. address string The carrier node address. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 1438 getVersion(onSuccess [, onError], onSuccess) Get current version of Carrier node. Parameters: Name Type Argument Description onSuccess function The function to call when success, the param is a String: The version of carrier node. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. onSuccess callback The version of carrier node Source: elastos-trinity-plugins-carrier/www/carrier.js, line 1397 isValidAddress(onSuccess [, onError], address) Check if the carrier node address is valid. Parameters: Name Type Argument Description onSuccess function The function to call when success, the param is a Boolean: True if key is valid, otherwise false. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. address string The carrier node address to be check. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 1423 isValidId(onSuccess [, onError], id) Check if the ID is Carrier node id. Parameters: Name Type Argument Description onSuccess function The function to call when success, the param is a Boolean: True if id is valid, otherwise false. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. id string The carrier node id to be check. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 1408 × Search results Close "},"module-CarrierPlugin-Carrier.html":{"id":"module-CarrierPlugin-Carrier.html","title":"Class: Carrier","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Class: Carrier CarrierPlugin~ Carrier new Carrier() The class representing Carrier. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 623 Members address Properties: Name Type Description address string Node address. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 632 nodeId Properties: Name Type Description nodeId string Node id. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 628 nospam Properties: Name Type Description nospam number The nospam for Carrier address is used to eliminate spam friend. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 784 presence Properties: Name Type Description presence number Presence status. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 797 userId Properties: Name Type Description userId string User id. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 630 Methods acceptFriend(onSuccess [, onError], userId) Accept the friend request. This function is used to add a friend in response to a friend request. Parameters: Name Type Argument Description onSuccess function The function to call when success. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. userId string The user id who want be friend with us. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 1008 addFriend(onSuccess [, onError], address, hello) Add friend by sending a new friend request. This function will add a new friend with specific address, and then send a friend request to the target node. Parameters: Name Type Argument Description onSuccess function The function to call when success. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. address string the target user address of remote carrier node. hello string PIN for target user, or any application defined content. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 995 destroy(onSuccess [, onError]) Disconnect carrier node from carrier network, and destroy all associated resources to carreier node instance. After calling the method, the carrier node instance becomes invalid. Parameters: Name Type Argument Description onSuccess function The function to call when success. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 1106 getFriend(onSuccess [, onError], userId) Get specified friend information. Parameters: Name Type Argument Description onSuccess function The function to call when success, the param is a FriendInfo: The friend information. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. userId string The user identifier of friend Source: elastos-trinity-plugins-carrier/www/carrier.js, line 954 getFriends(onSuccess [, onError]) Get friends list. Parameters: Name Type Argument Description onSuccess function The function to call when success, the param is a {friendId: info} Object: The list of friend information to current user. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 943 getSelfInfo(onSuccess [, onError]) Get self user information. Parameters: Name Type Argument Description onSuccess function The function to call when success, the param is a UserInfo: the user information to the carrier node. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 856 inviteFriend(onSuccess [, onError], to, data, handler) Send invite request to a friend. Application can attach the application defined data with in the invite request, and the data will send to target friend. Parameters: Name Type Argument Description onSuccess function The function to call when success. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. to string The target id data string The application defined data send to target user handler onFriendInviteResponse The handler to receive invite reponse Source: elastos-trinity-plugins-carrier/www/carrier.js, line 1053 isFriend(onSuccess [, onError], userId) Check if the user ID is friend. Parameters: Name Type Argument Description onSuccess function The function to call when success, the param is a Boolean: True if the user is a friend, or false if not. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. userId string The userId to check. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 980 isReady(onSuccess [, onError]) Check if carrier node instance is being ready. All carrier interactive APIs should be called only if carrier node instance is being ready. Parameters: Name Type Argument Description onSuccess function The function to call when success, the param is a Boolean: true if the carrier node instance is ready, or false if not. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 933 labelFriend(onSuccess [, onError], userId, label) Set the label of the specified friend. The label of a friend is a private alias name for current user. It can be seen by current user only, and has no impact to the target friend itself. Parameters: Name Type Argument Description onSuccess function The function to call when success. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. userId string The friend's user identifier label string The new label of specified friend Source: elastos-trinity-plugins-carrier/www/carrier.js, line 969 newSession(onSuccess [, onError], to) Create a new session to a friend. The session object represent a conversation handle to a friend. Parameters: Name Type Argument Description onSuccess function The function to call when success, the param is a Session Object: The new Session object onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. to string The target id(userid or userid@nodeid). Source: elastos-trinity-plugins-carrier/www/carrier.js, line 1086 on(name, callback) Add or remove Carrier callback. Parameters: Name Type Description name string The callback name. callback function The function to add or change callback function. If set to null, will remove callback. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 815 removeFriend(onSuccess [, onError], userId) Remove a friend. This function will remove a friend on this carrier node. Parameters: Name Type Argument Description onSuccess function The function to call when success. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. userId string The target user id to remove friendship Source: elastos-trinity-plugins-carrier/www/carrier.js, line 1021 replyFriendInvite(onSuccess [, onError], to, status, reason, data) Reply the friend invite request. This function will send a invite response to friend. Parameters: Name Type Argument Description onSuccess function The function to call when success. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. to string The id who send invite request status number The status code of the response. 0 is success, otherwise is error reason string The error message if status is error, or null if success data string The application defined data send to target user. If the status is error, this will be ignored Source: elastos-trinity-plugins-carrier/www/carrier.js, line 1073 sendFriendMessage(onSuccess [, onError], to, message) Send a message to a friend. The message length may not exceed MAX_APP_MESSAGE_LEN, and message itself should be text-formatted. Larger messages must be split by application and sent as separate messages. Other nodes can reassemble the fragments. Parameters: Name Type Argument Description onSuccess function The function to call when success. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. to string The target id message string The message content defined by application Source: elastos-trinity-plugins-carrier/www/carrier.js, line 1037 setSelfInfo(onSuccess [, onError], userinfo) Update self user information. After self user information changed, carrier node will update this information to carrier network, and thereupon network broadcasts the change to all friends. Parameters: Name Type Argument Description onSuccess function The function to call when success. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. userinfo UserInfo The user information to update for this carrier node. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 869 start(onSuccess [, onError], iterateInterval) Start carrier node asynchronously to connect to carrier network. If the connection to network is successful, carrier node starts working. Parameters: Name Type Argument Description onSuccess function The function to call when success. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. iterateInterval number Internal loop interval, in milliseconds. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 845 × Search results Close "},"module-CarrierPlugin-Session.html":{"id":"module-CarrierPlugin-Session.html","title":"Class: Session","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Class: Session CarrierPlugin~ Session new Session() The class representing Carrier Session. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 439 Members carrier Properties: Name Type Description carrier Carrier Parent carrier object. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 447 peer Properties: Name Type Description peer string The remote peer userid. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 445 Methods addService(onSuccess [, onError], service, protocol, host, port) Add a new portforwarding service to session. The registered services can be used by remote peer in portforwarding request. Parameters: Name Type Argument Description onSuccess function The function to call when success. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. service string The new service name, should be unique in session scope. protocol PortForwardingProtocol The protocol of the service. host string The host name or ip of the service. port number The port of the service. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 601 addStream(onSuccess [, onError], type, options, callbacks) Add a new stream to session. Carrier stream supports several underlying transport mechanisms: Plain/encrypted UDP data gram protocol Plain/encrypted TCP like reliable stream protocol Multiplexing over UDP Multiplexing over TCP like reliable protocol Application can use options to specify the new stream mode. Multiplexing over UDP can not provide reliable transport. Parameters: Name Type Argument Description onSuccess function The function to call when success, the param is a Stream object: The new added carrier stream. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. type StreamType The stream type defined in StreamType options number The stream mode options. options are constructed by a bitwise-inclusive OR of flags callbacks StreamCallbacks The stream callbacks. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 542 close() Close a session to friend. All resources include streams, channels, portforwardings associated with current session will be destroyed. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 466 removeService(onSuccess [, onError], service) Remove a portforwarding server to session. This function has not effect on existing portforwarings. Parameters: Name Type Argument Description onSuccess function The function to call when success. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. service string The service name. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 614 removeStream(onSuccess [, onError], stream) Remove a stream from session. Parameters: Name Type Argument Description onSuccess function The function to call when success. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. stream stream The Stream to be removed Source: elastos-trinity-plugins-carrier/www/carrier.js, line 573 replyRequest(onSuccess [, onError], status, reason) Reply the session request from friend. This function will send a session response to friend. Parameters: Name Type Argument Description onSuccess function The function to call when success. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. status number The status code of the response. 0 is success, otherwise is error reason string The error message if status is error, or null if success Source: elastos-trinity-plugins-carrier/www/carrier.js, line 505 request(onSuccess [, onError], handler) Send session request to the friend. Parameters: Name Type Argument Description onSuccess function The function to call when success. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. handler onSessionRequestComplete A handler to the SessionRequestCompleteHandler to receive the session response Source: elastos-trinity-plugins-carrier/www/carrier.js, line 487 start(onSuccess [, onError], sdp) Begin to start a session. All streams in current session will try to connect with remote friend, The stream status will update to application by stream's StreamHandler. Parameters: Name Type Argument Description onSuccess function The function to call when success. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. sdp string The remote user's SDP. Reference: https://tools.ietf.org/html/rfc4566 Source: elastos-trinity-plugins-carrier/www/carrier.js, line 519 × Search results Close "},"module-CarrierPlugin-Stream.html":{"id":"module-CarrierPlugin-Stream.html","title":"Class: Stream","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Class: Stream CarrierPlugin~ Stream new Stream() The class representing Carrier stream. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 188 Members carrier Properties: Name Type Description carrier Carrier Parent carrier object. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 195 id Properties: Name Type Description id number Stream ID. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 193 session Properties: Name Type Description session Session Parent session object. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 197 Methods closeChannel(onSuccess [, onError], channel) Close a new channel on multiplexing stream. If the stream is in multiplexing mode, application can not call this function. Parameters: Name Type Argument Description onSuccess function The function to call when success. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. channel number The channel ID to close Source: elastos-trinity-plugins-carrier/www/carrier.js, line 366 closePortForwarding(onSuccess [, onError], portForwarding) Close a port forwarding. If the stream is in multiplexing mode, application can not call this function. Parameters: Name Type Argument Description onSuccess function The function to call when success. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. portForwarding number The portforwarding ID. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 430 getTransportInfo(onSuccess [, onError]) Get tranport info of carrier stream. Parameters: Name Type Argument Description onSuccess function The function to call when success, the param is a TransportInfo object onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 330 on(name, callback) Add or remove Stream callback. Parameters: Name Type Description name string The callback name. callback function The function to add or change callback function. If set to null, will remove callback. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 303 openChannel(onSuccess [, onError], cookie) Open a new channel on multiplexing stream. If the stream is in multiplexing mode, application can not call this function. Parameters: Name Type Argument Description onSuccess function The function to call when success, the param is a Number: New channel ID. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. cookie string The application defined data passed to remote peer Source: elastos-trinity-plugins-carrier/www/carrier.js, line 354 openPortForwarding(onSuccess [, onError], service, protocol, host, port) Open a port forwarding to remote service over multiplexing. If the stream is in multiplexing mode, application can not call this function. Parameters: Name Type Argument Description onSuccess function The function to call when success, the param is a Number: Port forwarding ID. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. service string The remote service name protocol PortForwardingProtocol Port forwarding protocol host string Local host or ip to binding. If host is null, port forwarding will bind to localhost port number Local port to binding. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 418 pendChannel(onSuccess [, onError], channel) Request remote peer to pend channel data sending. If the stream is in multiplexing mode, application can not call this function. Parameters: Name Type Argument Description onSuccess function The function to call when success. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. channel number The current channel ID. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 391 resumeChannel(onSuccess [, onError], channel) Request remote peer to resume channel data sending. If the stream is in multiplexing mode, application can not call this function. Parameters: Name Type Argument Description onSuccess function The function to call when success. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. channel number The current channel ID. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 403 write(onSuccess [, onError], data) Send outgoing data to remote peer. If the stream is in multiplexing mode, application can not call this function. Parameters: Name Type Argument Description onSuccess function The function to call when success, the param is a Number: Bytes of data sent. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. data base64 The send data. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 342 writeChannel(onSuccess [, onError], channel, data) Send outgoing data to remote peer. If the stream is in multiplexing mode, application can not call this function. Parameters: Name Type Argument Description onSuccess function The function to call when success, the param is a Number: Bytes of data sent. onError function &lt;optional&gt; The function to call when error, the param is a String. Or set to null. channel number The current channel ID. data base64 The send data. Source: elastos-trinity-plugins-carrier/www/carrier.js, line 379 × Search results Close "},"module-Connection.html":{"id":"module-Connection.html","title":"Module: Connection","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Module: Connection Network status Source: cordova-plugin-network-information/www/Connection.js, line 23 Module: Connection Source: cordova-plugin-network-information/www/network.js, line 91 Example var connectionStatus = navigator.connection.type; × Search results Close "},"module-Flashlight.html":{"id":"module-Flashlight.html","title":"Module: Flashlight","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Module: Flashlight Source: cordova-plugin-flashlight/www/Flashlight.js, line 6 Methods available() Source: cordova-plugin-flashlight/www/Flashlight.js, line 13 isSwitchedOn() Source: cordova-plugin-flashlight/www/Flashlight.js, line 38 switchOff() Source: cordova-plugin-flashlight/www/Flashlight.js, line 25 switchOn() Source: cordova-plugin-flashlight/www/Flashlight.js, line 19 toggle() Source: cordova-plugin-flashlight/www/Flashlight.js, line 30 × Search results Close "},"module-Geolocation.html":{"id":"module-Geolocation.html","title":"Module: Geolocation","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Module: Geolocation Source: cordova-plugin-geolocation/www/geolocation.js, line 26 Methods &lt;inner&gt; clearWatch(id) Clears the specified heading watch. Parameters: Name Type Description id String The ID of the watch returned from #watchPosition Source: cordova-plugin-geolocation/www/geolocation.js, line 205 &lt;inner&gt; getCurrentPosition(successCallback, errorCallback, options) Asynchronously acquires the current position. Parameters: Name Type Description successCallback function The function to call when the position data is available errorCallback function The function to call when there is an error getting the heading position. (OPTIONAL) options PositionOptions The options for getting the position data. (OPTIONAL) Source: cordova-plugin-geolocation/www/geolocation.js, line 76 &lt;inner&gt; watchPosition(successCallback, errorCallback, options) Asynchronously watches the geolocation for changes to geolocation. When a change occurs, the successCallback is called with the new location. Parameters: Name Type Description successCallback function The function to call each time the location data is available errorCallback function The function to call when there is an error getting the location data. (OPTIONAL) options PositionOptions The options for getting the location data such as frequency. (OPTIONAL) Source: cordova-plugin-geolocation/www/geolocation.js, line 152 Returns: String The watch id that must be passed to #clearWatch to stop watching. × Search results Close "},"module-InAppBrowser.html":{"id":"module-InAppBrowser.html","title":"Module: InAppBrowser","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Module: InAppBrowser Source: cordova-plugin-inappbrowser/www/inappbrowser.js, line 104 × Search results Close "},"module-Notification.html":{"id":"module-Notification.html","title":"Module: Notification","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Module: Notification Source: cordova-plugin-dialogs/www/notification.js, line 32 Methods &lt;static&gt; alert(message, completeCallback, title, buttonLabel) Open a native alert dialog, with a customizable title and button text. Parameters: Name Type Description message String Message to print in the body of the alert completeCallback function The callback that is called when user clicks on a button. title String Title of the alert dialog (default: Alert) buttonLabel String Label of the close button (default: OK) Source: cordova-plugin-dialogs/www/notification.js, line 42 &lt;static&gt; beep(count) Causes the device to beep. On Android, the default notification ringtone is played \"count\" times. Parameters: Name Type Description count Integer The number of beeps. Source: cordova-plugin-dialogs/www/notification.js, line 107 &lt;static&gt; confirm(message, resultCallback, title, buttonLabels) Open a native confirm dialog, with a customizable title and button text. The result that the user selects is returned to the result callback. Parameters: Name Type Description message String Message to print in the body of the alert resultCallback function The callback that is called when user clicks on a button. title String Title of the alert dialog (default: Confirm) buttonLabels Array Array of the labels of the buttons (default: ['OK', 'Cancel']) Source: cordova-plugin-dialogs/www/notification.js, line 58 &lt;static&gt; prompt(message, resultCallback, title, buttonLabels, defaultText) Open a native prompt dialog, with a customizable title and button text. The following results are returned to the result callback: buttonIndex Index number of the button selected. input1 The text entered in the prompt dialog box. Parameters: Name Type Description message String Dialog message to display (default: \"Prompt message\") resultCallback function The callback that is called when user clicks on a button. title String Title of the dialog (default: \"Prompt\") buttonLabels Array Array of strings for the button labels (default: [\"OK\",\"Cancel\"]) defaultText String Textbox input value (default: empty string) Source: cordova-plugin-dialogs/www/notification.js, line 85 × Search results Close "},"module-Position.html":{"id":"module-Position.html","title":"Module: Position","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Module: Position Source: cordova-plugin-geolocation/www/Position.js, line 26 × Search results Close "},"module-ScreenOrientation.html":{"id":"module-ScreenOrientation.html","title":"Module: ScreenOrientation","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Module: ScreenOrientation Source: cordova-plugin-screen-orientation/www/screenorientation.js, line 157 × Search results Close "},"module-Splashscreen.html":{"id":"module-Splashscreen.html","title":"Module: Splashscreen","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Module: Splashscreen Source: cordova-plugin-splashscreen/www/splashscreen.js, line 40 Example navigator.splashscreen.hide(); or navigator.splashscreen.show(); × Search results Close "},"module-StatusBar.html":{"id":"module-StatusBar.html","title":"Module: StatusBar","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Module: StatusBar Source: cordova-plugin-statusbar/www/statusbar.js, line 50 Members &lt;static&gt; isVisible Properties: Name Type Description isVisible boolean Source: cordova-plugin-statusbar/www/statusbar.js, line 52 Methods &lt;static&gt; backgroundColorByHexString(hexString) Parameters: Name Type Description hexString boolean Source: cordova-plugin-statusbar/www/statusbar.js, line 91 &lt;static&gt; backgroundColorByName(colorname) Parameters: Name Type Description colorname boolean Source: cordova-plugin-statusbar/www/statusbar.js, line 84 &lt;static&gt; hide() Source: cordova-plugin-statusbar/www/statusbar.js, line 104 &lt;static&gt; overlaysWebView(doOverlay) Parameters: Name Type Description doOverlay boolean Source: cordova-plugin-statusbar/www/statusbar.js, line 57 &lt;static&gt; show() Source: cordova-plugin-statusbar/www/statusbar.js, line 109 &lt;static&gt; styleBlackOpaque() Source: cordova-plugin-statusbar/www/statusbar.js, line 76 &lt;static&gt; styleBlackTranslucent() Source: cordova-plugin-statusbar/www/statusbar.js, line 71 &lt;static&gt; styleDefault() Source: cordova-plugin-statusbar/www/statusbar.js, line 61 &lt;static&gt; styleLightContent() Source: cordova-plugin-statusbar/www/statusbar.js, line 66 × Search results Close "},"module-Vibration.html":{"id":"module-Vibration.html","title":"Module: Vibration","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Module: Vibration Source: cordova-plugin-vibration/www/vibration.js, line 31 Methods &lt;static&gt; vibrate(param, param) Vibrates the device for a given amount of time or for a given pattern or immediately cancels any ongoing vibrations (depending on the parameter). Parameters: Name Type Description param Integer The number of milliseconds to vibrate (if 0, cancels vibration) param Array.&lt;number&gt; Pattern with which to vibrate the device. Pass in an array of integers that are the durations for which to turn on or off the vibrator in milliseconds. The FIRST value indicates the number of milliseconds for which to keep the vibrator ON before turning it off. The NEXT value indicates the number of milliseconds for which to keep the vibrator OFF before turning it on. Subsequent values alternate between durations in milliseconds to turn the vibrator off or to turn the vibrator on. (if empty, cancels vibration) Source: cordova-plugin-vibration/www/vibration.js, line 56 × Search results Close "},"PositionError.html":{"id":"PositionError.html","title":"Class: PositionError","body":" Elastos Browser (Trinity) Modules AccelerationAccelerometerAppManagerAppServiceCameraCameraConstantsCameraPopoverHandleCameraPopoverOptionsCaptureCarrierPlugincarrierPluginConnectionFlashlightGeolocationInAppBrowserNotificationPositionScreenOrientationSplashscreenStatusBarVibration Classes BatteryClipboardCoordinatesDeviceFileReaderFileSystemFileUploadOptionsFileUploadResultFileWriterMediaAppManager~AppManagerAppService~AppServiceCarrierPlugin~CarrierCarrierPlugin~SessionCarrierPlugin~StreamPositionError Global CaptureAudioOptionsCaptureErrorCaptureImageOptionsCaptureVideoOptionsConfigurationDatacordovaDirectoryEntryDirectoryReaderEntryFileFileEntryFileErrorFlagsMediaFileMediaFileDataMetadatanamedColorsreadFailureCallbackreadSuccessCallbackresolveLocalFileSystemURL Class: PositionError PositionError new PositionError(code, message) Position error object Parameters: Name Type Description code message Source: cordova-plugin-geolocation/www/PositionError.js, line 29 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
